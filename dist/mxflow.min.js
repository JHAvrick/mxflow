/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["mxflow"] = factory();
	else
		root["mxflow"] = factory();
})(self, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/flow-util.ts":
/*!**************************!*\
  !*** ./src/flow-util.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"swapValues\": () => (/* binding */ swapValues),\n/* harmony export */   \"clone\": () => (/* binding */ clone),\n/* harmony export */   \"clamp\": () => (/* binding */ clamp),\n/* harmony export */   \"distance\": () => (/* binding */ distance),\n/* harmony export */   \"midpoint\": () => (/* binding */ midpoint),\n/* harmony export */   \"throttle\": () => (/* binding */ throttle),\n/* harmony export */   \"flatten\": () => (/* binding */ flatten),\n/* harmony export */   \"resolveProperty\": () => (/* binding */ resolveProperty),\n/* harmony export */   \"assignProperty\": () => (/* binding */ assignProperty),\n/* harmony export */   \"getBezierPath\": () => (/* binding */ getBezierPath),\n/* harmony export */   \"intersectRect\": () => (/* binding */ intersectRect),\n/* harmony export */   \"DefaultNodeTemplate\": () => (/* binding */ DefaultNodeTemplate),\n/* harmony export */   \"parseNodeTemplate\": () => (/* binding */ parseNodeTemplate),\n/* harmony export */   \"createNode\": () => (/* binding */ createNode),\n/* harmony export */   \"getEdgeCompositeKey\": () => (/* binding */ getEdgeCompositeKey),\n/* harmony export */   \"getLinkCompositeKey\": () => (/* binding */ getLinkCompositeKey),\n/* harmony export */   \"createEdge\": () => (/* binding */ createEdge),\n/* harmony export */   \"getEdgeLatchPos\": () => (/* binding */ getEdgeLatchPos),\n/* harmony export */   \"createLink\": () => (/* binding */ createLink),\n/* harmony export */   \"generateFlowEl\": () => (/* binding */ generateFlowEl),\n/* harmony export */   \"addItemClass\": () => (/* binding */ addItemClass),\n/* harmony export */   \"removeItemClass\": () => (/* binding */ removeItemClass),\n/* harmony export */   \"applyNodePosition\": () => (/* binding */ applyNodePosition),\n/* harmony export */   \"applyLinkPosition\": () => (/* binding */ applyLinkPosition),\n/* harmony export */   \"applyAllLinkPositions\": () => (/* binding */ applyAllLinkPositions)\n/* harmony export */ });\n/* harmony import */ var types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! types/flow.types.v2 */ \"./src/types/flow.types.v2.ts\");\n/* harmony import */ var _helpers_background__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers/background */ \"./src/helpers/background.ts\");\n\n\n/**\r\n * Generates a curved SVG bezier path. The severity of the curve is controlled by the weight parameter.\r\n *\r\n * See https://codepen.io/GrinninColossus/pen/PopzzNE?editors=1010\r\n */\n\nconst getBezierPath = (x1, y1, x2, y2, weight) => {\n  let dx = Math.abs(x2 - x1) * weight;\n  let bx2 = Math.max(x1, x2) - dx;\n  var bx3 = Math.min(x1, x2) + dx;\n  return `M${x1} ${y1} C ${bx2} ${y1} ${bx3} ${y2} ${x2} ${y2}`;\n};\n\nconst swapValues = (var1, var2) => [var1, var2];\n/**\r\n * Clone simpe objects\r\n */\n\n\nconst clone = obj => JSON.parse(JSON.stringify(obj));\n/**\r\n * Clamp value between min/max\r\n */\n\n\nconst clamp = (num, min, max) => Math.min(Math.max(num, min), max);\n/**\r\n * Get distance between two points.\r\n */\n\n\nconst distance = (x1, y1, x2, y2) => {\n  return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n};\n/**\r\n * Creates a simple throttled function\r\n */\n\n\nconst throttle = (callback, limit) => {\n  var waiting = false;\n  return function () {\n    if (!waiting) {\n      callback(...arguments);\n      waiting = true;\n      setTimeout(function () {\n        waiting = false;\n      }, limit);\n    }\n  };\n};\n/**\r\n * Get midpoint between two points\r\n */\n\n\nconst midpoint = (x1, y1, x2, y2) => {\n  return [(x1 + x2) / 2, (y1 + y2) / 2];\n};\n\nconst flatten = function (obj) {\n  let roots = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let sep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '.';\n  return Object.keys(obj).reduce((memo, prop) => Object.assign({}, memo, Object.prototype.toString.call(obj[prop]) === '[object Object]' // keep working if value is an object\n  ? flatten(obj[prop], roots.concat([prop]), sep) // include current prop and value and prefix prop with the roots\n  : {\n    [roots.concat([prop]).join(sep)]: obj[prop]\n  }), {});\n};\n/**\r\n * Resolve a property on an object using an accessor string.\r\n */\n\n\nconst resolveProperty = (path, obj) => {\n  return path.split('.').reduce((prev, curr) => {\n    return prev ? prev[curr] : null;\n  }, obj || self);\n};\n/**\r\n * Assigns value to property using accessor string. If the given path does not exist,\r\n * it is created.\r\n */\n\n\nconst assignProperty = (path, obj, val) => {\n  let parts = path.split('.');\n\n  for (let i = 0; i < parts.length - 1; i++) {\n    if (obj[parts[i]] == null || obj[parts[i]] == undefined) {\n      obj[parts[i]] = {};\n    }\n\n    obj = obj[parts[i]];\n  }\n\n  obj[parts[parts.length - 1]] = val;\n};\n/**\r\n * Determines whether to rects intersect\r\n *\r\n * @param r1\r\n * @param r2\r\n * @returns\r\n */\n\n\nconst intersectRect = (r1, r2) => {\n  return !(r2.left > r1.right || r2.right < r1.left || r2.top > r1.bottom || r2.bottom < r1.top);\n};\n\nconst enumFromStringValue = (enm, value) => {\n  return Object.values(enm).includes(value) ? value : undefined;\n};\n\nconst DefaultNodeTemplate =\n/* HTML */\n`\n    <div ${types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowAttr.NodeTemplate}>\n        <ul ${types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowAttr.EdgeGroup}=\"inputs\" ${types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowAttr.EdgeLatch}=\"center\">\n            <!-- Input Edges Dynamically Populated -->\n        </ul>\n        <div ${types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowAttr.NodeContent}>\n            <!-- Node Content as Provided by User -->\n        </div>\n        <ul ${types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowAttr.EdgeGroup}=\"outputs\" ${types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowAttr.EdgeLatch}=\"center\">\n            <!-- Output Edges Dynamically Populated -->\n        </ul>\n    </div>\n`;\n\nconst buildEdgeGroups = dom => {\n  let edgeGroups = new Map();\n  let groupNodes = dom.querySelectorAll(`ul[${types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowAttr.EdgeGroup}]`);\n  groupNodes.forEach(node => {\n    var _a;\n\n    let key = node.getAttribute(types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowAttr.EdgeGroup);\n    let latchPos = enumFromStringValue(types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.LinkLatchPosition, (_a = node.getAttribute(types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowAttr.EdgeLatch)) !== null && _a !== void 0 ? _a : 'center');\n    node.classList.add(types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.EdgeGroup);\n    edgeGroups.set(key, {\n      groupKey: key,\n      groupEl: node,\n      latchPos: latchPos !== null && latchPos !== void 0 ? latchPos : types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.LinkLatchPosition.CENTER\n    });\n  });\n  return edgeGroups;\n};\n\nconst parseNodeTemplate = template => {\n  let dom = new DOMParser().parseFromString(template, \"text/html\"); //Get and create node\n\n  let el = dom.querySelector(`*[${types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowAttr.NodeTemplate}]`);\n  let content = dom.querySelector(`*[${types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowAttr.NodeContent}]`); //Ensure all template elements have been included\n\n  if (!el\n  /*|| !inputs || !outputs */\n  || !content) {\n    throw new Error('Node template is missing required element.');\n  } //Ensure all template elements are of the correct type\n\n\n  if (!(el instanceof HTMLElement)\n  /* || !(inputs instanceof HTMLUListElement) || !(outputs instanceof HTMLUListElement) */\n  || !(content instanceof HTMLElement)) {\n    throw new Error('One more more template elements is of the incorrect element type.');\n  }\n\n  return [dom, el, content];\n};\n\nconst applyNodeAttributes = (el, key, z) => {\n  el.setAttribute(types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowAttr.Type, types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowItemType.Node);\n  el.setAttribute(types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowAttr.Key, key);\n  el.setAttribute('draggable', \"false\");\n\n  el.ondragstart = e => e.preventDefault();\n\n  el.style.display = 'inline-flex';\n  el.style.justifyContent = 'space-between';\n  el.style.touchAction = 'none';\n  el.style.userSelect = 'none';\n  el.style.pointerEvents = 'all';\n  el.style.position = 'absolute';\n  el.style.left = \"0px\";\n  el.style.top = \"0px\";\n  el.style.zIndex = z.toString();\n};\n\nconst createNode = opts => {\n  var _a, _b, _c, _d;\n\n  let template = (_a = opts.template) !== null && _a !== void 0 ? _a : DefaultNodeTemplate;\n  let dom, el, content;\n  [dom, el, content] = parseNodeTemplate(template); //Ensure all template elements have been included\n\n  if (!el\n  /*|| !inputs || !outputs */\n  || !content) {\n    throw new Error('Node template is missing required element.');\n  } //Ensure all template elements are of the correct type\n\n\n  if (!(el instanceof HTMLElement)\n  /* || !(inputs instanceof HTMLUListElement) || !(outputs instanceof HTMLUListElement) */\n  || !(content instanceof HTMLElement)) {\n    throw new Error('One more more template element is of the incorrect element type.');\n  }\n\n  if (el instanceof HTMLElement) {\n    applyNodeAttributes(el, opts.key, opts.z);\n  } else {\n    throw new Error('No parent HTMLElement found in Node template (w/ class \"mx-flow-node\").');\n  }\n\n  el.classList.add(types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.Node);\n  content.classList.add(types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.NodeContent); //Add any custom classes - these are provided by the user\n\n  let userClass = [];\n\n  if (opts.nodeClass && opts.nodeClass.length > 0) {\n    if (Array.isArray(opts.nodeClass)) {\n      el.classList.add(...opts.nodeClass);\n      userClass = opts.nodeClass;\n    } else {\n      el.classList.add(opts.nodeClass);\n      userClass = [opts.nodeClass];\n    }\n  }\n\n  if (opts.width) el.style.width = typeof opts.width === 'number' ? `${opts.width}px` : opts.width;\n  if (opts.height) el.style.height = typeof opts.height === 'number' ? `${opts.height}px` : opts.height;\n  return {\n    type: types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowItemType.Node,\n    template: template,\n    key: opts.key,\n    el: el,\n    contentEl: content,\n    edgeGroups: buildEdgeGroups(dom),\n    x: opts.x,\n    y: opts.y,\n    z: opts.z,\n    deltaX: 0,\n    deltaY: 0,\n    width: (_b = opts.width) !== null && _b !== void 0 ? _b : 'auto',\n    height: (_c = opts.height) !== null && _c !== void 0 ? _c : 'auto',\n    data: (_d = opts.data) !== null && _d !== void 0 ? _d : {},\n    class: userClass\n  };\n};\n\nconst getEdgeCompositeKey = edge => {\n  return `${edge.nodeKey}:${edge.edgeKey}`;\n};\n\nconst createEdge = (node, groupKey, edgeKey, edgeClass) => {\n  let group = node.edgeGroups.get(groupKey);\n\n  if (!group) {\n    throw new Error(`createEdge(): Unable to find group with key \"${groupKey}\" in node template.`);\n  }\n\n  let el = document.createElement('li');\n  el.classList.add(types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.Edge);\n  el.setAttribute(types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowAttr.Type, types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowItemType.Edge);\n  el.setAttribute(types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowAttr.Key, `${node.key}:${edgeKey}`);\n  el.setAttribute('draggable', \"false\");\n\n  el.ondragstart = e => e.preventDefault();\n\n  if (edgeClass && edgeClass.length > 0) {\n    el.classList.add(edgeClass);\n  }\n\n  return {\n    type: types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowItemType.Edge,\n    key: `${node.key}:${edgeKey}`,\n    group: group,\n    nodeKey: node.key,\n    edgeKey: edgeKey,\n    el: el,\n    data: {},\n    class: edgeClass !== null && edgeClass !== void 0 ? edgeClass : ''\n  };\n};\n/**\r\n * Given an edge, returns it's latch position as defined by its edge group.\r\n *\r\n * @param edge - The target Edge\r\n * @param offsetX - X axis offset to factor in\r\n * @param offsetY - Y axis offset to factor in\r\n * @returns\r\n */\n\n\nconst getEdgeLatchPos = function (edge) {\n  let offsetX = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let offsetY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let rect = edge.el.getBoundingClientRect();\n\n  switch (edge.group.latchPos.toString()) {\n    case 'top':\n      return {\n        x: rect.left - offsetX + rect.width / 2,\n        y: rect.top - offsetY\n      };\n\n    case 'right':\n      return {\n        x: rect.left - offsetX + rect.width,\n        y: rect.top - offsetY + rect.height / 2\n      };\n\n    case 'bottom':\n      return {\n        x: rect.left - offsetX + rect.width / 2,\n        y: rect.top - offsetY + rect.height\n      };\n\n    case 'left':\n      return {\n        x: rect.left - offsetX,\n        y: rect.top - offsetY + rect.height / 2\n      };\n\n    case 'center':\n    default:\n      return {\n        x: rect.left - offsetX + rect.width / 2,\n        y: rect.top - offsetY + rect.height / 2\n      };\n  }\n};\n\nconst getLinkCompositeKey = opts => {\n  return `${opts.fromNode}:${opts.fromEdge}:${opts.toNode}:${opts.toEdge}`;\n};\n\nconst createLink = (opts, groupClass) => {\n  let key = getLinkCompositeKey(opts);\n  let band1 = document.createElementNS(\"http://www.w3.org/2000/svg\", 'path');\n  band1.classList.add(types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.LinkBand1);\n  band1.style.pointerEvents = 'auto';\n  let band2 = document.createElementNS(\"http://www.w3.org/2000/svg\", 'path');\n  band2.classList.add(types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.LinkBand2);\n  band2.style.pointerEvents = 'none';\n  let band3 = document.createElementNS(\"http://www.w3.org/2000/svg\", 'path');\n  band3.classList.add(types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.LinkBand3);\n  band3.style.pointerEvents = 'none';\n  let text = document.createElementNS(\"http://www.w3.org/2000/svg\", 'text');\n  text.textContent = 'Label';\n  text.style.color = 'white';\n  text.setAttribute('width', \"300px\");\n  text.setAttribute('height', \"300px\");\n  text.setAttribute('textAnchor', 'middle');\n  let labelPath = document.createElementNS(\"http://www.w3.org/2000/svg\", 'textPath');\n  labelPath.style.pointerEvents = 'none';\n  text.appendChild(labelPath);\n  let group = document.createElementNS(\"http://www.w3.org/2000/svg\", 'g');\n  group.setAttribute(types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowAttr.Type, types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowItemType.Link);\n  group.setAttribute(types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowAttr.Key, key);\n  group.classList.add(types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.Link);\n  group.style.pointerEvents = 'none';\n  group.setAttribute('draggable', \"false\");\n\n  group.ondragstart = e => e.preventDefault();\n\n  group.appendChild(band1);\n  group.appendChild(band2);\n  group.appendChild(band3);\n  group.appendChild(text);\n\n  if (groupClass && groupClass.length > 0) {\n    group.classList.add(groupClass);\n  }\n\n  return {\n    type: types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowItemType.Link,\n    key: key,\n    fromNode: opts.fromNode,\n    fromEdge: opts.fromEdge,\n    toNode: opts.toNode,\n    toEdge: opts.toEdge,\n    el: group,\n    band1: band1,\n    band2: band2,\n    band3: band3,\n    labelEl: labelPath,\n    data: {}\n  };\n};\n\nconst generateFlowEl = (targetEl, opts) => {\n  let id = 'mxflow-instance-' + Date.now();\n  let bg = opts.background.html;\n\n  if (opts.background.type === 'grid' || opts.background.type === 'dots') {\n    bg = (0,_helpers_background__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(opts.background.type, opts.background.size, opts.background.radius);\n  }\n\n  targetEl.insertAdjacentHTML('afterbegin',\n  /* HTML */\n  `\n        <div id=\"${id}\" class=\"${types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.Container}\"\n            tabindex=\"1\" \n            style=\"position:relative; display:block; width:100%; height:100%; overflow:hidden; pointer-events:auto; padding:0px; outline:none\"\n            ondragstart=\"event.preventDefault()\">\n            <svg style=\"position:absolute; left:0px; top:0px; width:100%; height:100%; pointer-events:none; padding: 0px; z-index:1000;\">\n                <rect class=\"${types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.Lasso}\" \n                    ondragstart=\"event.preventDefault()\"\n                    style=\"position:absolute; display:none; z-index: 3; pointer-events:none;\">\n                </rect>\n            </svg>\n\n            <!-- <div class=\"${types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.Lasso}\"\n                ondragstart=\"event.preventDefault()\"\n                style=\"position:absolute; display:none; z-index: 3; pointer-events:none;\">\n            </div> -->\n            <div class=\"${types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.Context}\"\n                ondragstart=\"event.preventDefault()\"\n                style=\"display:none; position:absolute; z-index: 10;\">\n                <!-- Context Menu Populated Here -->\n            </div>\n            <div class=\"${types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.Root}\"\n                ${types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowAttr.Type}=\"graph\"\n                ${types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowAttr.Key}=\"graph\"\n                ondragstart=\"event.preventDefault()\"\n                style=\"position:relative; height:${opts.height}px; width:${opts.width}px; pointer-events:auto; transform-origin: 0 0; touch-action: none;\">\n\n                <div class=\"${types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.Background}\" style=\"width:100%;height:100%;display:${opts.background.type === 'none' ? 'none' : 'block'};\">\n                    ${bg}\n                </div>\n                <svg class=\"${types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.Links}\" \n                        ondragstart=\"event.preventDefault()\"\n                        style=\"position:absolute; left:0px; top:0px; width:100%; height:100%; pointer-events:none; padding: 0px;\">\n                        <!-- Links Populated Here -->\n                </svg>\n                <svg class=\"${types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.GhostLinks}\" \n                     ondragstart=\"event.preventDefault()\"\n                     style=\"position:absolute; left:0px; top:0px; width:100%; height:100%; pointer-events:none; padding: 0px; z-index:1000;\">\n                     <g style=\"position:absolute; pointer-events:none; overflow:visible; \">\n                        <path class=\"${types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.GhostLink}\" style=\"display:none;\"></path>\n                     </g>\n                </svg>\n                <div class=\"${types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.Nodes}\">\n                    <!-- Nodes Populated Here -->\n                </div>\n            </div>\n        </div>\n    `);\n  return {\n    instanceId: id,\n    containerEl: targetEl.querySelector(\".\" + types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.Container),\n    lassoEl: targetEl.querySelector(\".\" + types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.Lasso),\n    contextEl: targetEl.querySelector(\".\" + types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.Context),\n    rootEl: targetEl.querySelector(\".\" + types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.Root),\n    bgEl: targetEl.querySelector('.' + types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.Background),\n    nodeContainerEl: targetEl.querySelector(\".\" + types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.Nodes),\n    linkContainerEl: targetEl.querySelector(\".\" + types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.Links),\n    ghostLinkContainerEl: targetEl.querySelector(\".\" + types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.GhostLinks),\n    ghostLinkEl: targetEl.querySelector(\".\" + types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.GhostLink)\n  };\n};\n\nconst addItemClass = (item, c) => {\n  switch (true) {\n    case Array.isArray(item):\n      item.forEach(item => item.el.classList.add(c));\n      break;\n\n    case item instanceof Map:\n      item.forEach(item => item.el.classList.add(c));\n      break;\n\n    default:\n      item.el.classList.add(c);\n  }\n};\n\nconst removeItemClass = (item, c) => {\n  switch (true) {\n    case Array.isArray(item):\n      item.forEach(item => item.el.classList.remove(c));\n      break;\n\n    case item instanceof Map:\n      item.forEach(item => item.el.classList.remove(c));\n      break;\n\n    default:\n      item.el.classList.remove(c);\n  }\n};\n\nconst applyNodePosition = node => {\n  node.el.style.transform = `translate(${node.x + node.deltaX}px, ${node.y + node.deltaY}px)`;\n  return node;\n};\n\nfunction _getQBezierValue(t, p1, p2, p3) {\n  var iT = 1 - t;\n  return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3;\n}\n\nfunction getQuadraticCurvePoint(startX, startY, cpX, cpY, endX, endY, position) {\n  return {\n    x: _getQBezierValue(position, startX, cpX, endX),\n    y: _getQBezierValue(position, startY, cpY, endY)\n  };\n}\n\nconst applyLinkPosition = (api, link) => {\n  var _a;\n\n  let transform = api.state.transform;\n  let fromEdge = api.state.edges.get(`${link.fromNode}:${link.fromEdge}`);\n  let toEdge = api.state.edges.get(`${link.toNode}:${link.toEdge}`);\n\n  if (!fromEdge || !toEdge) {\n    throw new Error('MXFlow.applyLinkPosition(): Cannot apply link position for undefined edge');\n  } // let fromEdgeRect = <DOMRect> fromEdge!.el.getBoundingClientRect();\n  // let toEdgeRect = <DOMRect> toEdge!.el.getBoundingClientRect();\n\n\n  let containerRect = api.dom.containerEl.getBoundingClientRect();\n  let offsetY = containerRect.top;\n  let offsetX = containerRect.left;\n  let latchFrom = getEdgeLatchPos(fromEdge, offsetX, offsetY);\n  let latchTo = getEdgeLatchPos(toEdge, offsetX, offsetY);\n  let x1 = latchFrom.x;\n  let y1 = latchFrom.y;\n  let x2 = latchTo.x;\n  let y2 = latchTo.y;\n\n  if (x1 > x2) {\n    [x1, x2] = swapValues(x1, x2);\n    [y1, y2] = swapValues(y1, y2);\n  }\n\n  let bezier = getBezierPath((x1 - transform.x) / transform.scale, (y1 - transform.y) / transform.scale, (x2 - transform.x) / transform.scale, (y2 - transform.y) / transform.scale, (_a = api.opts.bezierWeight) !== null && _a !== void 0 ? _a : 0.675); //Apply our bezier curve to both the inner and outer link elements\n\n  link.band1.setAttribute('d', bezier);\n  link.band2.setAttribute('d', bezier);\n  link.band3.setAttribute('d', bezier);\n};\n\nconst applyAllLinkPositions = api => {\n  api.state.links.forEach(link => applyLinkPosition(api, link));\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0EsTUFBSSxDQUFDLEtBQUwsQ0FBVyxZQUFYLENBQXdCLEdBQXhCLEVBQTZCLE1BQTdCO0FBQ0gsQ0F2Q0Q7O0FBeUNBLE1BQU0scUJBQXFCLEdBQUksR0FBRCxJQUF1QjtBQUNqRCxLQUFHLENBQUMsS0FBSixDQUFVLEtBQVYsQ0FBZ0IsT0FBaEIsQ0FBd0IsSUFBSSxJQUFJLGlCQUFpQixDQUFDLEdBQUQsRUFBTSxJQUFOLENBQWpEO0FBQ0gsQ0FGRCIsInNvdXJjZXMiOlsid2VicGFjazovL214Zmxvdy8uL3NyYy9mbG93LXV0aWwudHM/YjQ3YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBGbG93VHlwZXMgZnJvbSAndHlwZXMvZmxvdy50eXBlcy52Mic7XHJcbmltcG9ydCBnZW5lcmF0ZUJhY2tncm91bmQgZnJvbSAnLi9oZWxwZXJzL2JhY2tncm91bmQnO1xyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIGN1cnZlZCBTVkcgYmV6aWVyIHBhdGguIFRoZSBzZXZlcml0eSBvZiB0aGUgY3VydmUgaXMgY29udHJvbGxlZCBieSB0aGUgd2VpZ2h0IHBhcmFtZXRlci5cclxuICogXHJcbiAqIFNlZSBodHRwczovL2NvZGVwZW4uaW8vR3Jpbm5pbkNvbG9zc3VzL3Blbi9Qb3B6ek5FP2VkaXRvcnM9MTAxMFxyXG4gKi9cclxuY29uc3QgZ2V0QmV6aWVyUGF0aCA9ICh4MTogbnVtYmVyLCB5MTogbnVtYmVyLCB4MjogbnVtYmVyLCB5MjogbnVtYmVyLCB3ZWlnaHQ6IG51bWJlcikgPT4ge1xyXG4gICAgbGV0IGR4ID0gTWF0aC5hYnMoeDIgLSB4MSkgKiB3ZWlnaHQ7XHJcbiAgICBsZXQgYngyID0gTWF0aC5tYXgoeDEsIHgyKSAtIGR4O1xyXG4gICAgdmFyIGJ4MyA9IE1hdGgubWluKHgxLCB4MikgKyBkeDtcclxuICAgIHJldHVybiBgTSR7eDF9ICR7eTF9IEMgJHtieDJ9ICR7eTF9ICR7YngzfSAke3kyfSAke3gyfSAke3kyfWBcclxufVxyXG5cclxuY29uc3Qgc3dhcFZhbHVlcyA9IDxUPiAodmFyMTogVCwgdmFyMjogVCkgOiBbVCwgVF0gPT4gW3ZhcjEsIHZhcjJdO1xyXG5cclxuLyoqXHJcbiAqIENsb25lIHNpbXBlIG9iamVjdHNcclxuICovXHJcbmNvbnN0IGNsb25lID0gKG9iajogT2JqZWN0KSA9PiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xyXG5cclxuLyoqXHJcbiAqIENsYW1wIHZhbHVlIGJldHdlZW4gbWluL21heFxyXG4gKi9cclxuY29uc3QgY2xhbXAgPSAobnVtOiBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcikgPT4gTWF0aC5taW4oTWF0aC5tYXgobnVtLCBtaW4pLCBtYXgpO1xyXG5cclxuLyoqXHJcbiAqIEdldCBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXHJcbiAqL1xyXG5jb25zdCBkaXN0YW5jZSA9ICh4MTogbnVtYmVyLCB5MTogbnVtYmVyLCB4MjogbnVtYmVyLCB5MjogbnVtYmVyKSA9PiB7XHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KCBNYXRoLnBvdygoeDEteDIpLCAyKSArIE1hdGgucG93KCh5MS15MiksIDIpICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgc2ltcGxlIHRocm90dGxlZCBmdW5jdGlvblxyXG4gKi9cclxuY29uc3QgdGhyb3R0bGUgPSAoY2FsbGJhY2s6IEZ1bmN0aW9uLCBsaW1pdDogbnVtYmVyKSA9PiB7XHJcbiAgICB2YXIgd2FpdGluZyA9IGZhbHNlO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzOiBhbnlbXSkge1xyXG4gICAgICAgIGlmICghd2FpdGluZykgeyAgICAgICBcclxuICAgICAgICAgICAgY2FsbGJhY2soLi4uYXJncyk7XHJcbiAgICAgICAgICAgIHdhaXRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHdhaXRpbmcgPSBmYWxzZTsgXHJcbiAgICAgICAgICAgIH0sIGxpbWl0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgbWlkcG9pbnQgYmV0d2VlbiB0d28gcG9pbnRzXHJcbiAqL1xyXG5jb25zdCBtaWRwb2ludCA9ICh4MTogbnVtYmVyLCB5MTogbnVtYmVyLCB4MjogbnVtYmVyLCB5MjogbnVtYmVyKSA9PiB7XHJcblx0cmV0dXJuIFsoeDEgKyB4MikgLyAyLCAoeTEgKyB5MikgLyAyXTtcclxufVxyXG5cclxuXHJcbmNvbnN0IGZsYXR0ZW4gPSAob2JqOiB7IFtrZXk6c3RyaW5nIHwgbnVtYmVyXTogYW55IH0sIHJvb3RzOiBzdHJpbmdbXSA9IFtdLCBzZXAgPSAnLicpIDogIHsgW2tleTpzdHJpbmcgfCBudW1iZXJdOiBhbnkgfSA9PiB7XHJcbiAgICByZXR1cm4gT2JqZWN0XHJcbiAgICAgICAgLmtleXMob2JqKVxyXG4gICAgICAgIC5yZWR1Y2UoKG1lbW8sIHByb3ApID0+IE9iamVjdC5hc3NpZ24oe30sIG1lbW8sXHJcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmpbcHJvcF0pID09PSAnW29iamVjdCBPYmplY3RdJ1xyXG4gICAgICAgICAgICAgICAgLy8ga2VlcCB3b3JraW5nIGlmIHZhbHVlIGlzIGFuIG9iamVjdFxyXG4gICAgICAgICAgICAgICAgPyBmbGF0dGVuKG9ialtwcm9wXSwgcm9vdHMuY29uY2F0KFtwcm9wXSksIHNlcClcclxuICAgICAgICAgICAgICAgIC8vIGluY2x1ZGUgY3VycmVudCBwcm9wIGFuZCB2YWx1ZSBhbmQgcHJlZml4IHByb3Agd2l0aCB0aGUgcm9vdHNcclxuICAgICAgICAgICAgICAgIDogeyBbcm9vdHMuY29uY2F0KFtwcm9wXSkuam9pbihzZXApXTogb2JqW3Byb3BdIH1cclxuICAgICAgICApLCB7fSlcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlc29sdmUgYSBwcm9wZXJ0eSBvbiBhbiBvYmplY3QgdXNpbmcgYW4gYWNjZXNzb3Igc3RyaW5nLlxyXG4gKi9cclxuY29uc3QgcmVzb2x2ZVByb3BlcnR5ID0gKHBhdGg6IHN0cmluZywgb2JqOiB7IFtrZXk6c3RyaW5nXTogYW55IH0pID0+IHtcclxuICAgIHJldHVybiBwYXRoLnNwbGl0KCcuJykucmVkdWNlKChwcmV2LCBjdXJyKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHByZXYgPyBwcmV2W2N1cnJdIDogbnVsbDtcclxuICAgIH0sIG9iaiB8fCBzZWxmKVxyXG59XHJcblxyXG4vKipcclxuICogQXNzaWducyB2YWx1ZSB0byBwcm9wZXJ0eSB1c2luZyBhY2Nlc3NvciBzdHJpbmcuIElmIHRoZSBnaXZlbiBwYXRoIGRvZXMgbm90IGV4aXN0LFxyXG4gKiBpdCBpcyBjcmVhdGVkLlxyXG4gKi9cclxuY29uc3QgYXNzaWduUHJvcGVydHkgPSAocGF0aDogc3RyaW5nLCBvYmo6IHsgW2tleTpzdHJpbmcgfCBudW1iZXJdOiBhbnkgfSwgdmFsOiBhbnkpID0+IHtcclxuICAgIGxldCBwYXJ0cyA9IHBhdGguc3BsaXQoJy4nKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrKXtcclxuICAgICAgICBpZiAob2JqW3BhcnRzW2ldXSA9PSBudWxsIHx8IG9ialtwYXJ0c1tpXV0gPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG9ialtwYXJ0c1tpXV0gPSB7fTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG9iaiA9IG9ialtwYXJ0c1tpXV07XHJcbiAgICB9XHJcbiAgICBvYmpbcGFydHNbcGFydHMubGVuZ3RoIC0gMV1dID0gdmFsO1xyXG59XHJcblxyXG50eXBlIHJlY3QgPSB7XHJcbiAgICBsZWZ0OiBudW1iZXIsXHJcbiAgICByaWdodDogbnVtYmVyLFxyXG4gICAgdG9wOiBudW1iZXIsXHJcbiAgICBib3R0b206IG51bWJlclxyXG59XHJcblxyXG4vKipcclxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIHJlY3RzIGludGVyc2VjdFxyXG4gKiBcclxuICogQHBhcmFtIHIxIFxyXG4gKiBAcGFyYW0gcjIgXHJcbiAqIEByZXR1cm5zIFxyXG4gKi9cclxuY29uc3QgaW50ZXJzZWN0UmVjdCA9IChyMTogcmVjdCwgcjI6IHJlY3QpID0+IHtcclxuICAgIHJldHVybiAhKHIyLmxlZnQgPiByMS5yaWdodCB8fFxyXG4gICAgICAgIHIyLnJpZ2h0IDwgcjEubGVmdCB8fFxyXG4gICAgICAgIHIyLnRvcCA+IHIxLmJvdHRvbSB8fFxyXG4gICAgICAgIHIyLmJvdHRvbSA8IHIxLnRvcCk7XHJcbn1cclxuXHJcbmNvbnN0IGVudW1Gcm9tU3RyaW5nVmFsdWUgPSA8VD4oZW5tOiB7IFtzOiBzdHJpbmddOiBUIH0sIHZhbHVlOiBzdHJpbmcpOiBUIHwgdW5kZWZpbmVkID0+IHtcclxuICAgIHJldHVybiAoT2JqZWN0LnZhbHVlcyhlbm0pIGFzIHVua25vd24gYXMgc3RyaW5nW10pLmluY2x1ZGVzKHZhbHVlKVxyXG4gICAgICAgID8gdmFsdWUgYXMgdW5rbm93biBhcyBUXHJcbiAgICAgICAgOiB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbmNvbnN0IERlZmF1bHROb2RlVGVtcGxhdGUgPSAvKiBIVE1MICovIGBcclxuICAgIDxkaXYgJHtGbG93VHlwZXMuRmxvd0F0dHIuTm9kZVRlbXBsYXRlfT5cclxuICAgICAgICA8dWwgJHtGbG93VHlwZXMuRmxvd0F0dHIuRWRnZUdyb3VwfT1cImlucHV0c1wiICR7Rmxvd1R5cGVzLkZsb3dBdHRyLkVkZ2VMYXRjaH09XCJjZW50ZXJcIj5cclxuICAgICAgICAgICAgPCEtLSBJbnB1dCBFZGdlcyBEeW5hbWljYWxseSBQb3B1bGF0ZWQgLS0+XHJcbiAgICAgICAgPC91bD5cclxuICAgICAgICA8ZGl2ICR7Rmxvd1R5cGVzLkZsb3dBdHRyLk5vZGVDb250ZW50fT5cclxuICAgICAgICAgICAgPCEtLSBOb2RlIENvbnRlbnQgYXMgUHJvdmlkZWQgYnkgVXNlciAtLT5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8dWwgJHtGbG93VHlwZXMuRmxvd0F0dHIuRWRnZUdyb3VwfT1cIm91dHB1dHNcIiAke0Zsb3dUeXBlcy5GbG93QXR0ci5FZGdlTGF0Y2h9PVwiY2VudGVyXCI+XHJcbiAgICAgICAgICAgIDwhLS0gT3V0cHV0IEVkZ2VzIER5bmFtaWNhbGx5IFBvcHVsYXRlZCAtLT5cclxuICAgICAgICA8L3VsPlxyXG4gICAgPC9kaXY+XHJcbmBcclxuXHJcbmNvbnN0IGJ1aWxkRWRnZUdyb3VwcyA9IChkb206IERvY3VtZW50KSA9PiB7XHJcbiAgICBsZXQgZWRnZUdyb3VwczogTWFwPHN0cmluZywgRmxvd1R5cGVzLkVkZ2VHcm91cD4gPSBuZXcgTWFwKCk7XHJcbiAgICBsZXQgZ3JvdXBOb2RlcyA9IGRvbS5xdWVyeVNlbGVjdG9yQWxsKGB1bFske0Zsb3dUeXBlcy5GbG93QXR0ci5FZGdlR3JvdXB9XWApO1xyXG4gICAgZ3JvdXBOb2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgIGxldCBrZXkgPSBub2RlLmdldEF0dHJpYnV0ZShGbG93VHlwZXMuRmxvd0F0dHIuRWRnZUdyb3VwKSE7XHJcbiAgICAgICAgbGV0IGxhdGNoUG9zID0gZW51bUZyb21TdHJpbmdWYWx1ZShGbG93VHlwZXMuTGlua0xhdGNoUG9zaXRpb24sIG5vZGUuZ2V0QXR0cmlidXRlKEZsb3dUeXBlcy5GbG93QXR0ci5FZGdlTGF0Y2gpID8/ICdjZW50ZXInKTtcclxuICAgICAgICBub2RlLmNsYXNzTGlzdC5hZGQoRmxvd1R5cGVzLkZsb3dDbGFzcy5FZGdlR3JvdXApO1xyXG4gICAgICAgIGVkZ2VHcm91cHMuc2V0KGtleSwge1xyXG4gICAgICAgICAgICBncm91cEtleToga2V5LFxyXG4gICAgICAgICAgICBncm91cEVsOiA8SFRNTFVMaXN0RWxlbWVudD5ub2RlLFxyXG4gICAgICAgICAgICBsYXRjaFBvczogbGF0Y2hQb3MgPz8gRmxvd1R5cGVzLkxpbmtMYXRjaFBvc2l0aW9uLkNFTlRFUlxyXG4gICAgICAgIH0pXHJcbiAgICB9KVxyXG5cclxuICAgIHJldHVybiBlZGdlR3JvdXBzO1xyXG59XHJcblxyXG5jb25zdCBwYXJzZU5vZGVUZW1wbGF0ZSA9ICh0ZW1wbGF0ZTogc3RyaW5nKTogW0RvY3VtZW50LCBIVE1MRWxlbWVudCwgSFRNTEVsZW1lbnRdID0+IHtcclxuICAgIGxldCBkb20gPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHRlbXBsYXRlLCBcInRleHQvaHRtbFwiKTtcclxuXHJcbiAgICAvL0dldCBhbmQgY3JlYXRlIG5vZGVcclxuICAgIGxldCBlbCA9IGRvbS5xdWVyeVNlbGVjdG9yKGAqWyR7Rmxvd1R5cGVzLkZsb3dBdHRyLk5vZGVUZW1wbGF0ZX1dYCk7XHJcbiAgICBsZXQgY29udGVudCA9IGRvbS5xdWVyeVNlbGVjdG9yKGAqWyR7Rmxvd1R5cGVzLkZsb3dBdHRyLk5vZGVDb250ZW50fV1gKTtcclxuXHJcbiAgICAvL0Vuc3VyZSBhbGwgdGVtcGxhdGUgZWxlbWVudHMgaGF2ZSBiZWVuIGluY2x1ZGVkXHJcbiAgICBpZiAoIWVsIC8qfHwgIWlucHV0cyB8fCAhb3V0cHV0cyAqLyB8fCAhY29udGVudCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm9kZSB0ZW1wbGF0ZSBpcyBtaXNzaW5nIHJlcXVpcmVkIGVsZW1lbnQuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy9FbnN1cmUgYWxsIHRlbXBsYXRlIGVsZW1lbnRzIGFyZSBvZiB0aGUgY29ycmVjdCB0eXBlXHJcbiAgICBpZiAoIShlbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSAvKiB8fCAhKGlucHV0cyBpbnN0YW5jZW9mIEhUTUxVTGlzdEVsZW1lbnQpIHx8ICEob3V0cHV0cyBpbnN0YW5jZW9mIEhUTUxVTGlzdEVsZW1lbnQpICovIHx8ICEoY29udGVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT25lIG1vcmUgbW9yZSB0ZW1wbGF0ZSBlbGVtZW50cyBpcyBvZiB0aGUgaW5jb3JyZWN0IGVsZW1lbnQgdHlwZS4nKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gW2RvbSwgZWwsIGNvbnRlbnRdO1xyXG59XHJcblxyXG5jb25zdCBhcHBseU5vZGVBdHRyaWJ1dGVzID0gKGVsOiBIVE1MRWxlbWVudCwga2V5OiBzdHJpbmcsIHo6IG51bWJlcikgPT4ge1xyXG4gICAgZWwuc2V0QXR0cmlidXRlKEZsb3dUeXBlcy5GbG93QXR0ci5UeXBlLCBGbG93VHlwZXMuRmxvd0l0ZW1UeXBlLk5vZGUpO1xyXG4gICAgZWwuc2V0QXR0cmlidXRlKEZsb3dUeXBlcy5GbG93QXR0ci5LZXksIGtleSk7XHJcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2RyYWdnYWJsZScsIFwiZmFsc2VcIik7XHJcbiAgICBlbC5vbmRyYWdzdGFydCA9IChlKSA9PiBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1mbGV4JztcclxuICAgIGVsLnN0eWxlLmp1c3RpZnlDb250ZW50ID0gJ3NwYWNlLWJldHdlZW4nO1xyXG4gICAgZWwuc3R5bGUudG91Y2hBY3Rpb24gPSAnbm9uZSc7XHJcbiAgICBlbC5zdHlsZS51c2VyU2VsZWN0ID0gJ25vbmUnO1xyXG4gICAgZWwuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhbGwnO1xyXG4gICAgZWwuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgZWwuc3R5bGUubGVmdCA9IFwiMHB4XCI7XHJcbiAgICBlbC5zdHlsZS50b3AgPSBcIjBweFwiO1xyXG4gICAgZWwuc3R5bGUuekluZGV4ID0gei50b1N0cmluZygpO1xyXG59XHJcblxyXG4vLyBjb25zdCBGbG93Q2xhc3NlcyA9IG5ldyBTZXQ8c3RyaW5nPihPYmplY3QudmFsdWVzKEZsb3dUeXBlcy5GbG93Q2xhc3MpKTtcclxuLy8gY29uc3QgY29weUZsb3dDbGFzc2VzID0gKGZyb206IEVsZW1lbnQsIHRvOiBFbGVtZW50KSA9PiB7XHJcbi8vICAgICBmcm9tLmNsYXNzTGlzdC5mb3JFYWNoKGMgPT4ge1xyXG4vLyAgICAgICAgIGlmIChGbG93Q2xhc3Nlcy5oYXMoYykpIHtcclxuLy8gICAgICAgICAgICAgdG8uY2xhc3NMaXN0LmFkZChjKTtcclxuLy8gICAgICAgICB9XHJcbi8vICAgICB9KVxyXG4vLyB9XHJcblxyXG50eXBlIENyZWF0ZU5vZGVPcHRpb25zID0ge1xyXG4gICAgdGVtcGxhdGU/OiBzdHJpbmcsXHJcbiAgICBrZXk6IHN0cmluZyxcclxuICAgIHg6IG51bWJlcixcclxuICAgIHk6IG51bWJlcixcclxuICAgIHo6IG51bWJlcixcclxuICAgIHdpZHRoPzogc3RyaW5nIHwgbnVtYmVyLFxyXG4gICAgaGVpZ2h0Pzogc3RyaW5nIHwgbnVtYmVyLFxyXG4gICAgbm9kZUNsYXNzPzogc3RyaW5nIHwgc3RyaW5nW10sXHJcbiAgICBkYXRhPzogRmxvd1R5cGVzLlNlcmlhbGl6YWJsZVxyXG59XHJcblxyXG5jb25zdCBjcmVhdGVOb2RlID0gKG9wdHM6IENyZWF0ZU5vZGVPcHRpb25zKTogRmxvd1R5cGVzLk5vZGUgPT4ge1xyXG4gICAgbGV0IHRlbXBsYXRlID0gb3B0cy50ZW1wbGF0ZSA/PyBEZWZhdWx0Tm9kZVRlbXBsYXRlO1xyXG4gICAgbGV0IGRvbSwgZWwsIGNvbnRlbnQ7W2RvbSwgZWwsIGNvbnRlbnRdID0gcGFyc2VOb2RlVGVtcGxhdGUodGVtcGxhdGUpO1xyXG5cclxuICAgIC8vRW5zdXJlIGFsbCB0ZW1wbGF0ZSBlbGVtZW50cyBoYXZlIGJlZW4gaW5jbHVkZWRcclxuICAgIGlmICghZWwgLyp8fCAhaW5wdXRzIHx8ICFvdXRwdXRzICovIHx8ICFjb250ZW50KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb2RlIHRlbXBsYXRlIGlzIG1pc3NpbmcgcmVxdWlyZWQgZWxlbWVudC4nKTtcclxuICAgIH1cclxuXHJcbiAgICAvL0Vuc3VyZSBhbGwgdGVtcGxhdGUgZWxlbWVudHMgYXJlIG9mIHRoZSBjb3JyZWN0IHR5cGVcclxuICAgIGlmICghKGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIC8qIHx8ICEoaW5wdXRzIGluc3RhbmNlb2YgSFRNTFVMaXN0RWxlbWVudCkgfHwgIShvdXRwdXRzIGluc3RhbmNlb2YgSFRNTFVMaXN0RWxlbWVudCkgKi8gfHwgIShjb250ZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmUgbW9yZSBtb3JlIHRlbXBsYXRlIGVsZW1lbnQgaXMgb2YgdGhlIGluY29ycmVjdCBlbGVtZW50IHR5cGUuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGVsIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICBhcHBseU5vZGVBdHRyaWJ1dGVzKGVsLCBvcHRzLmtleSwgb3B0cy56KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwYXJlbnQgSFRNTEVsZW1lbnQgZm91bmQgaW4gTm9kZSB0ZW1wbGF0ZSAody8gY2xhc3MgXCJteC1mbG93LW5vZGVcIikuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgZWwuY2xhc3NMaXN0LmFkZChGbG93VHlwZXMuRmxvd0NsYXNzLk5vZGUpO1xyXG4gICAgY29udGVudC5jbGFzc0xpc3QuYWRkKEZsb3dUeXBlcy5GbG93Q2xhc3MuTm9kZUNvbnRlbnQpO1xyXG5cclxuICAgIC8vQWRkIGFueSBjdXN0b20gY2xhc3NlcyAtIHRoZXNlIGFyZSBwcm92aWRlZCBieSB0aGUgdXNlclxyXG4gICAgbGV0IHVzZXJDbGFzcyA6IHN0cmluZ1tdID0gW107XHJcbiAgICBpZiAob3B0cy5ub2RlQ2xhc3MgJiYgb3B0cy5ub2RlQ2xhc3MubGVuZ3RoID4gMCl7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0cy5ub2RlQ2xhc3MpKXtcclxuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCguLi5vcHRzLm5vZGVDbGFzcyk7XHJcbiAgICAgICAgICAgIHVzZXJDbGFzcyA9IG9wdHMubm9kZUNsYXNzO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQob3B0cy5ub2RlQ2xhc3MpO1xyXG4gICAgICAgICAgICB1c2VyQ2xhc3MgPSBbb3B0cy5ub2RlQ2xhc3NdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAob3B0cy53aWR0aCkgZWwuc3R5bGUud2lkdGggPSB0eXBlb2Ygb3B0cy53aWR0aCA9PT0gJ251bWJlcicgPyBgJHtvcHRzLndpZHRofXB4YCA6IG9wdHMud2lkdGg7XHJcbiAgICBpZiAob3B0cy5oZWlnaHQpIGVsLnN0eWxlLmhlaWdodCA9IHR5cGVvZiBvcHRzLmhlaWdodCA9PT0gJ251bWJlcicgPyBgJHtvcHRzLmhlaWdodH1weGAgOiBvcHRzLmhlaWdodDtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IEZsb3dUeXBlcy5GbG93SXRlbVR5cGUuTm9kZSxcclxuICAgICAgICB0ZW1wbGF0ZTogdGVtcGxhdGUsXHJcbiAgICAgICAga2V5OiBvcHRzLmtleSxcclxuICAgICAgICBlbDogZWwsXHJcbiAgICAgICAgY29udGVudEVsOiBjb250ZW50LFxyXG4gICAgICAgIGVkZ2VHcm91cHM6IGJ1aWxkRWRnZUdyb3Vwcyhkb20pLFxyXG4gICAgICAgIHg6IG9wdHMueCxcclxuICAgICAgICB5OiBvcHRzLnksXHJcbiAgICAgICAgejogb3B0cy56LFxyXG4gICAgICAgIGRlbHRhWDogMCxcclxuICAgICAgICBkZWx0YVk6IDAsXHJcbiAgICAgICAgd2lkdGg6IG9wdHMud2lkdGggPz8gJ2F1dG8nLFxyXG4gICAgICAgIGhlaWdodDogb3B0cy5oZWlnaHQgPz8gJ2F1dG8nLFxyXG4gICAgICAgIGRhdGE6IG9wdHMuZGF0YSA/PyB7fSxcclxuICAgICAgICBjbGFzczogdXNlckNsYXNzXHJcbiAgICB9XHJcbn1cclxuXHJcbmNvbnN0IGdldEVkZ2VDb21wb3NpdGVLZXkgPSAoZWRnZTogRmxvd1R5cGVzLkVkZ2UpID0+IHtcclxuICAgIHJldHVybiBgJHtlZGdlLm5vZGVLZXl9OiR7ZWRnZS5lZGdlS2V5fWA7XHJcbn1cclxuXHJcbmNvbnN0IGNyZWF0ZUVkZ2UgPSAobm9kZTogRmxvd1R5cGVzLk5vZGUsIGdyb3VwS2V5OiBzdHJpbmcsIGVkZ2VLZXk6IHN0cmluZywgZWRnZUNsYXNzPzogc3RyaW5nKTogRmxvd1R5cGVzLkVkZ2UgPT4ge1xyXG4gICAgbGV0IGdyb3VwID0gbm9kZS5lZGdlR3JvdXBzLmdldChncm91cEtleSk7XHJcbiAgICBpZiAoIWdyb3VwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjcmVhdGVFZGdlKCk6IFVuYWJsZSB0byBmaW5kIGdyb3VwIHdpdGgga2V5IFwiJHtncm91cEtleX1cIiBpbiBub2RlIHRlbXBsYXRlLmApO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XHJcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChGbG93VHlwZXMuRmxvd0NsYXNzLkVkZ2UpO1xyXG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShGbG93VHlwZXMuRmxvd0F0dHIuVHlwZSwgRmxvd1R5cGVzLkZsb3dJdGVtVHlwZS5FZGdlKTtcclxuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoRmxvd1R5cGVzLkZsb3dBdHRyLktleSwgYCR7bm9kZS5rZXl9OiR7ZWRnZUtleX1gKTtcclxuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2RyYWdnYWJsZScsIFwiZmFsc2VcIik7XHJcbiAgICAgICAgZWwub25kcmFnc3RhcnQgPSAoZSkgPT4gZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgIGlmIChlZGdlQ2xhc3MgJiYgZWRnZUNsYXNzLmxlbmd0aCA+IDApe1xyXG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoZWRnZUNsYXNzKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IEZsb3dUeXBlcy5GbG93SXRlbVR5cGUuRWRnZSxcclxuICAgICAgICBrZXk6IGAke25vZGUua2V5fToke2VkZ2VLZXl9YCxcclxuICAgICAgICBncm91cDogZ3JvdXAsXHJcbiAgICAgICAgbm9kZUtleTogbm9kZS5rZXksXHJcbiAgICAgICAgZWRnZUtleTogZWRnZUtleSxcclxuICAgICAgICBlbDogZWwsXHJcbiAgICAgICAgZGF0YToge30sXHJcbiAgICAgICAgY2xhc3M6IGVkZ2VDbGFzcyA/PyAnJ1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogR2l2ZW4gYW4gZWRnZSwgcmV0dXJucyBpdCdzIGxhdGNoIHBvc2l0aW9uIGFzIGRlZmluZWQgYnkgaXRzIGVkZ2UgZ3JvdXAuXHJcbiAqIFxyXG4gKiBAcGFyYW0gZWRnZSAtIFRoZSB0YXJnZXQgRWRnZVxyXG4gKiBAcGFyYW0gb2Zmc2V0WCAtIFggYXhpcyBvZmZzZXQgdG8gZmFjdG9yIGluXHJcbiAqIEBwYXJhbSBvZmZzZXRZIC0gWSBheGlzIG9mZnNldCB0byBmYWN0b3IgaW5cclxuICogQHJldHVybnMgXHJcbiAqL1xyXG5jb25zdCBnZXRFZGdlTGF0Y2hQb3MgPSAoZWRnZTogRmxvd1R5cGVzLkVkZ2UsIG9mZnNldFg6IG51bWJlciA9IDAsIG9mZnNldFk6IG51bWJlciA9IDApID0+IHtcclxuICAgIGxldCByZWN0ID0gZWRnZS5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIHN3aXRjaCAoZWRnZS5ncm91cC5sYXRjaFBvcy50b1N0cmluZygpKSB7XHJcbiAgICAgICAgY2FzZSAndG9wJzpcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHg6IChyZWN0LmxlZnQgLSBvZmZzZXRYKSArIChyZWN0LndpZHRoIC8gMiksXHJcbiAgICAgICAgICAgICAgICB5OiAocmVjdC50b3AgLSBvZmZzZXRZKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAncmlnaHQnOlxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgeDogKHJlY3QubGVmdCAtIG9mZnNldFgpICsgcmVjdC53aWR0aCxcclxuICAgICAgICAgICAgICAgIHk6IChyZWN0LnRvcCAtIG9mZnNldFkpICsgKHJlY3QuaGVpZ2h0IC8gMilcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB4OiAocmVjdC5sZWZ0IC0gb2Zmc2V0WCkgKyAocmVjdC53aWR0aCAvIDIpLFxyXG4gICAgICAgICAgICAgICAgeTogKHJlY3QudG9wIC0gb2Zmc2V0WSkgKyByZWN0LmhlaWdodFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAnbGVmdCc6XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB4OiAocmVjdC5sZWZ0IC0gb2Zmc2V0WCksXHJcbiAgICAgICAgICAgICAgICB5OiAocmVjdC50b3AgLSBvZmZzZXRZKSArIChyZWN0LmhlaWdodCAvIDIpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBjYXNlICdjZW50ZXInOlxyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB4OiAocmVjdC5sZWZ0IC0gb2Zmc2V0WCkgKyAocmVjdC53aWR0aCAvIDIpLFxyXG4gICAgICAgICAgICAgICAgeTogKHJlY3QudG9wIC0gb2Zmc2V0WSkgKyAocmVjdC5oZWlnaHQgLyAyKVxyXG4gICAgICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmNvbnN0IGdldExpbmtDb21wb3NpdGVLZXkgPSAob3B0czogRmxvd1R5cGVzLkNyZWF0ZUxpbmtQYXJhbXMpID0+IHtcclxuICAgIHJldHVybiBgJHtvcHRzLmZyb21Ob2RlfToke29wdHMuZnJvbUVkZ2V9OiR7b3B0cy50b05vZGV9OiR7b3B0cy50b0VkZ2V9YDtcclxufVxyXG5cclxuY29uc3QgY3JlYXRlTGluayA9IChvcHRzOiBGbG93VHlwZXMuQ3JlYXRlTGlua1BhcmFtcywgZ3JvdXBDbGFzcz86IHN0cmluZyk6IEZsb3dUeXBlcy5MaW5rID0+IHtcclxuICAgIGxldCBrZXkgPSBnZXRMaW5rQ29tcG9zaXRlS2V5KG9wdHMpO1xyXG4gICAgbGV0IGJhbmQxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgJ3BhdGgnKTtcclxuICAgICAgICBiYW5kMS5jbGFzc0xpc3QuYWRkKEZsb3dUeXBlcy5GbG93Q2xhc3MuTGlua0JhbmQxKTtcclxuICAgICAgICBiYW5kMS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2F1dG8nO1xyXG5cclxuICAgIGxldCBiYW5kMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsICdwYXRoJyk7XHJcbiAgICAgICAgYmFuZDIuY2xhc3NMaXN0LmFkZChGbG93VHlwZXMuRmxvd0NsYXNzLkxpbmtCYW5kMik7XHJcbiAgICAgICAgYmFuZDIuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcclxuXHJcbiAgICBsZXQgYmFuZDMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCAncGF0aCcpO1xyXG4gICAgICAgIGJhbmQzLmNsYXNzTGlzdC5hZGQoRmxvd1R5cGVzLkZsb3dDbGFzcy5MaW5rQmFuZDMpO1xyXG4gICAgICAgIGJhbmQzLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XHJcblxyXG4gICAgbGV0IHRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCAndGV4dCcpO1xyXG4gICAgICAgIHRleHQudGV4dENvbnRlbnQgPSAnTGFiZWwnO1xyXG4gICAgICAgIHRleHQuc3R5bGUuY29sb3IgPSAnd2hpdGUnO1xyXG4gICAgICAgIHRleHQuc2V0QXR0cmlidXRlKCd3aWR0aCcsIFwiMzAwcHhcIik7XHJcbiAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIFwiMzAwcHhcIik7XHJcbiAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGUoJ3RleHRBbmNob3InLCAnbWlkZGxlJyk7XHJcblxyXG4gICAgbGV0IGxhYmVsUGF0aCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsICd0ZXh0UGF0aCcpO1xyXG4gICAgICAgIGxhYmVsUGF0aC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xyXG5cclxuICAgIHRleHQuYXBwZW5kQ2hpbGQobGFiZWxQYXRoKTtcclxuXHJcbiAgICBsZXQgZ3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCAnZycpO1xyXG4gICAgICAgIGdyb3VwLnNldEF0dHJpYnV0ZShGbG93VHlwZXMuRmxvd0F0dHIuVHlwZSwgRmxvd1R5cGVzLkZsb3dJdGVtVHlwZS5MaW5rKTtcclxuICAgICAgICBncm91cC5zZXRBdHRyaWJ1dGUoRmxvd1R5cGVzLkZsb3dBdHRyLktleSwga2V5KTtcclxuICAgICAgICBncm91cC5jbGFzc0xpc3QuYWRkKEZsb3dUeXBlcy5GbG93Q2xhc3MuTGluayk7XHJcbiAgICAgICAgZ3JvdXAuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcclxuICAgICAgICBncm91cC5zZXRBdHRyaWJ1dGUoJ2RyYWdnYWJsZScsIFwiZmFsc2VcIik7XHJcbiAgICAgICAgZ3JvdXAub25kcmFnc3RhcnQgPSAoZSkgPT4gZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGdyb3VwLmFwcGVuZENoaWxkKGJhbmQxKTtcclxuICAgICAgICBncm91cC5hcHBlbmRDaGlsZChiYW5kMik7XHJcbiAgICAgICAgZ3JvdXAuYXBwZW5kQ2hpbGQoYmFuZDMpO1xyXG4gICAgICAgIGdyb3VwLmFwcGVuZENoaWxkKHRleHQpO1xyXG5cclxuICAgIGlmIChncm91cENsYXNzICYmIGdyb3VwQ2xhc3MubGVuZ3RoID4gMCl7XHJcbiAgICAgICAgZ3JvdXAuY2xhc3NMaXN0LmFkZChncm91cENsYXNzKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IEZsb3dUeXBlcy5GbG93SXRlbVR5cGUuTGluayxcclxuICAgICAgICBrZXk6IGtleSxcclxuICAgICAgICBmcm9tTm9kZTogb3B0cy5mcm9tTm9kZSxcclxuICAgICAgICBmcm9tRWRnZTogb3B0cy5mcm9tRWRnZSxcclxuICAgICAgICB0b05vZGU6IG9wdHMudG9Ob2RlLFxyXG4gICAgICAgIHRvRWRnZTogb3B0cy50b0VkZ2UsXHJcbiAgICAgICAgZWw6IGdyb3VwLFxyXG4gICAgICAgIGJhbmQxOiBiYW5kMSxcclxuICAgICAgICBiYW5kMjogYmFuZDIsXHJcbiAgICAgICAgYmFuZDM6IGJhbmQzLFxyXG4gICAgICAgIGxhYmVsRWw6IGxhYmVsUGF0aCxcclxuICAgICAgICBkYXRhOiB7fVxyXG4gICAgfVxyXG59XHJcblxyXG5jb25zdCBnZW5lcmF0ZUZsb3dFbCA9ICh0YXJnZXRFbDogSFRNTEVsZW1lbnQsIG9wdHM6IEZsb3dUeXBlcy5Db25maWcpID0+IHtcclxuICAgIGxldCBpZCA9ICdteGZsb3ctaW5zdGFuY2UtJyArIERhdGUubm93KCk7XHJcbiAgICBsZXQgYmcgPSBvcHRzLmJhY2tncm91bmQuaHRtbDtcclxuICAgIGlmIChvcHRzLmJhY2tncm91bmQudHlwZSA9PT0gJ2dyaWQnIHx8IG9wdHMuYmFja2dyb3VuZC50eXBlID09PSAnZG90cycpe1xyXG4gICAgICAgIGJnID0gZ2VuZXJhdGVCYWNrZ3JvdW5kKG9wdHMuYmFja2dyb3VuZC50eXBlLCBvcHRzLmJhY2tncm91bmQuc2l6ZSwgb3B0cy5iYWNrZ3JvdW5kLnJhZGl1cyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGFyZ2V0RWwuaW5zZXJ0QWRqYWNlbnRIVE1MKCdhZnRlcmJlZ2luJywgLyogSFRNTCAqLyBgXHJcbiAgICAgICAgPGRpdiBpZD1cIiR7aWR9XCIgY2xhc3M9XCIke0Zsb3dUeXBlcy5GbG93Q2xhc3MuQ29udGFpbmVyfVwiXHJcbiAgICAgICAgICAgIHRhYmluZGV4PVwiMVwiIFxyXG4gICAgICAgICAgICBzdHlsZT1cInBvc2l0aW9uOnJlbGF0aXZlOyBkaXNwbGF5OmJsb2NrOyB3aWR0aDoxMDAlOyBoZWlnaHQ6MTAwJTsgb3ZlcmZsb3c6aGlkZGVuOyBwb2ludGVyLWV2ZW50czphdXRvOyBwYWRkaW5nOjBweDsgb3V0bGluZTpub25lXCJcclxuICAgICAgICAgICAgb25kcmFnc3RhcnQ9XCJldmVudC5wcmV2ZW50RGVmYXVsdCgpXCI+XHJcbiAgICAgICAgICAgIDxzdmcgc3R5bGU9XCJwb3NpdGlvbjphYnNvbHV0ZTsgbGVmdDowcHg7IHRvcDowcHg7IHdpZHRoOjEwMCU7IGhlaWdodDoxMDAlOyBwb2ludGVyLWV2ZW50czpub25lOyBwYWRkaW5nOiAwcHg7IHotaW5kZXg6MTAwMDtcIj5cclxuICAgICAgICAgICAgICAgIDxyZWN0IGNsYXNzPVwiJHtGbG93VHlwZXMuRmxvd0NsYXNzLkxhc3NvfVwiIFxyXG4gICAgICAgICAgICAgICAgICAgIG9uZHJhZ3N0YXJ0PVwiZXZlbnQucHJldmVudERlZmF1bHQoKVwiXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU9XCJwb3NpdGlvbjphYnNvbHV0ZTsgZGlzcGxheTpub25lOyB6LWluZGV4OiAzOyBwb2ludGVyLWV2ZW50czpub25lO1wiPlxyXG4gICAgICAgICAgICAgICAgPC9yZWN0PlxyXG4gICAgICAgICAgICA8L3N2Zz5cclxuXHJcbiAgICAgICAgICAgIDwhLS0gPGRpdiBjbGFzcz1cIiR7Rmxvd1R5cGVzLkZsb3dDbGFzcy5MYXNzb31cIlxyXG4gICAgICAgICAgICAgICAgb25kcmFnc3RhcnQ9XCJldmVudC5wcmV2ZW50RGVmYXVsdCgpXCJcclxuICAgICAgICAgICAgICAgIHN0eWxlPVwicG9zaXRpb246YWJzb2x1dGU7IGRpc3BsYXk6bm9uZTsgei1pbmRleDogMzsgcG9pbnRlci1ldmVudHM6bm9uZTtcIj5cclxuICAgICAgICAgICAgPC9kaXY+IC0tPlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiJHtGbG93VHlwZXMuRmxvd0NsYXNzLkNvbnRleHR9XCJcclxuICAgICAgICAgICAgICAgIG9uZHJhZ3N0YXJ0PVwiZXZlbnQucHJldmVudERlZmF1bHQoKVwiXHJcbiAgICAgICAgICAgICAgICBzdHlsZT1cImRpc3BsYXk6bm9uZTsgcG9zaXRpb246YWJzb2x1dGU7IHotaW5kZXg6IDEwO1wiPlxyXG4gICAgICAgICAgICAgICAgPCEtLSBDb250ZXh0IE1lbnUgUG9wdWxhdGVkIEhlcmUgLS0+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiJHtGbG93VHlwZXMuRmxvd0NsYXNzLlJvb3R9XCJcclxuICAgICAgICAgICAgICAgICR7Rmxvd1R5cGVzLkZsb3dBdHRyLlR5cGV9PVwiZ3JhcGhcIlxyXG4gICAgICAgICAgICAgICAgJHtGbG93VHlwZXMuRmxvd0F0dHIuS2V5fT1cImdyYXBoXCJcclxuICAgICAgICAgICAgICAgIG9uZHJhZ3N0YXJ0PVwiZXZlbnQucHJldmVudERlZmF1bHQoKVwiXHJcbiAgICAgICAgICAgICAgICBzdHlsZT1cInBvc2l0aW9uOnJlbGF0aXZlOyBoZWlnaHQ6JHtvcHRzLmhlaWdodH1weDsgd2lkdGg6JHtvcHRzLndpZHRofXB4OyBwb2ludGVyLWV2ZW50czphdXRvOyB0cmFuc2Zvcm0tb3JpZ2luOiAwIDA7IHRvdWNoLWFjdGlvbjogbm9uZTtcIj5cclxuXHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiJHtGbG93VHlwZXMuRmxvd0NsYXNzLkJhY2tncm91bmR9XCIgc3R5bGU9XCJ3aWR0aDoxMDAlO2hlaWdodDoxMDAlO2Rpc3BsYXk6JHsgb3B0cy5iYWNrZ3JvdW5kLnR5cGUgPT09ICdub25lJyA/ICdub25lJyA6ICdibG9jaycgfTtcIj5cclxuICAgICAgICAgICAgICAgICAgICAke2JnfVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8c3ZnIGNsYXNzPVwiJHtGbG93VHlwZXMuRmxvd0NsYXNzLkxpbmtzfVwiIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmRyYWdzdGFydD1cImV2ZW50LnByZXZlbnREZWZhdWx0KClcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT1cInBvc2l0aW9uOmFic29sdXRlOyBsZWZ0OjBweDsgdG9wOjBweDsgd2lkdGg6MTAwJTsgaGVpZ2h0OjEwMCU7IHBvaW50ZXItZXZlbnRzOm5vbmU7IHBhZGRpbmc6IDBweDtcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPCEtLSBMaW5rcyBQb3B1bGF0ZWQgSGVyZSAtLT5cclxuICAgICAgICAgICAgICAgIDwvc3ZnPlxyXG4gICAgICAgICAgICAgICAgPHN2ZyBjbGFzcz1cIiR7Rmxvd1R5cGVzLkZsb3dDbGFzcy5HaG9zdExpbmtzfVwiIFxyXG4gICAgICAgICAgICAgICAgICAgICBvbmRyYWdzdGFydD1cImV2ZW50LnByZXZlbnREZWZhdWx0KClcIlxyXG4gICAgICAgICAgICAgICAgICAgICBzdHlsZT1cInBvc2l0aW9uOmFic29sdXRlOyBsZWZ0OjBweDsgdG9wOjBweDsgd2lkdGg6MTAwJTsgaGVpZ2h0OjEwMCU7IHBvaW50ZXItZXZlbnRzOm5vbmU7IHBhZGRpbmc6IDBweDsgei1pbmRleDoxMDAwO1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICA8ZyBzdHlsZT1cInBvc2l0aW9uOmFic29sdXRlOyBwb2ludGVyLWV2ZW50czpub25lOyBvdmVyZmxvdzp2aXNpYmxlOyBcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGggY2xhc3M9XCIke0Zsb3dUeXBlcy5GbG93Q2xhc3MuR2hvc3RMaW5rfVwiIHN0eWxlPVwiZGlzcGxheTpub25lO1wiPjwvcGF0aD5cclxuICAgICAgICAgICAgICAgICAgICAgPC9nPlxyXG4gICAgICAgICAgICAgICAgPC9zdmc+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiJHtGbG93VHlwZXMuRmxvd0NsYXNzLk5vZGVzfVwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDwhLS0gTm9kZXMgUG9wdWxhdGVkIEhlcmUgLS0+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICBgKVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaW5zdGFuY2VJZDogaWQsXHJcbiAgICAgICAgY29udGFpbmVyRWw6IDxIVE1MRGl2RWxlbWVudD50YXJnZXRFbC5xdWVyeVNlbGVjdG9yKFwiLlwiICsgRmxvd1R5cGVzLkZsb3dDbGFzcy5Db250YWluZXIpISxcclxuICAgICAgICBsYXNzb0VsOiA8U1ZHRWxlbWVudD50YXJnZXRFbC5xdWVyeVNlbGVjdG9yKFwiLlwiICsgRmxvd1R5cGVzLkZsb3dDbGFzcy5MYXNzbykhLFxyXG4gICAgICAgIGNvbnRleHRFbDogPEhUTUxEaXZFbGVtZW50PnRhcmdldEVsLnF1ZXJ5U2VsZWN0b3IoXCIuXCIgKyBGbG93VHlwZXMuRmxvd0NsYXNzLkNvbnRleHQpISxcclxuICAgICAgICByb290RWw6IDxIVE1MRGl2RWxlbWVudD50YXJnZXRFbC5xdWVyeVNlbGVjdG9yKFwiLlwiICsgRmxvd1R5cGVzLkZsb3dDbGFzcy5Sb290KSEsXHJcbiAgICAgICAgYmdFbDogPEhUTUxEaXZFbGVtZW50PnRhcmdldEVsLnF1ZXJ5U2VsZWN0b3IoJy4nICsgRmxvd1R5cGVzLkZsb3dDbGFzcy5CYWNrZ3JvdW5kKSxcclxuICAgICAgICBub2RlQ29udGFpbmVyRWw6IDxIVE1MRGl2RWxlbWVudD50YXJnZXRFbC5xdWVyeVNlbGVjdG9yKFwiLlwiICsgRmxvd1R5cGVzLkZsb3dDbGFzcy5Ob2RlcyksXHJcbiAgICAgICAgbGlua0NvbnRhaW5lckVsOiA8U1ZHRWxlbWVudD50YXJnZXRFbC5xdWVyeVNlbGVjdG9yKFwiLlwiICsgRmxvd1R5cGVzLkZsb3dDbGFzcy5MaW5rcykhLFxyXG4gICAgICAgIGdob3N0TGlua0NvbnRhaW5lckVsOiA8U1ZHRWxlbWVudD50YXJnZXRFbC5xdWVyeVNlbGVjdG9yKFwiLlwiICsgRmxvd1R5cGVzLkZsb3dDbGFzcy5HaG9zdExpbmtzKSEsXHJcbiAgICAgICAgZ2hvc3RMaW5rRWw6IDxTVkdQYXRoRWxlbWVudD50YXJnZXRFbC5xdWVyeVNlbGVjdG9yKFwiLlwiICsgRmxvd1R5cGVzLkZsb3dDbGFzcy5HaG9zdExpbmspIVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuY29uc3QgYWRkSXRlbUNsYXNzID0gKGl0ZW06IEZsb3dUeXBlcy5GbG93SXRlbSB8IEZsb3dUeXBlcy5GbG93SXRlbVtdIHwgTWFwPHN0cmluZywgRmxvd1R5cGVzLkZsb3dJdGVtPiwgYzogc3RyaW5nKSA9PiB7XHJcbiAgICBzd2l0Y2ggKHRydWUpIHtcclxuICAgICAgICBjYXNlIEFycmF5LmlzQXJyYXkoaXRlbSk6XHJcbiAgICAgICAgICAgICg8Rmxvd1R5cGVzLkZsb3dJdGVtW10+aXRlbSkuZm9yRWFjaChpdGVtID0+IGl0ZW0uZWwuY2xhc3NMaXN0LmFkZChjKSlcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBpdGVtIGluc3RhbmNlb2YgTWFwOlxyXG4gICAgICAgICAgICAoPE1hcDxzdHJpbmcsIEZsb3dUeXBlcy5GbG93SXRlbT4+aXRlbSkuZm9yRWFjaChpdGVtID0+IGl0ZW0uZWwuY2xhc3NMaXN0LmFkZChjKSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICg8Rmxvd1R5cGVzLkZsb3dJdGVtPml0ZW0pLmVsLmNsYXNzTGlzdC5hZGQoYyk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNvbnN0IHJlbW92ZUl0ZW1DbGFzcyA9IChpdGVtOiBGbG93VHlwZXMuRmxvd0l0ZW0gfCBGbG93VHlwZXMuRmxvd0l0ZW1bXSB8IE1hcDxzdHJpbmcsIEZsb3dUeXBlcy5GbG93SXRlbT4sIGM6IHN0cmluZykgPT4ge1xyXG4gICAgc3dpdGNoICh0cnVlKSB7XHJcbiAgICAgICAgY2FzZSBBcnJheS5pc0FycmF5KGl0ZW0pOlxyXG4gICAgICAgICAgICAoPEZsb3dUeXBlcy5GbG93SXRlbVtdPml0ZW0pLmZvckVhY2goaXRlbSA9PiBpdGVtLmVsLmNsYXNzTGlzdC5yZW1vdmUoYykpXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgaXRlbSBpbnN0YW5jZW9mIE1hcDpcclxuICAgICAgICAgICAgKDxNYXA8c3RyaW5nLCBGbG93VHlwZXMuRmxvd0l0ZW0+Pml0ZW0pLmZvckVhY2goaXRlbSA9PiBpdGVtLmVsLmNsYXNzTGlzdC5yZW1vdmUoYykpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAoPEZsb3dUeXBlcy5GbG93SXRlbT5pdGVtKS5lbC5jbGFzc0xpc3QucmVtb3ZlKGMpO1xyXG4gICAgfVxyXG59XHJcblxyXG5jb25zdCBhcHBseU5vZGVQb3NpdGlvbiA9IChub2RlOiBGbG93VHlwZXMuTm9kZSk6IEZsb3dUeXBlcy5Ob2RlID0+IHtcclxuICAgIG5vZGUuZWwuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke25vZGUueCArIG5vZGUuZGVsdGFYfXB4LCAke25vZGUueSArIG5vZGUuZGVsdGFZfXB4KWA7XHJcbiAgICByZXR1cm4gbm9kZTtcclxufVxyXG5cclxuZnVuY3Rpb24gX2dldFFCZXppZXJWYWx1ZSh0OiBudW1iZXIsIHAxOiBudW1iZXIsIHAyOiBudW1iZXIsIHAzOiBudW1iZXIpIHtcclxuICAgIHZhciBpVCA9IDEgLSB0O1xyXG4gICAgcmV0dXJuIGlUICogaVQgKiBwMSArIDIgKiBpVCAqIHQgKiBwMiArIHQgKiB0ICogcDM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFF1YWRyYXRpY0N1cnZlUG9pbnQoc3RhcnRYOiBudW1iZXIsIHN0YXJ0WTogbnVtYmVyLCBjcFg6IG51bWJlciwgY3BZOiBudW1iZXIsIGVuZFg6IG51bWJlciwgZW5kWTogbnVtYmVyLCBwb3NpdGlvbjogbnVtYmVyKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IF9nZXRRQmV6aWVyVmFsdWUocG9zaXRpb24sIHN0YXJ0WCwgY3BYLCBlbmRYKSxcclxuICAgICAgICB5OiBfZ2V0UUJlemllclZhbHVlKHBvc2l0aW9uLCBzdGFydFksIGNwWSwgZW5kWSlcclxuICAgIH07XHJcbn1cclxuXHJcbmNvbnN0IGFwcGx5TGlua1Bvc2l0aW9uID0gKGFwaTogRmxvd1R5cGVzLkFwaSwgbGluazogRmxvd1R5cGVzLkxpbmspID0+IHtcclxuICAgIGxldCB0cmFuc2Zvcm0gPSBhcGkuc3RhdGUudHJhbnNmb3JtO1xyXG4gICAgbGV0IGZyb21FZGdlID0gYXBpLnN0YXRlLmVkZ2VzLmdldChgJHtsaW5rLmZyb21Ob2RlfToke2xpbmsuZnJvbUVkZ2V9YCk7XHJcbiAgICBsZXQgdG9FZGdlID0gYXBpLnN0YXRlLmVkZ2VzLmdldChgJHtsaW5rLnRvTm9kZX06JHtsaW5rLnRvRWRnZX1gKTtcclxuICAgIGlmICghZnJvbUVkZ2UgfHwgIXRvRWRnZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTVhGbG93LmFwcGx5TGlua1Bvc2l0aW9uKCk6IENhbm5vdCBhcHBseSBsaW5rIHBvc2l0aW9uIGZvciB1bmRlZmluZWQgZWRnZScpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGxldCBmcm9tRWRnZVJlY3QgPSA8RE9NUmVjdD4gZnJvbUVkZ2UhLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgLy8gbGV0IHRvRWRnZVJlY3QgPSA8RE9NUmVjdD4gdG9FZGdlIS5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHJcbiAgICBsZXQgY29udGFpbmVyUmVjdCA9IGFwaS5kb20uY29udGFpbmVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICBsZXQgb2Zmc2V0WSA9IGNvbnRhaW5lclJlY3QudG9wO1xyXG4gICAgbGV0IG9mZnNldFggPSBjb250YWluZXJSZWN0LmxlZnQ7XHJcblxyXG4gICAgbGV0IGxhdGNoRnJvbSA9IGdldEVkZ2VMYXRjaFBvcyhmcm9tRWRnZSwgb2Zmc2V0WCwgb2Zmc2V0WSk7XHJcbiAgICBsZXQgbGF0Y2hUbyA9IGdldEVkZ2VMYXRjaFBvcyh0b0VkZ2UsIG9mZnNldFgsIG9mZnNldFkpO1xyXG4gICAgbGV0IHgxID0gbGF0Y2hGcm9tLng7XHJcbiAgICBsZXQgeTEgPSBsYXRjaEZyb20ueTtcclxuICAgIGxldCB4MiA9IGxhdGNoVG8ueDtcclxuICAgIGxldCB5MiA9IGxhdGNoVG8ueVxyXG5cclxuICAgIGlmICh4MSA+IHgyKSB7XHJcbiAgICAgICAgW3gxLCB4Ml0gPSBzd2FwVmFsdWVzKHgxLCB4Mik7XHJcbiAgICAgICAgW3kxLCB5Ml0gPSBzd2FwVmFsdWVzKHkxLCB5Mik7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGJlemllciA9IGdldEJlemllclBhdGgoXHJcbiAgICAgICAgKHgxIC0gdHJhbnNmb3JtLngpIC8gdHJhbnNmb3JtLnNjYWxlLFxyXG4gICAgICAgICh5MSAtIHRyYW5zZm9ybS55KSAvIHRyYW5zZm9ybS5zY2FsZSxcclxuICAgICAgICAoeDIgLSB0cmFuc2Zvcm0ueCkgLyB0cmFuc2Zvcm0uc2NhbGUsXHJcbiAgICAgICAgKHkyIC0gdHJhbnNmb3JtLnkpIC8gdHJhbnNmb3JtLnNjYWxlLFxyXG4gICAgICAgIGFwaS5vcHRzLmJlemllcldlaWdodCA/PyAwLjY3NVxyXG4gICAgKTtcclxuXHJcbiAgICAvL0FwcGx5IG91ciBiZXppZXIgY3VydmUgdG8gYm90aCB0aGUgaW5uZXIgYW5kIG91dGVyIGxpbmsgZWxlbWVudHNcclxuICAgIGxpbmsuYmFuZDEuc2V0QXR0cmlidXRlKCdkJywgYmV6aWVyKTtcclxuICAgIGxpbmsuYmFuZDIuc2V0QXR0cmlidXRlKCdkJywgYmV6aWVyKTtcclxuICAgIGxpbmsuYmFuZDMuc2V0QXR0cmlidXRlKCdkJywgYmV6aWVyKTtcclxufVxyXG5cclxuY29uc3QgYXBwbHlBbGxMaW5rUG9zaXRpb25zID0gKGFwaTogRmxvd1R5cGVzLkFwaSkgPT4ge1xyXG4gICAgYXBpLnN0YXRlLmxpbmtzLmZvckVhY2gobGluayA9PiBhcHBseUxpbmtQb3NpdGlvbihhcGksIGxpbmspKTtcclxufVxyXG5cclxuZXhwb3J0IHtcclxuICAgIHN3YXBWYWx1ZXMsXHJcbiAgICBjbG9uZSxcclxuICAgIGNsYW1wLFxyXG4gICAgZGlzdGFuY2UsXHJcbiAgICBtaWRwb2ludCxcclxuICAgIHRocm90dGxlLFxyXG4gICAgZmxhdHRlbixcclxuICAgIHJlc29sdmVQcm9wZXJ0eSxcclxuICAgIGFzc2lnblByb3BlcnR5LFxyXG4gICAgZ2V0QmV6aWVyUGF0aCxcclxuICAgIGludGVyc2VjdFJlY3QsXHJcbiAgICBEZWZhdWx0Tm9kZVRlbXBsYXRlLFxyXG4gICAgcGFyc2VOb2RlVGVtcGxhdGUsXHJcbiAgICBjcmVhdGVOb2RlLFxyXG4gICAgZ2V0RWRnZUNvbXBvc2l0ZUtleSxcclxuICAgIGdldExpbmtDb21wb3NpdGVLZXksXHJcbiAgICBjcmVhdGVFZGdlLFxyXG4gICAgZ2V0RWRnZUxhdGNoUG9zLFxyXG4gICAgY3JlYXRlTGluayxcclxuICAgIGdlbmVyYXRlRmxvd0VsLFxyXG4gICAgYWRkSXRlbUNsYXNzLFxyXG4gICAgcmVtb3ZlSXRlbUNsYXNzLFxyXG4gICAgYXBwbHlOb2RlUG9zaXRpb24sXHJcbiAgICBhcHBseUxpbmtQb3NpdGlvbixcclxuICAgIGFwcGx5QWxsTGlua1Bvc2l0aW9uc1xyXG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/flow-util.ts\n");

/***/ }),

/***/ "./src/flow.ts":
/*!*********************!*\
  !*** ./src/flow.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MXFlowController\": () => (/* binding */ MXFlowController)\n/* harmony export */ });\n/* harmony import */ var types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! types/flow.types.v2 */ \"./src/types/flow.types.v2.ts\");\n/* harmony import */ var _flow_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./flow-util */ \"./src/flow-util.ts\");\n/* harmony import */ var util_event_emitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! util/event-emitter */ \"./src/util/event-emitter.ts\");\n/* harmony import */ var _methods__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./methods */ \"./src/methods.ts\");\n/* harmony import */ var _systems_select__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./systems/select */ \"./src/systems/select.ts\");\n/* harmony import */ var _systems_drag__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./systems/drag */ \"./src/systems/drag.ts\");\n/* harmony import */ var _systems_lasso__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./systems/lasso */ \"./src/systems/lasso.ts\");\n/* harmony import */ var _systems_panzoom__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./systems/panzoom */ \"./src/systems/panzoom.ts\");\n/* harmony import */ var _systems_linker__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./systems/linker */ \"./src/systems/linker.ts\");\n/* harmony import */ var _systems_context__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./systems/context */ \"./src/systems/context.ts\");\n/* harmony import */ var _systems_shortcut__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./systems/shortcut */ \"./src/systems/shortcut.ts\");\n/* harmony import */ var _interact__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./interact */ \"./src/interact.ts\");\n\n\n\n\n\n\n\n\n\n\n\n //Creates internal state structure, passed to the various systems\n\nconst getMXFlowState = dom => {\n  return {\n    root: {\n      key: 'graph',\n      type: types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowItemType.Graph,\n      el: dom.rootEl\n    },\n    nodes: new Map(),\n    edges: new Map(),\n    links: new Map(),\n    preselected: new Map(),\n    selected: new Map(),\n    contextOpen: false,\n    undo: [],\n    redo: [],\n    transform: {\n      x: 0,\n      y: 0,\n      scale: 1\n    }\n  };\n}; //Default options, must include ALL possible options as it is deep-merged w/ user options on init\n\n\nconst DefaultOpts = {\n  nodeHTMLTemplate: _flow_util__WEBPACK_IMPORTED_MODULE_1__.DefaultNodeTemplate,\n  width: 5000,\n  height: 5000,\n  zIndexStart: 100,\n  showGrid: true,\n  gridSize: 32,\n  bezierWeight: 0.675,\n  linkValidator: () => true,\n  beforeLinkStart: () => true,\n  beforeLinkEnd: () => true,\n  beforeNodeRemoved: () => true,\n  beforeEdgeRemoved: () => true,\n  beforeLinkRemoved: () => true,\n  renderContext: () => {},\n  render: () => {},\n  background: {\n    type: 'dots',\n    size: 32,\n    radius: 0.4,\n    html: ''\n  },\n  drag: {\n    cancelSelector: '',\n    handleSelector: '',\n    gridX: 0,\n    gridY: 0,\n    latchThreshold: 5\n  },\n  select: {\n    multiSelectEnabled: true\n  },\n  undo: {\n    enabled: true,\n    max: Infinity,\n    actions: ['drag', 'addEdge', 'removeEdge', 'addLink', 'removeLink', 'addNode', 'removeNode', 'removeItems', 'clear', 'select']\n  },\n  lasso: {\n    enabled: true\n  },\n  panzoom: {\n    enabled: true,\n    minScale: 0.5,\n    maxScale: 2,\n    scaleStep: .25,\n    scale: 1,\n    x: 0,\n    y: 0\n  },\n  controls: {\n    panButton: 0,\n    panModifier: false,\n    panOnWheel: false,\n    panOnArrowKeys: true,\n    zoomOnWheelModifier: false,\n    zoomOnWheel: true,\n    zoomOnPinch: true,\n    zoomOnDoubleClick: false,\n    selectButton: 0,\n    multiSelectModifier: 'Shift',\n    lassoModifier: 'Control',\n    lassoButton: 0\n  }\n};\n/**\r\n * Flattens and merges the user options with the default options, ensuring that all options are present.\r\n *\r\n * @param opts\r\n * @returns\r\n */\n\nconst mergeDefaultOpts = opts => {\n  var _a;\n\n  let merged = {};\n  let defaultFlat = (0,_flow_util__WEBPACK_IMPORTED_MODULE_1__.flatten)(DefaultOpts);\n\n  for (let key in defaultFlat) {\n    (0,_flow_util__WEBPACK_IMPORTED_MODULE_1__.assignProperty)(key, merged, (_a = (0,_flow_util__WEBPACK_IMPORTED_MODULE_1__.resolveProperty)(key, opts)) !== null && _a !== void 0 ? _a : (0,_flow_util__WEBPACK_IMPORTED_MODULE_1__.resolveProperty)(key, DefaultOpts));\n  }\n\n  return merged;\n};\n\nfunction MXFlowController(targetEl, options) {\n  var _a, _b;\n\n  let opts = mergeDefaultOpts(options); //merge({}, DefaultOpts, options);\n\n  const dom = (0,_flow_util__WEBPACK_IMPORTED_MODULE_1__.generateFlowEl)(targetEl, opts);\n  const state = getMXFlowState(dom);\n  const events = new util_event_emitter__WEBPACK_IMPORTED_MODULE_2__.EventEmitter();\n  ``;\n  const tools = new Map();\n  const renderCache = new Map(); //Internal event emitter. Passed to tool instances.\n\n  const emit = (type, event) => {\n    events.emit(type, event);\n  }; //Methods to lock or unlock a specific tool. These are passed to tool instances only.\n\n\n  let toolLock = false;\n\n  const isLocked = exceptTool => toolLock !== false && toolLock.name !== exceptTool;\n\n  const unlock = () => toolLock = false;\n\n  const lock = toolName => {\n    if (!toolLock && tools.has(toolName)) {\n      toolLock = tools.get(toolName);\n    }\n  }; //API and methods, passed to tool instances.\n\n\n  const api = {\n    tools,\n    opts,\n    dom,\n    state,\n    emit,\n    lock,\n    unlock,\n    isLocked,\n    renderCache\n  };\n  const methods = (0,_methods__WEBPACK_IMPORTED_MODULE_3__.getPublicInterface)(api);\n  const interactions = (0,_interact__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(api, methods);\n  /**\r\n   * Creates new option set and notifies all subsystems to update state\\\r\n   *\r\n   * TODO: There are many options which are difficult to change at runtime, will need to consider\r\n   * whether this method is feasible. For now, individual setters are provided for some options.\r\n   *\r\n   * @param options\r\n   */\n  // const setOptions = (options: FlowTypes.Options) => {\n  //     opts = mergeDefaultOpts(options); //merge({}, DefaultOpts, options);\n  //     api.opts = opts;\n  //     tools.forEach(tool => tool.update?.(api));\n  // }\n\n  const setDragOptions = grid => {\n    opts.drag = Object.assign(Object.assign({}, opts.drag), grid);\n    api.opts = opts;\n    tools.forEach(tool => {\n      var _a;\n\n      return (_a = tool.update) === null || _a === void 0 ? void 0 : _a.call(tool, api);\n    });\n  };\n  /**\r\n   * Notifies all subsystems to cancel active operation (linking, dragging, etc.)\r\n   */\n\n\n  const cancel = () => {\n    tools.forEach(tool => {\n      var _a;\n\n      return (_a = tool.cancel) === null || _a === void 0 ? void 0 : _a.call(tool);\n    });\n  }; //Add tools\n\n\n  tools.set('select', (0,_systems_select__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(api, methods, interactions));\n  if ((_a = api.opts.lasso) === null || _a === void 0 ? void 0 : _a.enabled) tools.set('lasso', (0,_systems_lasso__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(api, methods, interactions));\n  if ((_b = api.opts.panzoom) === null || _b === void 0 ? void 0 : _b.enabled) tools.set('panzoom', (0,_systems_panzoom__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(api, methods, interactions));\n  tools.set('drag', (0,_systems_drag__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(api, methods, interactions));\n  tools.set('linker', (0,_systems_linker__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(api, methods, interactions));\n  tools.set('context', (0,_systems_context__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(api, methods, interactions));\n  tools.set('shortcut', (0,_systems_shortcut__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(api, methods));\n\n  const dispose = () => {\n    tools.forEach(tool => {\n      var _a;\n\n      return (_a = tool.dispose) === null || _a === void 0 ? void 0 : _a.call(tool);\n    });\n    interactions.dispose();\n    renderCache.clear();\n  }; //Return public facing api\n\n\n  return Object.assign({\n    on(type, listener) {\n      events.on(type, listener);\n    },\n\n    removeListener(type, listener) {\n      events.removeListener(type, listener);\n    },\n\n    dispose,\n    setDragOptions,\n    cancel\n  }, methods);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QixTQUFLLENBQUMsT0FBTixDQUFjLElBQUksSUFBRztBQUFBOztBQUFDLHVCQUFJLENBQUMsT0FBTCxNQUFZLElBQVosSUFBWSxhQUFaLEdBQVksTUFBWixHQUFZLFFBQVosSUFBWSxDQUFaO0FBQWdCLEtBQXRDO0FBQ0EsZ0JBQVksQ0FBQyxPQUFiO0FBQ0EsZUFBVyxDQUFDLEtBQVo7QUFDSCxHQUpELENBakV1RSxDQXVFdkU7OztBQUNBLFNBQU87QUFDSCxNQUFFLENBQXlDLElBQXpDLEVBQWtELFFBQWxELEVBQXFHO0FBQ25HLFlBQU0sQ0FBQyxFQUFQLENBQVUsSUFBVixFQUFnQixRQUFoQjtBQUNILEtBSEU7O0FBSUgsa0JBQWMsQ0FBeUMsSUFBekMsRUFBa0QsUUFBbEQsRUFBb0U7QUFDOUUsWUFBTSxDQUFDLGNBQVAsQ0FBc0IsSUFBdEIsRUFBNEIsUUFBNUI7QUFDSCxLQU5FOztBQU9ILFdBUEc7QUFRSCxrQkFSRztBQVNIO0FBVEcsS0FVQSxPQVZBLENBQVA7QUFZSCIsInNvdXJjZXMiOlsid2VicGFjazovL214Zmxvdy8uL3NyYy9mbG93LnRzP2VlN2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgRmxvd1R5cGVzIGZyb20gJ3R5cGVzL2Zsb3cudHlwZXMudjInO1xyXG5pbXBvcnQgeyBnZW5lcmF0ZUZsb3dFbCwgZmxhdHRlbiwgcmVzb2x2ZVByb3BlcnR5LCBhc3NpZ25Qcm9wZXJ0eSwgRGVmYXVsdE5vZGVUZW1wbGF0ZSB9ICBmcm9tICcuL2Zsb3ctdXRpbCc7XHJcbmltcG9ydCB7IEV2ZW50RW1pdHRlciwgTGlzdGVuZXIgfSBmcm9tICd1dGlsL2V2ZW50LWVtaXR0ZXInO1xyXG5pbXBvcnQgeyBnZXRQdWJsaWNJbnRlcmZhY2UgfSBmcm9tICcuL21ldGhvZHMnO1xyXG5pbXBvcnQgTVhGbG93U2VsZWN0VG9vbCBmcm9tICcuL3N5c3RlbXMvc2VsZWN0JztcclxuaW1wb3J0IE1YRmxvd0RyYWdUb29sIGZyb20gJy4vc3lzdGVtcy9kcmFnJztcclxuaW1wb3J0IE1YRmxvd0xhc3NvVG9vbCBmcm9tICcuL3N5c3RlbXMvbGFzc28nO1xyXG5pbXBvcnQgTVhGbG93UGFuWm9vbVRvb2wgZnJvbSAnLi9zeXN0ZW1zL3Bhbnpvb20nO1xyXG5pbXBvcnQgTVhGbG93TGlua2VyVG9vbCBmcm9tICcuL3N5c3RlbXMvbGlua2VyJztcclxuaW1wb3J0IE1YRmxvd0NvbnRleHRUb29sIGZyb20gJy4vc3lzdGVtcy9jb250ZXh0JztcclxuaW1wb3J0IE1YRmxvd1Nob3J0Y3V0VG9vbCBmcm9tICcuL3N5c3RlbXMvc2hvcnRjdXQnO1xyXG5pbXBvcnQgSW50ZXJhY3Rpb25FbWl0dGVyIGZyb20gJy4vaW50ZXJhY3QnO1xyXG5cclxuLy9DcmVhdGVzIGludGVybmFsIHN0YXRlIHN0cnVjdHVyZSwgcGFzc2VkIHRvIHRoZSB2YXJpb3VzIHN5c3RlbXNcclxuY29uc3QgZ2V0TVhGbG93U3RhdGUgPSAoZG9tOiBGbG93VHlwZXMuRmxvd0RvbSkgOiBGbG93VHlwZXMuRmxvd1N0YXRlID0+IHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcm9vdDoge1xyXG4gICAgICAgICAgICBrZXk6ICdncmFwaCcsXHJcbiAgICAgICAgICAgIHR5cGU6IEZsb3dUeXBlcy5GbG93SXRlbVR5cGUuR3JhcGgsXHJcbiAgICAgICAgICAgIGVsOiBkb20ucm9vdEVsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBub2RlczogbmV3IE1hcDxzdHJpbmcsIEZsb3dUeXBlcy5Ob2RlPigpLFxyXG4gICAgICAgIGVkZ2VzOiBuZXcgTWFwPHN0cmluZywgRmxvd1R5cGVzLkVkZ2U+KCksXHJcbiAgICAgICAgbGlua3M6IG5ldyBNYXA8c3RyaW5nLCBGbG93VHlwZXMuTGluaz4oKSxcclxuICAgICAgICBwcmVzZWxlY3RlZDogbmV3IE1hcDxzdHJpbmcsIEZsb3dUeXBlcy5TZWxlY3RhYmxlSXRlbT4oKSxcclxuICAgICAgICBzZWxlY3RlZDogbmV3IE1hcDxzdHJpbmcsIEZsb3dUeXBlcy5TZWxlY3RhYmxlSXRlbT4oKSxcclxuICAgICAgICBjb250ZXh0T3BlbjogZmFsc2UsXHJcbiAgICAgICAgdW5kbzogW10sXHJcbiAgICAgICAgcmVkbzogW10sXHJcbiAgICAgICAgdHJhbnNmb3JtOiB7XHJcbiAgICAgICAgICAgIHg6IDAsXHJcbiAgICAgICAgICAgIHk6IDAsXHJcbiAgICAgICAgICAgIHNjYWxlOiAxXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4vL0RlZmF1bHQgb3B0aW9ucywgbXVzdCBpbmNsdWRlIEFMTCBwb3NzaWJsZSBvcHRpb25zIGFzIGl0IGlzIGRlZXAtbWVyZ2VkIHcvIHVzZXIgb3B0aW9ucyBvbiBpbml0XHJcbmNvbnN0IERlZmF1bHRPcHRzOiBGbG93VHlwZXMuT3B0aW9ucyA9IHtcclxuICAgIG5vZGVIVE1MVGVtcGxhdGU6IERlZmF1bHROb2RlVGVtcGxhdGUsXHJcbiAgICB3aWR0aDogNTAwMCxcclxuICAgIGhlaWdodDogNTAwMCxcclxuICAgIHpJbmRleFN0YXJ0OiAxMDAsXHJcbiAgICBzaG93R3JpZDogdHJ1ZSxcclxuICAgIGdyaWRTaXplOiAzMixcclxuICAgIGJlemllcldlaWdodDogMC42NzUsXHJcbiAgICBsaW5rVmFsaWRhdG9yOiAoKSA9PiB0cnVlLFxyXG4gICAgYmVmb3JlTGlua1N0YXJ0OiAoKSA9PiB0cnVlLFxyXG4gICAgYmVmb3JlTGlua0VuZDogKCkgPT4gdHJ1ZSxcclxuICAgIGJlZm9yZU5vZGVSZW1vdmVkOiAoKSA9PiB0cnVlLFxyXG4gICAgYmVmb3JlRWRnZVJlbW92ZWQ6ICgpID0+IHRydWUsXHJcbiAgICBiZWZvcmVMaW5rUmVtb3ZlZDogKCkgPT4gdHJ1ZSxcclxuICAgIHJlbmRlckNvbnRleHQ6ICgpID0+IHt9LFxyXG4gICAgcmVuZGVyOiAoKSA9PiB7fSxcclxuICAgIGJhY2tncm91bmQ6IHtcclxuICAgICAgICB0eXBlOiAnZG90cycsXHJcbiAgICAgICAgc2l6ZTogMzIsXHJcbiAgICAgICAgcmFkaXVzOiAwLjQsXHJcbiAgICAgICAgaHRtbDogJydcclxuICAgIH0sXHJcbiAgICBkcmFnOiB7XHJcbiAgICAgICAgY2FuY2VsU2VsZWN0b3I6ICcnLFxyXG4gICAgICAgIGhhbmRsZVNlbGVjdG9yOiAnJyxcclxuICAgICAgICBncmlkWDogMCxcclxuICAgICAgICBncmlkWTogMCxcclxuICAgICAgICBsYXRjaFRocmVzaG9sZDogNVxyXG4gICAgfSxcclxuICAgIHNlbGVjdDoge1xyXG4gICAgICAgIG11bHRpU2VsZWN0RW5hYmxlZDogdHJ1ZVxyXG4gICAgfSxcclxuICAgIHVuZG86IHtcclxuICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgICAgIG1heDogSW5maW5pdHksXHJcbiAgICAgICAgYWN0aW9uczogW1xyXG4gICAgICAgICAgICAnZHJhZycsXHJcbiAgICAgICAgICAgICdhZGRFZGdlJyxcclxuICAgICAgICAgICAgJ3JlbW92ZUVkZ2UnLFxyXG4gICAgICAgICAgICAnYWRkTGluaycsXHJcbiAgICAgICAgICAgICdyZW1vdmVMaW5rJyxcclxuICAgICAgICAgICAgJ2FkZE5vZGUnLFxyXG4gICAgICAgICAgICAncmVtb3ZlTm9kZScsXHJcbiAgICAgICAgICAgICdyZW1vdmVJdGVtcycsXHJcbiAgICAgICAgICAgICdjbGVhcicsXHJcbiAgICAgICAgICAgICdzZWxlY3QnXHJcbiAgICAgICAgXVxyXG4gICAgfSxcclxuICAgIGxhc3NvOiB7XHJcbiAgICAgICAgZW5hYmxlZDogdHJ1ZVxyXG4gICAgfSxcclxuICAgIHBhbnpvb206IHtcclxuICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgICAgIG1pblNjYWxlOiAwLjUsXHJcbiAgICAgICAgbWF4U2NhbGU6IDIsXHJcbiAgICAgICAgc2NhbGVTdGVwOiAuMjUsXHJcbiAgICAgICAgc2NhbGU6IDEsXHJcbiAgICAgICAgeDogMCxcclxuICAgICAgICB5OiAwXHJcbiAgICB9LFxyXG4gICAgY29udHJvbHM6IHtcclxuICAgICAgICBwYW5CdXR0b246IDAsXHJcbiAgICAgICAgcGFuTW9kaWZpZXI6IGZhbHNlLFxyXG4gICAgICAgIHBhbk9uV2hlZWw6IGZhbHNlLFxyXG4gICAgICAgIHBhbk9uQXJyb3dLZXlzOiB0cnVlLFxyXG4gICAgICAgIHpvb21PbldoZWVsTW9kaWZpZXI6IGZhbHNlLFxyXG4gICAgICAgIHpvb21PbldoZWVsOiB0cnVlLFxyXG4gICAgICAgIHpvb21PblBpbmNoOiB0cnVlLFxyXG4gICAgICAgIHpvb21PbkRvdWJsZUNsaWNrOiBmYWxzZSxcclxuICAgICAgICBzZWxlY3RCdXR0b246IDAsXHJcbiAgICAgICAgbXVsdGlTZWxlY3RNb2RpZmllcjogJ1NoaWZ0JyxcclxuICAgICAgICBsYXNzb01vZGlmaWVyOiAnQ29udHJvbCcsXHJcbiAgICAgICAgbGFzc29CdXR0b246IDBcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEZsYXR0ZW5zIGFuZCBtZXJnZXMgdGhlIHVzZXIgb3B0aW9ucyB3aXRoIHRoZSBkZWZhdWx0IG9wdGlvbnMsIGVuc3VyaW5nIHRoYXQgYWxsIG9wdGlvbnMgYXJlIHByZXNlbnQuXHJcbiAqIFxyXG4gKiBAcGFyYW0gb3B0cyBcclxuICogQHJldHVybnMgXHJcbiAqL1xyXG5jb25zdCBtZXJnZURlZmF1bHRPcHRzID0gKG9wdHM6IEZsb3dUeXBlcy5PcHRpb25zKSA6IEZsb3dUeXBlcy5Db25maWcgPT4ge1xyXG4gICAgbGV0IG1lcmdlZCA9IHt9O1xyXG4gICAgbGV0IGRlZmF1bHRGbGF0ID0gZmxhdHRlbihEZWZhdWx0T3B0cyk7XHJcbiAgICBmb3IgKGxldCBrZXkgaW4gZGVmYXVsdEZsYXQpe1xyXG4gICAgICAgIGFzc2lnblByb3BlcnR5KGtleSwgbWVyZ2VkLCByZXNvbHZlUHJvcGVydHkoa2V5LCBvcHRzKSA/PyByZXNvbHZlUHJvcGVydHkoa2V5LCBEZWZhdWx0T3B0cykpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gPEZsb3dUeXBlcy5Db25maWc+IG1lcmdlZDtcclxufVxyXG5cclxuZnVuY3Rpb24gTVhGbG93Q29udHJvbGxlcih0YXJnZXRFbDogSFRNTEVsZW1lbnQsIG9wdGlvbnM6IEZsb3dUeXBlcy5PcHRpb25zKXtcclxuICAgIGxldCBvcHRzID0gbWVyZ2VEZWZhdWx0T3B0cyhvcHRpb25zKTsgLy9tZXJnZSh7fSwgRGVmYXVsdE9wdHMsIG9wdGlvbnMpO1xyXG4gICAgY29uc3QgZG9tID0gZ2VuZXJhdGVGbG93RWwodGFyZ2V0RWwsIG9wdHMpO1xyXG4gICAgY29uc3Qgc3RhdGUgPSBnZXRNWEZsb3dTdGF0ZShkb20pO1xyXG4gICAgY29uc3QgZXZlbnRzID0gbmV3IEV2ZW50RW1pdHRlcigpO2BgXHJcbiAgICBjb25zdCB0b29scyA9IG5ldyBNYXA8c3RyaW5nLCBGbG93VHlwZXMuQWN0aW9uSGFuZGxlcj4oKTtcclxuICAgIGNvbnN0IHJlbmRlckNhY2hlID0gbmV3IE1hcDxzdHJpbmcsIEVsZW1lbnQgfCBudWxsPigpO1xyXG5cclxuICAgIC8vSW50ZXJuYWwgZXZlbnQgZW1pdHRlci4gUGFzc2VkIHRvIHRvb2wgaW5zdGFuY2VzLlxyXG4gICAgY29uc3QgZW1pdCA9IDxLIGV4dGVuZHMga2V5b2YgRmxvd1R5cGVzLkZsb3dFdmVudE1hcD4odHlwZTogSywgZXZlbnQ/OiBGbG93VHlwZXMuRmxvd0V2ZW50TWFwW0tdKSA9PiB7XHJcbiAgICAgICAgZXZlbnRzLmVtaXQodHlwZSwgZXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vTWV0aG9kcyB0byBsb2NrIG9yIHVubG9jayBhIHNwZWNpZmljIHRvb2wuIFRoZXNlIGFyZSBwYXNzZWQgdG8gdG9vbCBpbnN0YW5jZXMgb25seS5cclxuICAgIGxldCB0b29sTG9jazogRmxvd1R5cGVzLkFjdGlvbkhhbmRsZXIgfCBmYWxzZSA9IGZhbHNlO1xyXG4gICAgY29uc3QgaXNMb2NrZWQgPSAoZXhjZXB0VG9vbD86IHN0cmluZykgPT4gdG9vbExvY2sgIT09IGZhbHNlICYmIHRvb2xMb2NrLm5hbWUgIT09IGV4Y2VwdFRvb2w7XHJcbiAgICBjb25zdCB1bmxvY2sgPSAoKSA9PiB0b29sTG9jayA9IGZhbHNlO1xyXG4gICAgY29uc3QgbG9jayA9ICh0b29sTmFtZTogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgaWYgKCF0b29sTG9jayAmJiB0b29scy5oYXModG9vbE5hbWUpKXtcclxuICAgICAgICAgICAgdG9vbExvY2sgPSB0b29scy5nZXQodG9vbE5hbWUpITtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9BUEkgYW5kIG1ldGhvZHMsIHBhc3NlZCB0byB0b29sIGluc3RhbmNlcy5cclxuICAgIGNvbnN0IGFwaTogRmxvd1R5cGVzLkFwaSA9IDxjb25zdD4geyB0b29scywgb3B0cywgZG9tLCBzdGF0ZSwgZW1pdCwgbG9jaywgdW5sb2NrLCBpc0xvY2tlZCwgcmVuZGVyQ2FjaGUgfTtcclxuICAgIGNvbnN0IG1ldGhvZHMgPSBnZXRQdWJsaWNJbnRlcmZhY2UoYXBpKTtcclxuICAgIGNvbnN0IGludGVyYWN0aW9ucyA9IEludGVyYWN0aW9uRW1pdHRlcihhcGksIG1ldGhvZHMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBuZXcgb3B0aW9uIHNldCBhbmQgbm90aWZpZXMgYWxsIHN1YnN5c3RlbXMgdG8gdXBkYXRlIHN0YXRlXFxcclxuICAgICAqIFxyXG4gICAgICogVE9ETzogVGhlcmUgYXJlIG1hbnkgb3B0aW9ucyB3aGljaCBhcmUgZGlmZmljdWx0IHRvIGNoYW5nZSBhdCBydW50aW1lLCB3aWxsIG5lZWQgdG8gY29uc2lkZXIgXHJcbiAgICAgKiB3aGV0aGVyIHRoaXMgbWV0aG9kIGlzIGZlYXNpYmxlLiBGb3Igbm93LCBpbmRpdmlkdWFsIHNldHRlcnMgYXJlIHByb3ZpZGVkIGZvciBzb21lIG9wdGlvbnMuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIFxyXG4gICAgICovXHJcbiAgICAvLyBjb25zdCBzZXRPcHRpb25zID0gKG9wdGlvbnM6IEZsb3dUeXBlcy5PcHRpb25zKSA9PiB7XHJcbiAgICAvLyAgICAgb3B0cyA9IG1lcmdlRGVmYXVsdE9wdHMob3B0aW9ucyk7IC8vbWVyZ2Uoe30sIERlZmF1bHRPcHRzLCBvcHRpb25zKTtcclxuICAgIC8vICAgICBhcGkub3B0cyA9IG9wdHM7XHJcbiAgICAvLyAgICAgdG9vbHMuZm9yRWFjaCh0b29sID0+IHRvb2wudXBkYXRlPy4oYXBpKSk7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgY29uc3Qgc2V0RHJhZ09wdGlvbnMgPSAoZ3JpZDogRmxvd1R5cGVzLkRyYWdPcHRpb25zKSA9PiB7XHJcbiAgICAgICAgb3B0cy5kcmFnID0geyAuLi5vcHRzLmRyYWcsIC4uLmdyaWQgfTtcclxuICAgICAgICBhcGkub3B0cyA9IG9wdHM7XHJcbiAgICAgICAgdG9vbHMuZm9yRWFjaCh0b29sID0+IHRvb2wudXBkYXRlPy4oYXBpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOb3RpZmllcyBhbGwgc3Vic3lzdGVtcyB0byBjYW5jZWwgYWN0aXZlIG9wZXJhdGlvbiAobGlua2luZywgZHJhZ2dpbmcsIGV0Yy4pXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGNhbmNlbCA9ICgpID0+IHtcclxuICAgICAgICB0b29scy5mb3JFYWNoKHRvb2wgPT4gdG9vbC5jYW5jZWw/LigpKTtcclxuICAgIH1cclxuXHJcbiAgICAvL0FkZCB0b29sc1xyXG4gICAgdG9vbHMuc2V0KCdzZWxlY3QnLCBNWEZsb3dTZWxlY3RUb29sKGFwaSwgbWV0aG9kcywgaW50ZXJhY3Rpb25zKSk7XHJcbiAgICBpZiAoYXBpLm9wdHMubGFzc28/LmVuYWJsZWQpIHRvb2xzLnNldCgnbGFzc28nLCBNWEZsb3dMYXNzb1Rvb2woYXBpLCBtZXRob2RzLCBpbnRlcmFjdGlvbnMpKTtcclxuICAgIGlmIChhcGkub3B0cy5wYW56b29tPy5lbmFibGVkKSB0b29scy5zZXQoJ3Bhbnpvb20nLCBNWEZsb3dQYW5ab29tVG9vbChhcGksIG1ldGhvZHMsIGludGVyYWN0aW9ucykpO1xyXG4gICAgdG9vbHMuc2V0KCdkcmFnJywgTVhGbG93RHJhZ1Rvb2woYXBpLCBtZXRob2RzLCBpbnRlcmFjdGlvbnMpKTtcclxuICAgIHRvb2xzLnNldCgnbGlua2VyJywgTVhGbG93TGlua2VyVG9vbChhcGksIG1ldGhvZHMsIGludGVyYWN0aW9ucykpO1xyXG4gICAgdG9vbHMuc2V0KCdjb250ZXh0JywgTVhGbG93Q29udGV4dFRvb2woYXBpLCBtZXRob2RzLCBpbnRlcmFjdGlvbnMpKTtcclxuICAgIHRvb2xzLnNldCgnc2hvcnRjdXQnLCBNWEZsb3dTaG9ydGN1dFRvb2woYXBpLCBtZXRob2RzKSk7XHJcbiAgICBcclxuXHJcbiAgICBjb25zdCBkaXNwb3NlID0gKCkgPT4ge1xyXG4gICAgICAgIHRvb2xzLmZvckVhY2godG9vbCA9PiB0b29sLmRpc3Bvc2U/LigpKTtcclxuICAgICAgICBpbnRlcmFjdGlvbnMuZGlzcG9zZSgpO1xyXG4gICAgICAgIHJlbmRlckNhY2hlLmNsZWFyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy9SZXR1cm4gcHVibGljIGZhY2luZyBhcGlcclxuICAgIHJldHVybiA8Y29uc3Q+IHtcclxuICAgICAgICBvbjxLIGV4dGVuZHMga2V5b2YgRmxvd1R5cGVzLkZsb3dFdmVudE1hcD4odHlwZTogSywgbGlzdGVuZXI6IChldmVudDogRmxvd1R5cGVzLkZsb3dFdmVudE1hcFtLXSkgPT4gYW55KXtcclxuICAgICAgICAgICAgZXZlbnRzLm9uKHR5cGUsIGxpc3RlbmVyKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlbW92ZUxpc3RlbmVyPEsgZXh0ZW5kcyBrZXlvZiBGbG93VHlwZXMuRmxvd0V2ZW50TWFwPih0eXBlOiBLLCBsaXN0ZW5lcjogTGlzdGVuZXIpe1xyXG4gICAgICAgICAgICBldmVudHMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGlzcG9zZSxcclxuICAgICAgICBzZXREcmFnT3B0aW9ucyxcclxuICAgICAgICBjYW5jZWwsXHJcbiAgICAgICAgLi4ubWV0aG9kc1xyXG4gICAgfVxyXG59XHJcblxyXG50eXBlIE1YRmxvd0NvbnRyb2xsZXJJbnN0YW5jZSA9IFJldHVyblR5cGU8dHlwZW9mIE1YRmxvd0NvbnRyb2xsZXI+O1xyXG5cclxuZXhwb3J0IHsgTVhGbG93Q29udHJvbGxlciwgTVhGbG93Q29udHJvbGxlckluc3RhbmNlIH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/flow.ts\n");

/***/ }),

/***/ "./src/helpers/background.ts":
/*!***********************************!*\
  !*** ./src/helpers/background.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types/flow.types.v2 */ \"./src/types/flow.types.v2.ts\");\n\n/**\r\n * Generates HTML for an SVG grid or dot-pattern background. Can be passes to `setBackground()` on mxflow instance.\r\n * Especially useful when creating multiple backgrounds for different scales.\r\n *\r\n * @param type - The background type. Currently supported values are 'grid' or 'dots'\r\n * @param size - The size of the background\r\n * @param radius - If `type=dots`, the radius of each individual dot\r\n * @returns\r\n */\n\nconst generateBackground = (type, size, radius) => {\n  let bg = '';\n\n  if (type === 'grid') {\n    let _size = size ? size : 32;\n\n    let _macroSize = _size * 10;\n\n    bg =\n    /* SVG */\n    `\n            <defs>\n                <pattern id=\"smallGrid\" width=\"${_size}\" height=\"${_size}\" patternUnits=\"userSpaceOnUse\">\n                    <path class=\"${_types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.GridInner}\" d=\"M ${_size} 0 L 0 0 0 ${_size}\" fill=\"none\" stroke=\"#273558\" stroke-width=\"0.5\"/>\n                </pattern>\n                <pattern id=\"grid\" width=\"${_macroSize}\" height=\"${_macroSize}\" patternUnits=\"userSpaceOnUse\">\n                    <rect width=\"${_macroSize}\" height=\"${_macroSize}\" fill=\"url(#smallGrid)\" />\n                    <path class=\"${_types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.GridOuter}\" d=\"M ${_macroSize} 0 L 0 0 0 ${_macroSize}\" fill=\"none\" stroke=\"#273558\" stroke-width=\"1\"/>\n                </pattern>\n            </defs>\n            <rect width=\"100%\" height=\"100%\" fill=\"url(#grid)\" />\n        `;\n  } else {\n    let _size = size ? size : 15;\n\n    let _radius = radius ? radius : 0.4;\n\n    bg =\n    /* SVG */\n    `\n            <pattern id=\"mxflow-dot-pattern\" x=\"0\" y=\"0\" width=\"${_size}\" height=\"${_size}\" patternUnits=\"userSpaceOnUse\">\n                <circle cx=\"${_radius}\" cy=\"${_radius}\" r=\"${_radius}\" fill=\"#81818a\"></circle>\n            </pattern>\n            <rect x=\"0\" y=\"0\" width=\"100%\" height=\"100%\" fill=\"url(#mxflow-dot-pattern)\"></rect>\n        `;\n  }\n\n  let className = type === 'grid' ? _types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.Grid : _types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.Dots;\n  return (\n    /* SVG */\n    `\n        <svg class=\"${className}\" width=\"100%\" height=\"100%\" xmlns=\"http://www.w3.org/2000/svg\" \n            style=\"position:absolute; top:0; left:0; pointer-events:none; opacity:.5; display:block;'\">\n            ${bg}\n        </svg>\n    `\n  );\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (generateBackground);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaGVscGVycy9iYWNrZ3JvdW5kLnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFFQTs7Ozs7Ozs7QUFRRzs7QUFDSCxNQUFNLGtCQUFrQixHQUFHLENBQUMsSUFBRCxFQUF3QixJQUF4QixFQUF1QyxNQUF2QyxLQUEwRDtBQUNqRixNQUFJLEVBQUUsR0FBVyxFQUFqQjs7QUFDQSxNQUFJLElBQUksS0FBSyxNQUFiLEVBQW9CO0FBQ2hCLFFBQUksS0FBSyxHQUFHLElBQUksR0FBRyxJQUFILEdBQVUsRUFBMUI7O0FBQ0EsUUFBSSxVQUFVLEdBQUcsS0FBSyxHQUFHLEVBQXpCOztBQUNBLE1BQUU7QUFBRztBQUFVOztpREFFMEIsS0FBSyxhQUFhLEtBQUs7bUNBQ3JDLHFFQUFtQixVQUFVLEtBQUssY0FBYyxLQUFLOzs0Q0FFNUMsVUFBVSxhQUFhLFVBQVU7bUNBQzFDLFVBQVUsYUFBYSxVQUFVO21DQUNqQyxxRUFBbUIsVUFBVSxVQUFVLGNBQWMsVUFBVTs7OztBQUl6RixTQVhEO0FBWUgsR0FmRCxNQWVPO0FBQ0gsUUFBSSxLQUFLLEdBQUcsSUFBSSxHQUFHLElBQUgsR0FBVSxFQUExQjs7QUFDQSxRQUFJLE9BQU8sR0FBRyxNQUFNLEdBQUcsTUFBSCxHQUFZLEdBQWhDOztBQUNBLE1BQUU7QUFBRztBQUFVO2tFQUMyQyxLQUFLLGFBQWEsS0FBSzs4QkFDM0QsT0FBTyxTQUFTLE9BQU8sUUFBUSxPQUFPOzs7QUFHM0QsU0FMRDtBQU1IOztBQUVELE1BQUksU0FBUyxHQUFHLElBQUksS0FBSyxNQUFULEdBQWtCLGdFQUFsQixHQUFtQyxnRUFBbkQ7QUFDQTtBQUFPO0FBQVU7c0JBQ0MsU0FBUzs7Y0FFakIsRUFBRTs7QUFFWDtBQUxEO0FBTUgsQ0FuQ0Q7O0FBcUNBLGlFQUFlLGtCQUFmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXhmbG93Ly4vc3JjL2hlbHBlcnMvYmFja2dyb3VuZC50cz9lYTdhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEZsb3dDbGFzcyB9IGZyb20gJy4uL3R5cGVzL2Zsb3cudHlwZXMudjInO1xyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlcyBIVE1MIGZvciBhbiBTVkcgZ3JpZCBvciBkb3QtcGF0dGVybiBiYWNrZ3JvdW5kLiBDYW4gYmUgcGFzc2VzIHRvIGBzZXRCYWNrZ3JvdW5kKClgIG9uIG14ZmxvdyBpbnN0YW5jZS5cclxuICogRXNwZWNpYWxseSB1c2VmdWwgd2hlbiBjcmVhdGluZyBtdWx0aXBsZSBiYWNrZ3JvdW5kcyBmb3IgZGlmZmVyZW50IHNjYWxlcy5cclxuICogXHJcbiAqIEBwYXJhbSB0eXBlIC0gVGhlIGJhY2tncm91bmQgdHlwZS4gQ3VycmVudGx5IHN1cHBvcnRlZCB2YWx1ZXMgYXJlICdncmlkJyBvciAnZG90cydcclxuICogQHBhcmFtIHNpemUgLSBUaGUgc2l6ZSBvZiB0aGUgYmFja2dyb3VuZFxyXG4gKiBAcGFyYW0gcmFkaXVzIC0gSWYgYHR5cGU9ZG90c2AsIHRoZSByYWRpdXMgb2YgZWFjaCBpbmRpdmlkdWFsIGRvdFxyXG4gKiBAcmV0dXJucyBcclxuICovXHJcbmNvbnN0IGdlbmVyYXRlQmFja2dyb3VuZCA9ICh0eXBlOiAnZ3JpZCcgfCAnZG90cycsIHNpemU/OiBudW1iZXIsIHJhZGl1cz86IG51bWJlcikgPT4ge1xyXG4gICAgbGV0IGJnOiBzdHJpbmcgPSAnJztcclxuICAgIGlmICh0eXBlID09PSAnZ3JpZCcpe1xyXG4gICAgICAgIGxldCBfc2l6ZSA9IHNpemUgPyBzaXplIDogMzI7XHJcbiAgICAgICAgbGV0IF9tYWNyb1NpemUgPSBfc2l6ZSAqIDEwO1xyXG4gICAgICAgIGJnID0gLyogU1ZHICovIGBcclxuICAgICAgICAgICAgPGRlZnM+XHJcbiAgICAgICAgICAgICAgICA8cGF0dGVybiBpZD1cInNtYWxsR3JpZFwiIHdpZHRoPVwiJHtfc2l6ZX1cIiBoZWlnaHQ9XCIke19zaXplfVwiIHBhdHRlcm5Vbml0cz1cInVzZXJTcGFjZU9uVXNlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHBhdGggY2xhc3M9XCIke0Zsb3dDbGFzcy5HcmlkSW5uZXJ9XCIgZD1cIk0gJHtfc2l6ZX0gMCBMIDAgMCAwICR7X3NpemV9XCIgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCIjMjczNTU4XCIgc3Ryb2tlLXdpZHRoPVwiMC41XCIvPlxyXG4gICAgICAgICAgICAgICAgPC9wYXR0ZXJuPlxyXG4gICAgICAgICAgICAgICAgPHBhdHRlcm4gaWQ9XCJncmlkXCIgd2lkdGg9XCIke19tYWNyb1NpemV9XCIgaGVpZ2h0PVwiJHtfbWFjcm9TaXplfVwiIHBhdHRlcm5Vbml0cz1cInVzZXJTcGFjZU9uVXNlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHJlY3Qgd2lkdGg9XCIke19tYWNyb1NpemV9XCIgaGVpZ2h0PVwiJHtfbWFjcm9TaXplfVwiIGZpbGw9XCJ1cmwoI3NtYWxsR3JpZClcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgIDxwYXRoIGNsYXNzPVwiJHtGbG93Q2xhc3MuR3JpZE91dGVyfVwiIGQ9XCJNICR7X21hY3JvU2l6ZX0gMCBMIDAgMCAwICR7X21hY3JvU2l6ZX1cIiBmaWxsPVwibm9uZVwiIHN0cm9rZT1cIiMyNzM1NThcIiBzdHJva2Utd2lkdGg9XCIxXCIvPlxyXG4gICAgICAgICAgICAgICAgPC9wYXR0ZXJuPlxyXG4gICAgICAgICAgICA8L2RlZnM+XHJcbiAgICAgICAgICAgIDxyZWN0IHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiBmaWxsPVwidXJsKCNncmlkKVwiIC8+XHJcbiAgICAgICAgYFxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBsZXQgX3NpemUgPSBzaXplID8gc2l6ZSA6IDE1O1xyXG4gICAgICAgIGxldCBfcmFkaXVzID0gcmFkaXVzID8gcmFkaXVzIDogMC40O1xyXG4gICAgICAgIGJnID0gLyogU1ZHICovIGBcclxuICAgICAgICAgICAgPHBhdHRlcm4gaWQ9XCJteGZsb3ctZG90LXBhdHRlcm5cIiB4PVwiMFwiIHk9XCIwXCIgd2lkdGg9XCIke19zaXplfVwiIGhlaWdodD1cIiR7X3NpemV9XCIgcGF0dGVyblVuaXRzPVwidXNlclNwYWNlT25Vc2VcIj5cclxuICAgICAgICAgICAgICAgIDxjaXJjbGUgY3g9XCIke19yYWRpdXN9XCIgY3k9XCIke19yYWRpdXN9XCIgcj1cIiR7X3JhZGl1c31cIiBmaWxsPVwiIzgxODE4YVwiPjwvY2lyY2xlPlxyXG4gICAgICAgICAgICA8L3BhdHRlcm4+XHJcbiAgICAgICAgICAgIDxyZWN0IHg9XCIwXCIgeT1cIjBcIiB3aWR0aD1cIjEwMCVcIiBoZWlnaHQ9XCIxMDAlXCIgZmlsbD1cInVybCgjbXhmbG93LWRvdC1wYXR0ZXJuKVwiPjwvcmVjdD5cclxuICAgICAgICBgXHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGNsYXNzTmFtZSA9IHR5cGUgPT09ICdncmlkJyA/IEZsb3dDbGFzcy5HcmlkIDogRmxvd0NsYXNzLkRvdHM7XHJcbiAgICByZXR1cm4gLyogU1ZHICovIGBcclxuICAgICAgICA8c3ZnIGNsYXNzPVwiJHtjbGFzc05hbWV9XCIgd2lkdGg9XCIxMDAlXCIgaGVpZ2h0PVwiMTAwJVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBcclxuICAgICAgICAgICAgc3R5bGU9XCJwb3NpdGlvbjphYnNvbHV0ZTsgdG9wOjA7IGxlZnQ6MDsgcG9pbnRlci1ldmVudHM6bm9uZTsgb3BhY2l0eTouNTsgZGlzcGxheTpibG9jazsnXCI+XHJcbiAgICAgICAgICAgICR7Ymd9XHJcbiAgICAgICAgPC9zdmc+XHJcbiAgICBgXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGdlbmVyYXRlQmFja2dyb3VuZDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/helpers/background.ts\n");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MXFlow\": () => (/* reexport safe */ _flow__WEBPACK_IMPORTED_MODULE_0__.MXFlowController)\n/* harmony export */ });\n/* harmony import */ var _flow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./flow */ \"./src/flow.ts\");\n/* harmony import */ var _styles_default_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./styles/default.css */ \"./src/styles/default.css\");\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXgudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL214Zmxvdy8uL3NyYy9pbmRleC50cz9mZmI0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1YRmxvd0NvbnRyb2xsZXIgYXMgTVhGbG93LCBNWEZsb3dDb250cm9sbGVySW5zdGFuY2UgYXMgTVhGbG93SW5zdGFuY2UgfSBmcm9tIFwiLi9mbG93XCI7XHJcbmltcG9ydCAnLi9zdHlsZXMvZGVmYXVsdC5jc3MnO1xyXG5cclxuZXhwb3J0IHsgTVhGbG93LCBNWEZsb3dJbnN0YW5jZSB9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/index.ts\n");

/***/ }),

/***/ "./src/interact.ts":
/*!*************************!*\
  !*** ./src/interact.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _util_event_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/event-emitter */ \"./src/util/event-emitter.ts\");\n\n\nconst getModifierMap = api => {\n  const controls = api.opts.controls;\n  const modifiers = new Map();\n  if (typeof controls.multiSelectModifier === 'string') modifiers.set(controls.multiSelectModifier.toLowerCase(), false);\n  if (typeof controls.panModifier === 'string') modifiers.set(controls.panModifier.toLowerCase(), false);\n  if (typeof controls.zoomOnWheelModifier === 'string') modifiers.set(controls.zoomOnWheelModifier.toLowerCase(), false);\n  if (typeof controls.lassoModifier === 'string') modifiers.set(controls.lassoModifier.toLowerCase(), false);\n  return modifiers;\n};\n\nconst InteractionEmitter = (api, methods) => {\n  const events = new _util_event_emitter__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();\n\n  const emit = (type, event) => {\n    events.emit(type, event);\n  };\n  /**\r\n   * Map to keep track of modifiers and their states\r\n   */\n\n\n  const modifiers = getModifierMap(api);\n  /**\r\n   * Double tap state\r\n   */\n\n  const doubleTap = {\n    thresholdMs: 25,\n    lastTarget: null,\n    timeout: null\n  };\n  /**\r\n   * Dragging state\r\n   */\n\n  const drag = {\n    thresholdPx: 3,\n    startEvent: null,\n    latched: false\n  };\n\n  const getDragLatched = e => {\n    let deltaX = e.clientX - drag.startEvent.clientX;\n    let deltaY = e.clientY - drag.startEvent.clientY;\n    return Math.abs(deltaX) > drag.thresholdPx || Math.abs(deltaY) > drag.thresholdPx;\n  };\n  /**\r\n   * Get a drag event\r\n   *\r\n   * @param e - The event from which to calcualte deltas\r\n   * @param source - Pass in an alternate source event. This is used to pass in original PointerEvent\r\n   * for `dragstart` event, but calculate deltas from last move event.\r\n   * @returns\r\n   */\n\n\n  const getDragEvent = (e, source) => {\n    let deltaX = e.clientX - drag.startEvent.clientX;\n    let deltaY = e.clientY - drag.startEvent.clientY;\n    return {\n      start: drag.startEvent,\n      source: source !== null && source !== void 0 ? source : e,\n      deltaX: deltaX,\n      deltaY: deltaY,\n      scaledDeltaX: deltaX / api.state.transform.scale,\n      scaledDeltaY: deltaY / api.state.transform.scale\n    };\n  };\n\n  const handlePointerDown = e => {\n    /**\r\n     * Handle double tap\r\n     */\n    if (!doubleTap.lastTarget) {\n      //Set initial timeout\n      doubleTap.lastTarget = e.target;\n      doubleTap.timeout = window.setTimeout(() => doubleTap.lastTarget = null, doubleTap.thresholdMs);\n    } else if (e.target === doubleTap.lastTarget) {\n      emit('doubletap', {\n        source: e\n      }); //Tap on same target before timeout cleared, emit event\n    } else {\n      window.clearTimeout(doubleTap.timeout); //Wrong target or timeout nullified original target\n    }\n    /**\r\n     * Handle drag start, but not latch\r\n     *\r\n     * TODO: Need a check here for a \"user content\" sort of section where dragging doesn't take place,\r\n     * something like !(<HTMLElement> e.target).hasAttribute(FlowTypes.FlowAttr.NodeContent) except needs to\r\n     * account for child elements.\r\n     *\r\n     * Also, not here, but we may want something similar for the context menu so that users can select text, etc.\r\n     *\r\n     */\n\n\n    if (e.isPrimary) {\n      drag.startEvent = e;\n    }\n\n    emit('down', {\n      source: e\n    });\n  };\n\n  const handlePointerMove = e => {\n    /**\r\n     * Handle drag\r\n     */\n    if (e.isPrimary && drag.startEvent) {\n      if (!drag.latched) {\n        /**\r\n         * Emit dragstart if we have dragged past the \"latch\" threshold\r\n         */\n        if (getDragLatched(e)) {\n          emit('dragstart', getDragEvent(drag.startEvent, drag.startEvent));\n          drag.startEvent = e;\n          drag.latched = true;\n        }\n      } else {\n        /**\r\n         * If we've already latched, emit drag event\r\n         */\n        emit('drag', getDragEvent(e));\n      }\n    }\n\n    emit('move', {\n      source: e\n    });\n  };\n\n  const handlePointerUp = e => {\n    /**\r\n     * End our drag event if applicable\r\n     */\n    if (drag.startEvent && e.isPrimary) {\n      if (drag.latched) {\n        emit('dragend', getDragEvent(e));\n      }\n\n      drag.latched = false;\n      drag.startEvent = null;\n    }\n\n    emit('up', {\n      source: e\n    });\n  };\n\n  const handleDoubleClick = e => {\n    emit('doubletap', {\n      source: e\n    });\n  };\n\n  const updateModifiers = e => {\n    let code = e.key.toLowerCase();\n    let val = modifiers.get(code);\n\n    if (val !== null && val !== undefined) {\n      modifiers.set(code, e.type === 'keydown');\n    }\n  };\n\n  const handleKeyDown = e => {\n    updateModifiers(e);\n    emit('keydown', {\n      source: e\n    });\n  };\n\n  const handleKeyUp = e => {\n    updateModifiers(e);\n    emit('keyup', {\n      source: e\n    });\n  };\n\n  const handleContextMenu = e => {\n    if (methods.eventInGraph(e)) {\n      e.preventDefault();\n      emit('contextmenu', {\n        source: e,\n        item: methods.resolveItem(e)\n      });\n    }\n  };\n\n  const handleWheel = e => {\n    if (methods.eventInGraph(e)) {\n      //e.preventDefault();\n      emit('wheel', {\n        source: e\n      });\n    }\n  };\n\n  document.addEventListener('pointerdown', handlePointerDown);\n  document.addEventListener('pointermove', handlePointerMove);\n  document.addEventListener('pointerup', handlePointerUp);\n  document.addEventListener('keydown', handleKeyDown);\n  document.addEventListener('keyup', handleKeyUp);\n  document.addEventListener('dblclick', handleDoubleClick);\n  document.addEventListener('contextmenu', handleContextMenu);\n  document.addEventListener('wheel', handleWheel);\n  return {\n    on(type, listener) {\n      events.on(type, listener);\n    },\n\n    removeListener(type, listener) {\n      events.removeListener(type, listener);\n    },\n\n    dispose() {\n      document.removeEventListener('pointerdown', handlePointerDown);\n      document.removeEventListener('pointerdown', handlePointerUp);\n      document.removeEventListener('pointerdown', handlePointerMove);\n      document.removeEventListener('keydown', handleKeyDown);\n      document.removeEventListener('keyup', handleKeyUp);\n      document.removeEventListener('dblclick', handleDoubleClick);\n      document.removeEventListener('contextmenu', handleContextMenu);\n      document.removeEventListener('wheel', handleWheel);\n    },\n\n    /**\r\n     * Returns true if the modifier key denoted by the given modifier control option\r\n     * is active. ()\r\n     *\r\n     * @param modConfigOpt - The config option (`panModifier`, `multiSelectModifier` etc.);\r\n     */\n    isModActive(modConfigOpt) {\n      let key = api.opts.controls[modConfigOpt];\n\n      if (typeof key === 'string') {\n        return modifiers.get(key.toLowerCase());\n      }\n    },\n\n    isModKeyActive(key) {\n      return modifiers.get(key.toLowerCase());\n    },\n\n    rebaseDrag(e) {\n      drag.startEvent = e;\n    },\n\n    dragging() {\n      return drag.latched;\n    }\n\n  };\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (InteractionEmitter);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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R0FBRyxDQUFDLFdBQUosRUFBZCxDQUFQO0FBQ0g7QUFDSixLQTVCVTs7QUE2Qlgsa0JBQWMsQ0FBQyxHQUFELEVBQVk7QUFDdEIsYUFBTyxTQUFTLENBQUMsR0FBVixDQUFjLEdBQUcsQ0FBQyxXQUFKLEVBQWQsQ0FBUDtBQUNILEtBL0JVOztBQWdDWCxjQUFVLENBQUMsQ0FBRCxFQUFnQjtBQUN0QixVQUFJLENBQUMsVUFBTCxHQUFrQixDQUFsQjtBQUNILEtBbENVOztBQW1DWCxZQUFRO0FBQ0osYUFBTyxJQUFJLENBQUMsT0FBWjtBQUNIOztBQXJDVSxHQUFmO0FBdUNILENBdE5EOztBQXdOQSxpRUFBZSxrQkFBZiIsInNvdXJjZXMiOlsid2VicGFjazovL214Zmxvdy8uL3NyYy9pbnRlcmFjdC50cz8yZDM5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV2ZW50RW1pdHRlciwgTGlzdGVuZXIgfSBmcm9tIFwiLi91dGlsL2V2ZW50LWVtaXR0ZXJcIjtcclxuaW1wb3J0ICogYXMgRmxvd1R5cGVzIGZyb20gJy4vdHlwZXMvZmxvdy50eXBlcy52Mic7XHJcbmltcG9ydCAqIGFzIEludGVyYWN0VHlwZXMgZnJvbSAnLi90eXBlcy9pbnRlcmFjdC50eXBlcyc7XHJcblxyXG5jb25zdCBnZXRNb2RpZmllck1hcCA9IChhcGk6IEZsb3dUeXBlcy5BcGkpID0+IHtcclxuICAgIGNvbnN0IGNvbnRyb2xzID0gYXBpLm9wdHMuY29udHJvbHM7XHJcbiAgICBjb25zdCBtb2RpZmllcnMgPSBuZXcgTWFwPHN0cmluZywgYm9vbGVhbj4oKTtcclxuICAgIGlmICh0eXBlb2YgY29udHJvbHMubXVsdGlTZWxlY3RNb2RpZmllciA9PT0gJ3N0cmluZycpIG1vZGlmaWVycy5zZXQoY29udHJvbHMubXVsdGlTZWxlY3RNb2RpZmllci50b0xvd2VyQ2FzZSgpLCBmYWxzZSk7XHJcbiAgICBpZiAodHlwZW9mIGNvbnRyb2xzLnBhbk1vZGlmaWVyID09PSAnc3RyaW5nJykgbW9kaWZpZXJzLnNldChjb250cm9scy5wYW5Nb2RpZmllci50b0xvd2VyQ2FzZSgpLCBmYWxzZSk7XHJcbiAgICBpZiAodHlwZW9mIGNvbnRyb2xzLnpvb21PbldoZWVsTW9kaWZpZXIgPT09ICdzdHJpbmcnKSBtb2RpZmllcnMuc2V0KGNvbnRyb2xzLnpvb21PbldoZWVsTW9kaWZpZXIudG9Mb3dlckNhc2UoKSwgZmFsc2UpO1xyXG4gICAgaWYgKHR5cGVvZiBjb250cm9scy5sYXNzb01vZGlmaWVyID09PSAnc3RyaW5nJykgbW9kaWZpZXJzLnNldChjb250cm9scy5sYXNzb01vZGlmaWVyLnRvTG93ZXJDYXNlKCksIGZhbHNlKTtcclxuICAgIHJldHVybiBtb2RpZmllcnM7XHJcbn1cclxuXHJcbmNvbnN0IEludGVyYWN0aW9uRW1pdHRlciA9IChhcGk6IEZsb3dUeXBlcy5BcGksIG1ldGhvZHM6IEZsb3dUeXBlcy5NZXRob2RzKSA9PiB7XHJcbiAgICBjb25zdCBldmVudHMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICBjb25zdCBlbWl0ID0gPEsgZXh0ZW5kcyBrZXlvZiBJbnRlcmFjdFR5cGVzLkludGVyYWN0RXZlbnRNYXA+KHR5cGU6IEssIGV2ZW50PzogSW50ZXJhY3RUeXBlcy5JbnRlcmFjdEV2ZW50TWFwW0tdKSA9PiB7XHJcbiAgICAgICAgZXZlbnRzLmVtaXQodHlwZSwgZXZlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwIHRvIGtlZXAgdHJhY2sgb2YgbW9kaWZpZXJzIGFuZCB0aGVpciBzdGF0ZXNcclxuICAgICAqL1xyXG4gICAgY29uc3QgbW9kaWZpZXJzID0gZ2V0TW9kaWZpZXJNYXAoYXBpKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIERvdWJsZSB0YXAgc3RhdGVcclxuICAgICAqL1xyXG4gICAgY29uc3QgZG91YmxlVGFwIDogSW50ZXJhY3RUeXBlcy5Eb3VibGVUYXAgPSB7XHJcbiAgICAgICAgdGhyZXNob2xkTXM6IDI1LFxyXG4gICAgICAgIGxhc3RUYXJnZXQ6IG51bGwsXHJcbiAgICAgICAgdGltZW91dDogbnVsbFxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRHJhZ2dpbmcgc3RhdGVcclxuICAgICAqL1xyXG4gICAgY29uc3QgZHJhZyA6IEludGVyYWN0VHlwZXMuRHJhZyA9IHtcclxuICAgICAgICB0aHJlc2hvbGRQeDogMywgXHJcbiAgICAgICAgc3RhcnRFdmVudDogbnVsbCxcclxuICAgICAgICBsYXRjaGVkOiBmYWxzZVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGdldERyYWdMYXRjaGVkID0gKGU6IFBvaW50ZXJFdmVudCkgPT4ge1xyXG4gICAgICAgIGxldCBkZWx0YVggPSBlLmNsaWVudFggLSBkcmFnLnN0YXJ0RXZlbnQhLmNsaWVudFg7XHJcbiAgICAgICAgbGV0IGRlbHRhWSA9IGUuY2xpZW50WSAtIGRyYWcuc3RhcnRFdmVudCEuY2xpZW50WTtcclxuICAgICAgICByZXR1cm4gKE1hdGguYWJzKGRlbHRhWCkgPiBkcmFnLnRocmVzaG9sZFB4IHx8IE1hdGguYWJzKGRlbHRhWSkgPiBkcmFnLnRocmVzaG9sZFB4KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBhIGRyYWcgZXZlbnRcclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIGUgLSBUaGUgZXZlbnQgZnJvbSB3aGljaCB0byBjYWxjdWFsdGUgZGVsdGFzXHJcbiAgICAgKiBAcGFyYW0gc291cmNlIC0gUGFzcyBpbiBhbiBhbHRlcm5hdGUgc291cmNlIGV2ZW50LiBUaGlzIGlzIHVzZWQgdG8gcGFzcyBpbiBvcmlnaW5hbCBQb2ludGVyRXZlbnRcclxuICAgICAqIGZvciBgZHJhZ3N0YXJ0YCBldmVudCwgYnV0IGNhbGN1bGF0ZSBkZWx0YXMgZnJvbSBsYXN0IG1vdmUgZXZlbnQuXHJcbiAgICAgKiBAcmV0dXJucyBcclxuICAgICAqL1xyXG4gICAgY29uc3QgZ2V0RHJhZ0V2ZW50ID0gKGU6IFBvaW50ZXJFdmVudCwgc291cmNlPzogUG9pbnRlckV2ZW50KSA9PiB7XHJcbiAgICAgICAgbGV0IGRlbHRhWCA9IGUuY2xpZW50WCAtIGRyYWcuc3RhcnRFdmVudCEuY2xpZW50WDtcclxuICAgICAgICBsZXQgZGVsdGFZID0gZS5jbGllbnRZIC0gZHJhZy5zdGFydEV2ZW50IS5jbGllbnRZO1xyXG4gICAgICAgIHJldHVybiB7IFxyXG4gICAgICAgICAgICBzdGFydDogZHJhZy5zdGFydEV2ZW50ISxcclxuICAgICAgICAgICAgc291cmNlOiBzb3VyY2UgPz8gZSxcclxuICAgICAgICAgICAgZGVsdGFYOiBkZWx0YVgsXHJcbiAgICAgICAgICAgIGRlbHRhWTogZGVsdGFZLFxyXG4gICAgICAgICAgICBzY2FsZWREZWx0YVg6IGRlbHRhWCAvIGFwaS5zdGF0ZS50cmFuc2Zvcm0uc2NhbGUsXHJcbiAgICAgICAgICAgIHNjYWxlZERlbHRhWTogZGVsdGFZIC8gYXBpLnN0YXRlLnRyYW5zZm9ybS5zY2FsZVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBoYW5kbGVQb2ludGVyRG93biA9IChlOiBQb2ludGVyRXZlbnQpID0+IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIYW5kbGUgZG91YmxlIHRhcFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlmICghZG91YmxlVGFwLmxhc3RUYXJnZXQpeyAvL1NldCBpbml0aWFsIHRpbWVvdXRcclxuICAgICAgICAgICAgZG91YmxlVGFwLmxhc3RUYXJnZXQgPSA8RWxlbWVudD4gZS50YXJnZXQ7XHJcbiAgICAgICAgICAgIGRvdWJsZVRhcC50aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4gZG91YmxlVGFwLmxhc3RUYXJnZXQgPSBudWxsLCBkb3VibGVUYXAudGhyZXNob2xkTXMpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZS50YXJnZXQgPT09IGRvdWJsZVRhcC5sYXN0VGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIGVtaXQoJ2RvdWJsZXRhcCcsIHsgc291cmNlOiBlIH0pIC8vVGFwIG9uIHNhbWUgdGFyZ2V0IGJlZm9yZSB0aW1lb3V0IGNsZWFyZWQsIGVtaXQgZXZlbnRcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGRvdWJsZVRhcC50aW1lb3V0ISk7IC8vV3JvbmcgdGFyZ2V0IG9yIHRpbWVvdXQgbnVsbGlmaWVkIG9yaWdpbmFsIHRhcmdldFxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIYW5kbGUgZHJhZyBzdGFydCwgYnV0IG5vdCBsYXRjaFxyXG4gICAgICAgICAqIFxyXG4gICAgICAgICAqIFRPRE86IE5lZWQgYSBjaGVjayBoZXJlIGZvciBhIFwidXNlciBjb250ZW50XCIgc29ydCBvZiBzZWN0aW9uIHdoZXJlIGRyYWdnaW5nIGRvZXNuJ3QgdGFrZSBwbGFjZSxcclxuICAgICAgICAgKiBzb21ldGhpbmcgbGlrZSAhKDxIVE1MRWxlbWVudD4gZS50YXJnZXQpLmhhc0F0dHJpYnV0ZShGbG93VHlwZXMuRmxvd0F0dHIuTm9kZUNvbnRlbnQpIGV4Y2VwdCBuZWVkcyB0byBcclxuICAgICAgICAgKiBhY2NvdW50IGZvciBjaGlsZCBlbGVtZW50cy5cclxuICAgICAgICAgKiBcclxuICAgICAgICAgKiBBbHNvLCBub3QgaGVyZSwgYnV0IHdlIG1heSB3YW50IHNvbWV0aGluZyBzaW1pbGFyIGZvciB0aGUgY29udGV4dCBtZW51IHNvIHRoYXQgdXNlcnMgY2FuIHNlbGVjdCB0ZXh0LCBldGMuXHJcbiAgICAgICAgICogXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaWYgKGUuaXNQcmltYXJ5KXtcclxuICAgICAgICAgICAgZHJhZy5zdGFydEV2ZW50ID0gZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgZW1pdCgnZG93bicsIHsgc291cmNlOiBlIH0pXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaGFuZGxlUG9pbnRlck1vdmUgPSAoZTogUG9pbnRlckV2ZW50KSA9PiB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSGFuZGxlIGRyYWdcclxuICAgICAgICAgKi9cclxuICAgICAgICBpZiAoZS5pc1ByaW1hcnkgJiYgZHJhZy5zdGFydEV2ZW50KXtcclxuICAgICAgICAgICAgaWYgKCFkcmFnLmxhdGNoZWQpe1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBFbWl0IGRyYWdzdGFydCBpZiB3ZSBoYXZlIGRyYWdnZWQgcGFzdCB0aGUgXCJsYXRjaFwiIHRocmVzaG9sZFxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBpZiAoZ2V0RHJhZ0xhdGNoZWQoZSkpe1xyXG4gICAgICAgICAgICAgICAgICAgIGVtaXQoJ2RyYWdzdGFydCcsIGdldERyYWdFdmVudChkcmFnLnN0YXJ0RXZlbnQsIGRyYWcuc3RhcnRFdmVudCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRyYWcuc3RhcnRFdmVudCA9IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgZHJhZy5sYXRjaGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogSWYgd2UndmUgYWxyZWFkeSBsYXRjaGVkLCBlbWl0IGRyYWcgZXZlbnRcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZW1pdCgnZHJhZycsIGdldERyYWdFdmVudChlKSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZW1pdCgnbW92ZScsIHsgc291cmNlOiBlIH0pXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaGFuZGxlUG9pbnRlclVwID0gKGU6IFBvaW50ZXJFdmVudCkgPT4ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuZCBvdXIgZHJhZyBldmVudCBpZiBhcHBsaWNhYmxlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaWYgKGRyYWcuc3RhcnRFdmVudCAmJiBlLmlzUHJpbWFyeSl7XHJcbiAgICAgICAgICAgIGlmIChkcmFnLmxhdGNoZWQpe1xyXG4gICAgICAgICAgICAgICAgZW1pdCgnZHJhZ2VuZCcsIGdldERyYWdFdmVudChlKSlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkcmFnLmxhdGNoZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgZHJhZy5zdGFydEV2ZW50ID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGVtaXQoJ3VwJywgeyBzb3VyY2U6IGUgfSlcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBoYW5kbGVEb3VibGVDbGljayA9IChlOiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgZW1pdCgnZG91YmxldGFwJywgeyBzb3VyY2U6IGUgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdXBkYXRlTW9kaWZpZXJzID0gKGU6IEtleWJvYXJkRXZlbnQpID0+IHtcclxuICAgICAgICBsZXQgY29kZSA9IGUua2V5LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgbGV0IHZhbCA9IG1vZGlmaWVycy5nZXQoY29kZSk7XHJcbiAgICAgICAgaWYgKHZhbCAhPT0gbnVsbCAmJiB2YWwgIT09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIG1vZGlmaWVycy5zZXQoY29kZSwgZS50eXBlID09PSAna2V5ZG93bicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBoYW5kbGVLZXlEb3duID0gKGU6IEtleWJvYXJkRXZlbnQpID0+IHtcclxuICAgICAgICB1cGRhdGVNb2RpZmllcnMoZSk7XHJcbiAgICAgICAgZW1pdCgna2V5ZG93bicsIHsgc291cmNlOiBlIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGhhbmRsZUtleVVwID0gKGU6IEtleWJvYXJkRXZlbnQpID0+IHtcclxuICAgICAgICB1cGRhdGVNb2RpZmllcnMoZSk7XHJcbiAgICAgICAgZW1pdCgna2V5dXAnLCB7IHNvdXJjZTogZSB9KTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBoYW5kbGVDb250ZXh0TWVudSA9IChlOiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgaWYgKG1ldGhvZHMuZXZlbnRJbkdyYXBoKGUpKXtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBlbWl0KCdjb250ZXh0bWVudScsIHsgXHJcbiAgICAgICAgICAgICAgICBzb3VyY2U6IGUsXHJcbiAgICAgICAgICAgICAgICBpdGVtOiBtZXRob2RzLnJlc29sdmVJdGVtKGUpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBoYW5kbGVXaGVlbCA9IChlOiBXaGVlbEV2ZW50KSA9PiB7XHJcbiAgICAgICAgaWYgKG1ldGhvZHMuZXZlbnRJbkdyYXBoKGUpKXtcclxuICAgICAgICAgICAgLy9lLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGVtaXQoJ3doZWVsJywgeyBcclxuICAgICAgICAgICAgICAgIHNvdXJjZTogZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBoYW5kbGVQb2ludGVyRG93bik7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIGhhbmRsZVBvaW50ZXJNb3ZlKTtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIGhhbmRsZVBvaW50ZXJVcCk7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlS2V5RG93bik7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGhhbmRsZUtleVVwKTtcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgaGFuZGxlRG91YmxlQ2xpY2spO1xyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBoYW5kbGVDb250ZXh0TWVudSk7XHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIGhhbmRsZVdoZWVsKTtcclxuICAgIHJldHVybiA8Y29uc3Q+IHtcclxuICAgICAgICBvbjxLIGV4dGVuZHMga2V5b2YgSW50ZXJhY3RUeXBlcy5JbnRlcmFjdEV2ZW50TWFwPih0eXBlOiBLLCBsaXN0ZW5lcjogKGV2ZW50OiBJbnRlcmFjdFR5cGVzLkludGVyYWN0RXZlbnRNYXBbS10pID0+IGFueSl7XHJcbiAgICAgICAgICAgIGV2ZW50cy5vbih0eXBlLCBsaXN0ZW5lcik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZW1vdmVMaXN0ZW5lcjxLIGV4dGVuZHMga2V5b2YgSW50ZXJhY3RUeXBlcy5JbnRlcmFjdEV2ZW50TWFwPih0eXBlOiBLLCBsaXN0ZW5lcjogTGlzdGVuZXIpe1xyXG4gICAgICAgICAgICBldmVudHMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGlzcG9zZSgpe1xyXG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIGhhbmRsZVBvaW50ZXJEb3duKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBoYW5kbGVQb2ludGVyVXApO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIGhhbmRsZVBvaW50ZXJNb3ZlKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZUtleURvd24pO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIGhhbmRsZUtleVVwKTtcclxuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBoYW5kbGVEb3VibGVDbGljayk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgaGFuZGxlQ29udGV4dE1lbnUpO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd3aGVlbCcsIGhhbmRsZVdoZWVsKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgbW9kaWZpZXIga2V5IGRlbm90ZWQgYnkgdGhlIGdpdmVuIG1vZGlmaWVyIGNvbnRyb2wgb3B0aW9uXHJcbiAgICAgICAgICogaXMgYWN0aXZlLiAoKVxyXG4gICAgICAgICAqIFxyXG4gICAgICAgICAqIEBwYXJhbSBtb2RDb25maWdPcHQgLSBUaGUgY29uZmlnIG9wdGlvbiAoYHBhbk1vZGlmaWVyYCwgYG11bHRpU2VsZWN0TW9kaWZpZXJgIGV0Yy4pO1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlzTW9kQWN0aXZlKG1vZENvbmZpZ09wdDoga2V5b2YgRmxvd1R5cGVzLkNvbnRyb2xPcHRpb25zKXtcclxuICAgICAgICAgICAgbGV0IGtleSA9IGFwaS5vcHRzLmNvbnRyb2xzW21vZENvbmZpZ09wdF07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kaWZpZXJzLmdldChrZXkudG9Mb3dlckNhc2UoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzTW9kS2V5QWN0aXZlKGtleTogc3RyaW5nKXtcclxuICAgICAgICAgICAgcmV0dXJuIG1vZGlmaWVycy5nZXQoa2V5LnRvTG93ZXJDYXNlKCkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmViYXNlRHJhZyhlOiBQb2ludGVyRXZlbnQpe1xyXG4gICAgICAgICAgICBkcmFnLnN0YXJ0RXZlbnQgPSBlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZHJhZ2dpbmcoKXtcclxuICAgICAgICAgICAgcmV0dXJuIGRyYWcubGF0Y2hlZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEludGVyYWN0aW9uRW1pdHRlcjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/interact.ts\n");

/***/ }),

/***/ "./src/methods.ts":
/*!************************!*\
  !*** ./src/methods.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getPublicInterface\": () => (/* binding */ getPublicInterface)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! types/flow.types.v2 */ \"./src/types/flow.types.v2.ts\");\n/* harmony import */ var _flow_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./flow-util */ \"./src/flow-util.ts\");\n\n\n\nconst AddNodeDefaultOpts = {\n  x: 0,\n  y: 0,\n  suppressEvent: false,\n  ignoreAction: false,\n  edges: []\n};\n\nconst getPublicInterface = api => {\n  //const opts = api.opts;\n  const dom = api.dom;\n  const state = api.state;\n  const transform = api.state.transform;\n  const emit = api.emit;\n\n  const getCompositeScale = () => {\n    if (api.opts.parent) {\n      return api.opts.parent.getCompositeScale() + api.state.transform.scale;\n    }\n\n    return api.state.transform.scale;\n  };\n\n  const getState = () => {\n    return api.state;\n  };\n\n  const recordAction = action => {\n    var _a, _b, _c;\n\n    if (!((_a = api.opts.undo) === null || _a === void 0 ? void 0 : _a.enabled)) return;\n\n    if ((_c = (_b = api.opts.undo) === null || _b === void 0 ? void 0 : _b.actions) === null || _c === void 0 ? void 0 : _c.includes(action)) {\n      state.undo.unshift({\n        type: action,\n        model: getModel()\n      });\n\n      if (state.undo.length > api.opts.undo.max) {\n        state.undo.pop();\n      }\n      /**\r\n       * Clear redo stack any time a new action was recorded\r\n       */\n\n\n      state.redo = [];\n    }\n  };\n\n  const undo = () => {\n    var _a;\n\n    if (!((_a = api.opts.undo) === null || _a === void 0 ? void 0 : _a.enabled)) return;\n\n    if (state.undo.length > 1) {\n      if (state.undo.length > 0) {\n        state.redo.unshift(state.undo.shift());\n      }\n\n      setModel(_flow_util__WEBPACK_IMPORTED_MODULE_1__.clone(state.undo[0].model));\n    }\n  };\n\n  const redo = () => {\n    var _a;\n\n    if (!((_a = api.opts.undo) === null || _a === void 0 ? void 0 : _a.enabled)) return;\n\n    if (state.redo.length > 0) {\n      if (state.redo.length > 0) {\n        state.undo.unshift(state.redo.shift());\n      }\n\n      setModel(_flow_util__WEBPACK_IMPORTED_MODULE_1__.clone(state.undo[0].model));\n    }\n  };\n\n  const isSelected = item => {\n    let key = typeof item === 'string' ? item : item.key;\n    return state.selected.has(key);\n  };\n\n  const setSelected = (selected, opts) => {\n    let s = Array.isArray(selected) ? new Map(selected.map(item => [item.key, item])) : selected;\n\n    if (state.selected.size !== 0 || s.size !== 0) {\n      _flow_util__WEBPACK_IMPORTED_MODULE_1__.removeItemClass(state.selected, types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.ItemSelected);\n      state.selected = s;\n      _flow_util__WEBPACK_IMPORTED_MODULE_1__.addItemClass(state.selected, types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.ItemSelected); //If we didn't just select everything, enforce layers\n\n      if (s.size !== 0 && state.selected.size < state.nodes.size) {\n        bringToTop(Array.from(selected.values()).filter(item => item.type === 'node'));\n      }\n    }\n\n    if (!(opts === null || opts === void 0 ? void 0 : opts.suppressEvent)) emit('selected', new Map(state.preselected));\n    if (!(opts === null || opts === void 0 ? void 0 : opts.ignoreAction)) recordAction('select');\n  };\n  /**\r\n   * Add one or more items to the current selection.\r\n   */\n\n\n  const addToSelection = (items, opts) => {\n    items.forEach(item => {\n      state.selected.set(item.key, item);\n      _flow_util__WEBPACK_IMPORTED_MODULE_1__.addItemClass(item, types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.ItemSelected);\n    });\n    bringToTop(Array.from(items.values()).filter(item => item.type === 'node'));\n    if (!(opts === null || opts === void 0 ? void 0 : opts.suppressEvent)) emit('selected', new Map(state.selected));\n    if (!(opts === null || opts === void 0 ? void 0 : opts.ignoreAction)) recordAction('select');\n  };\n  /**\r\n   * Remove one or more items from the current selection using item keys.\r\n   */\n\n\n  const removeFromSelection = (keys, opts) => {\n    keys.forEach(key => {\n      let selection = state.selected.get(key);\n\n      if (selection) {\n        _flow_util__WEBPACK_IMPORTED_MODULE_1__.removeItemClass(selection, types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.ItemSelected);\n        state.selected.delete(key);\n      }\n    });\n    if (!(opts === null || opts === void 0 ? void 0 : opts.suppressEvent)) emit('selected', new Map(state.selected));\n    if (!(opts === null || opts === void 0 ? void 0 : opts.ignoreAction)) recordAction('select');\n  };\n  /**\r\n   * Bring one or more nodes to the front.\r\n   *\r\n   * @param nodes - Array of Node items.\r\n   */\n\n\n  const bringToTop = nodes => {\n    let toTop = nodes.sort((a, b) => a.z > b.z ? 1 : -1); //Sort given nodes\n\n    let toTopSet = new Set(toTop);\n    let all = Array.from(state.nodes.values()).sort((a, b) => a.z > b.z ? 1 : -1); //Sort all nodes\n\n    /**\r\n     * Take any node NOT in the given node set and move all thier indexes down.\r\n     * For some nodes, the index may move down by more than 1.\r\n     */\n\n    let lastZ = api.opts.zIndexStart; //Our counter\n\n    all.forEach(node => {\n      if (!toTopSet.has(node)) {\n        node.z = lastZ;\n        node.el.style.zIndex = node.z.toString();\n        lastZ = lastZ + 1;\n      }\n    });\n    /**\r\n     * Relayer our given node set to the top of the list, but maintain the\r\n     * previous z-indexes within the list (this is already done by sorting)\r\n     */\n\n    let toTopBaseZ = lastZ + toTop.length;\n    toTop.forEach((node, i) => {\n      node.z = toTopBaseZ + i;\n      node.el.style.zIndex = node.z.toString();\n    }); //TODO:\n    //api.dom.lassoEl.style.zIndex = (toTop[toTop.length - 1].z + 1).toString();\n  };\n  /**\r\n   * Set which items are \"preselected\". Any existing \"preselect\" states will be removed.\r\n   *\r\n   * @param preselected - Array or map of items to preselect.\r\n   * @param opts\r\n   */\n\n\n  const setPreselected = (preselected, opts) => {\n    let s = Array.isArray(preselected) ? new Map(preselected.map(item => [item.key, item])) : preselected;\n\n    if (state.preselected.size !== 0 || s.size !== 0) {\n      _flow_util__WEBPACK_IMPORTED_MODULE_1__.removeItemClass(state.preselected, types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.ItemPreselected);\n      state.preselected = s;\n      _flow_util__WEBPACK_IMPORTED_MODULE_1__.addItemClass(state.preselected, types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.ItemPreselected);\n    }\n\n    if (!(opts === null || opts === void 0 ? void 0 : opts.suppressEvent)) emit('preselected', new Map(state.preselected));\n  };\n  /**\r\n   * Remove an item from the graph\r\n   *\r\n   * @param type - The item type, one of `node`, `link`, or `edge`\r\n   * @param key - The item key\r\n   * @param opts - Extended options\r\n   * @param opts.suppressEvent - When set to true, no event will be emitted for this action\r\n   * @param opts.ignoreAction - When set to true, no action will be added to the do/undo stack\r\n   * @returns\r\n   */\n\n\n  const removeItem = (type, key, opts) => {\n    let item = getItem(type, key);\n\n    if (item) {\n      switch (item.type) {\n        case 'node':\n          removeNode(item.key, opts);\n          return;\n\n        case 'link':\n          removeLink(item.key, opts);\n          return;\n\n        case 'edge':\n          removeEdge(item.key, opts);\n          return;\n      }\n    }\n  };\n  /**\r\n   * Remove currently selected items from the graph. If there are multiple selected items, and `ignoreAction=false`,\r\n   * then the operations will be batched into a single action.\r\n   *\r\n   * @param opts.suppressEvent - When set to true, no event will be emitted for this action\r\n   * @param opts.ignoreAction - When set to true, no action will be added to the do/undo stack\r\n   */\n\n\n  1;\n\n  const removeSelectedItems = opts => {\n    /**\r\n     * If the selection size is greater than one, we want to ignore the individual remove\r\n     * actions and record the batch action once each operation is complete.\r\n     */\n    let ignoreSingleActions = state.selected.size > 1;\n    state.selected.forEach(item => {\n      removeItem(item.type, item.key, {\n        suppressEvent: opts === null || opts === void 0 ? void 0 : opts.suppressEvent,\n        ignoreAction: (opts === null || opts === void 0 ? void 0 : opts.ignoreAction) || ignoreSingleActions //We will use batch \"removeItems\" if more than one item is being removed\n\n      });\n    }); //Record our batch action only if more than one item was removed\n\n    if (!(opts === null || opts === void 0 ? void 0 : opts.ignoreAction) && ignoreSingleActions) {\n      recordAction('removeItems');\n    }\n  };\n  /**\r\n   * Retrieve an existing item by `type` and `key`.\r\n   *\r\n   * @param type - The item type, one of `graph`, `node`, `edge`, or `link`.\r\n   * @param key - The item key\r\n   * @returns {FlowTypes.FlowItem}\r\n   */\n\n\n  const getItem = (type, key) => {\n    let item;\n\n    if (type === 'graph') {\n      return state.root;\n    } else if (key && type === 'node') {\n      item = state.nodes.get(key);\n    } else if (key && type === 'edge') {\n      item = state.edges.get(key);\n    } else if (key && type === 'link') {\n      item = state.links.get(key);\n    }\n\n    return item;\n  };\n  /**\r\n   * Checks whether the given event target (if there is one) is within this graph.\r\n   *\r\n   * @param e - The event in question\r\n   * @returns\r\n   */\n\n\n  const eventInGraph = e => {\n    var _a, _b, _c;\n\n    return ((_c = (_b = (_a = e.target) === null || _a === void 0 ? void 0 : _a.closest) === null || _b === void 0 ? void 0 : _b.call(_a, `.${types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.Container}`)) === null || _c === void 0 ? void 0 : _c.id) === dom.instanceId;\n  };\n  /**\r\n   * Given an event, resolves an item within the graph or returns `undefined` if no item was targeted.\r\n   *\r\n   * @param e - The event in question, either `PointerEvent` or `MouseEvent`\r\n   * @returns {FlowTypes.FlowItem | undefined}\r\n   */\n\n\n  const resolveItem = e => {\n    if (!eventInGraph(e)) return;\n    let item;\n    let target = document.elementFromPoint(e.clientX, e.clientY);\n\n    if (target\n    /*e.target && e.target instanceof Element */\n    ) {\n      let closestItem = target.closest(`[${types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowAttr.Type}]`);\n\n      if (closestItem) {\n        closestItem.getAttribute;\n        item = getItem(closestItem.getAttribute(types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowAttr.Type), closestItem.getAttribute(types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowAttr.Key));\n      }\n    }\n\n    return item;\n  };\n\n  const addEdge = (group, nodeKey, edgeKey, opts) => {\n    let key = `${nodeKey}:${edgeKey}`;\n\n    if (!state.edges.has(key)) {\n      let node = state.nodes.get(nodeKey);\n\n      if (node) {\n        let edge = _flow_util__WEBPACK_IMPORTED_MODULE_1__.createEdge(node, group, edgeKey, opts === null || opts === void 0 ? void 0 : opts.class);\n        edge.data = (opts === null || opts === void 0 ? void 0 : opts.data) || {};\n        state.edges.set(key, edge); //if (content) setEdgeContent(nodeKey, edgeKey, content);\n\n        render(edge); //Append edge to node\n\n        edge.group.groupEl.appendChild(edge.el); // let targetList = type === 'input' ? node.inputsEl : node.outputsEl;\n        //     targetList.appendChild(edge.el);\n\n        if (!(opts === null || opts === void 0 ? void 0 : opts.suppressEvent)) emit('edgeAdded', edge);\n        if (!(opts === null || opts === void 0 ? void 0 : opts.ignoreAction)) recordAction('addEdge');\n        return edge;\n      }\n\n      throw new Error(`MXFlow: Attempted to add edge to node which doesn't exist (key=\"${key}\")`);\n    }\n\n    throw new Error(`MXFlow: Attempted to add edge with a key that already exists (key=\"${key}\")`);\n  };\n\n  const removeEdge = (key, opts) => {\n    let edge = state.edges.get(key);\n\n    if (edge) {\n      if (api.opts.beforeEdgeRemoved && !api.opts.beforeEdgeRemoved(edge)) return; //Remove any links associated with this edge and batch this action in w/ the edge removal\n\n      state.links.forEach(link => {\n        if (link.fromNode === (edge === null || edge === void 0 ? void 0 : edge.nodeKey) && link.fromEdge === (edge === null || edge === void 0 ? void 0 : edge.edgeKey) || link.toNode === (edge === null || edge === void 0 ? void 0 : edge.nodeKey) && link.toEdge === (edge === null || edge === void 0 ? void 0 : edge.edgeKey)) {\n          removeLink(link.key, {\n            suppressEvent: opts === null || opts === void 0 ? void 0 : opts.suppressEvent,\n            ignoreAction: true\n          });\n        }\n      });\n      edge.el.remove();\n      state.edges.delete(key);\n      _flow_util__WEBPACK_IMPORTED_MODULE_1__.applyAllLinkPositions(api);\n      if (!(opts === null || opts === void 0 ? void 0 : opts.suppressEvent)) emit('edgeRemoved', edge);\n      if (!(opts === null || opts === void 0 ? void 0 : opts.ignoreAction)) recordAction('removeEdge');\n      return;\n    }\n\n    throw new Error(`MXFlow: No edge exists with key=\"${key}\"`);\n  }; // const setNodeContent = (nodeKey: string, content: HTMLElement | string) => {\n  //     let node = state.nodes.get(nodeKey);\n  //     if (node){\n  //         if (content instanceof HTMLElement){\n  //             node.contentEl.innerHTML = ''\n  //             node.contentEl.appendChild(content);\n  //         } else {\n  //             node.contentEl.innerHTML = ''\n  //             node.contentEl.insertAdjacentHTML('afterbegin', content);\n  //         }\n  //     }\n  //     throw new Error(`MXFlow: Attempted to set node content on node which doesn't exist (key=\"${nodeKey}\")`);\n  // }\n\n\n  const addNode = function (nodeKey) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var _a, _b, _c;\n\n    let opts = Object.assign(Object.assign({}, AddNodeDefaultOpts), options);\n\n    if (!state.nodes.has(nodeKey)) {\n      let node = _flow_util__WEBPACK_IMPORTED_MODULE_1__.createNode({\n        template: api.opts.nodeHTMLTemplate,\n        key: nodeKey,\n        x: (_a = opts.x) !== null && _a !== void 0 ? _a : 0,\n        y: (_b = opts.y) !== null && _b !== void 0 ? _b : 0,\n        z: state.nodes.size + 1,\n        width: opts.width,\n        height: opts.height,\n        nodeClass: opts.class,\n        data: opts.data\n      });\n      state.nodes.set(nodeKey, node); //Create edges\n\n      (_c = options.edges) === null || _c === void 0 ? void 0 : _c.forEach(config => {\n        addEdge(config.group, nodeKey, config.key, {\n          data: config.data,\n          class: config.class,\n          suppressEvent: true,\n          ignoreAction: true\n        });\n      });\n      render(node); //Add node and bind position\n\n      dom.nodeContainerEl.appendChild(node.el);\n      _flow_util__WEBPACK_IMPORTED_MODULE_1__.applyNodePosition(node); //Emit event and record action of configured\n\n      if (!(opts === null || opts === void 0 ? void 0 : opts.suppressEvent)) emit('nodeAdded', node);\n      if (!(opts === null || opts === void 0 ? void 0 : opts.ignoreAction)) recordAction('addNode');\n      return;\n    }\n\n    throw new Error(`MXFlow: Attempted to add a node with a key that already exists (key=\"${nodeKey}\")`);\n  }; // const updateNodeTemplate = (node: string | FlowTypes.Node, htmlTemplate: string) => {\n  //     if (typeof node === 'string'){\n  //         node = <FlowTypes.Node> getItem('node', node);\n  //         if (!node){\n  //             throw new Error(`updateNodeTemplate(): No node exists with key=\"${node}\"`);\n  //         }\n  //     }\n  //     FlowUtil.updateNodeTemplate(api, node, htmlTemplate);\n  //     render(node); //Render node\n  //     state.edges.forEach(edge => { //Render any node edges\n  //         if (edge.nodeKey === (<FlowTypes.Node> node).key){\n  //             render(edge);\n  //         }\n  //     })\n  // }\n\n\n  const removeNode = (key, opts) => {\n    let node = state.nodes.get(key);\n\n    if (node) {\n      if (api.opts.beforeNodeRemoved && !api.opts.beforeNodeRemoved(node)) return; //Clear from selection\n\n      if (state.selected.has(key)) {\n        removeFromSelection([key], {\n          suppressEvent: true,\n          ignoreAction: true\n        });\n      } //clear links\n\n\n      state.links.forEach(link => {\n        if (link.fromNode === (node === null || node === void 0 ? void 0 : node.key) || link.toNode === (node === null || node === void 0 ? void 0 : node.key)) {\n          link.el.remove();\n          state.links.delete(link.key);\n        }\n      }); //clear edges\n\n      state.edges.forEach(edge => {\n        if (edge.nodeKey === (node === null || node === void 0 ? void 0 : node.key)) {\n          edge.el.remove();\n          state.edges.delete(edge.key);\n        }\n      }); //this.emit('beforeNodeRemoved', node);\n\n      node.el.remove();\n      state.nodes.delete(key);\n\n      if (!(opts === null || opts === void 0 ? void 0 : opts.suppressEvent)) {\n        emit('nodeRemoved', node);\n      } //Add action to undo stack if configured            \n\n\n      if (!(opts === null || opts === void 0 ? void 0 : opts.ignoreAction)) {\n        recordAction('removeNode');\n      }\n\n      return;\n    }\n\n    throw new Error(`MXFlow: No node exists with key=\"${key}\"`);\n  };\n\n  const addLink = (fromNode, fromEdge, toNode, toEdge, opts) => {\n    let params = {\n      fromNode,\n      fromEdge,\n      toNode,\n      toEdge\n    };\n    let from = state.edges.get(`${fromNode}:${fromEdge}`);\n    let to = state.edges.get(`${toNode}:${toEdge}`);\n\n    if (!from || !to) {\n      throw new Error(`MXFlow.addLink(): One or both edges missing \"${fromEdge}\", \"${toEdge}\"`);\n    } //Swap direction if provided backwards\n    // if (from.type === 'input'){\n    //     throw new Error(`MXflow.addLink(): The \"from\" edge must be of type 'output'.`);\n    // }\n\n\n    if (!isLinkValid(from, to)) {\n      throw new Error(`MXFlow.addLink(): Invalid link.`);\n    }\n\n    let key = _flow_util__WEBPACK_IMPORTED_MODULE_1__.getLinkCompositeKey(params);\n\n    if (!state.links.has(key)) {\n      let link = _flow_util__WEBPACK_IMPORTED_MODULE_1__.createLink(params, opts === null || opts === void 0 ? void 0 : opts.class);\n      link.data = (opts === null || opts === void 0 ? void 0 : opts.data) || {};\n      state.links.set(key, link);\n      dom.linkContainerEl.appendChild(link.el);\n      _flow_util__WEBPACK_IMPORTED_MODULE_1__.applyLinkPosition(api, link);\n\n      if (!(opts === null || opts === void 0 ? void 0 : opts.suppressEvent)) {\n        emit('linkAdded', link);\n      } //Add action to undo stack if configured            \n\n\n      if (!(opts === null || opts === void 0 ? void 0 : opts.ignoreAction)) {\n        recordAction('addLink');\n      }\n\n      return;\n    }\n\n    throw new Error(`MXFlow: Attempted to add link which already exists (key=\"${key}\")`);\n  };\n\n  const removeLink = (key, opts) => {\n    //let key = FlowUtil.getLinkCompositeKey({ fromNode, fromEdge, toNode, toEdge });\n    let link = state.links.get(key);\n\n    if (link) {\n      if (api.opts.beforeLinkRemoved && !api.opts.beforeLinkRemoved(link)) return;\n\n      if (state.selected.has(key)) {\n        removeFromSelection([key], {\n          suppressEvent: true,\n          ignoreAction: true\n        });\n      }\n\n      link.el.remove();\n      state.links.delete(key);\n\n      if (!(opts === null || opts === void 0 ? void 0 : opts.suppressEvent)) {\n        emit('linkRemoved', link);\n      } //Add action to undo stack if configured            \n\n\n      if (!(opts === null || opts === void 0 ? void 0 : opts.ignoreAction)) {\n        recordAction('removeLink');\n      }\n\n      return;\n    }\n  };\n\n  const isLinkValid = (fromEdge, toEdge) => {\n    if (fromEdge && toEdge) {\n      if (fromEdge.nodeKey === toEdge.nodeKey) return false; //Check if edges are on same node\n\n      if (fromEdge.group.groupKey === toEdge.group.groupKey) return false; //Check if type matches\n\n      if (state.links.has(`${fromEdge.nodeKey}:${fromEdge.edgeKey}:${toEdge.nodeKey}:${toEdge.edgeKey}`)) return false; //Check if link already exists\n\n      if (state.links.has(`${toEdge.nodeKey}:${toEdge.edgeKey}:${fromEdge.nodeKey}:${fromEdge.edgeKey}`)) return false;\n      if (api.opts.linkValidator && !api.opts.linkValidator(fromEdge, toEdge)) return false; //User validation\n\n      return true;\n    }\n\n    return false;\n  };\n\n  const openContextMenu = (graphX, graphY, target, opts) => {\n    renderContext(target, graphX, graphY); // dom.contextEl.style.left = `${graphX}px`;\n    // dom.contextEl.style.top = `${graphY}px`;\n    // dom.contextEl.style.display = 'block';\n\n    state.contextOpen = true;\n\n    if (!(opts === null || opts === void 0 ? void 0 : opts.suppressEvent)) {\n      emit('contextOpened', target);\n    }\n  };\n\n  const closeContextMenu = opts => {\n    dom.contextEl.style.display = 'none';\n    state.contextOpen = false;\n\n    if (!(opts === null || opts === void 0 ? void 0 : opts.suppressEvent)) {\n      emit('contextClosed');\n    }\n  };\n\n  const clear = opts => {\n    state.preselected.clear();\n    state.selected.clear();\n    state.nodes.clear();\n    state.edges.clear();\n    state.links.clear();\n    dom.linkContainerEl.innerHTML = '';\n    dom.nodeContainerEl.innerHTML = '';\n    if (!(opts === null || opts === void 0 ? void 0 : opts.suppressEvent)) emit('cleared');\n    if (!(opts === null || opts === void 0 ? void 0 : opts.ignoreAction)) recordAction('clear');\n  };\n  /**\r\n   * Retrieves the current model which can be used to reset to a previous state\r\n   * using setModel()\r\n   */\n\n\n  const getModel = () => {\n    let model = {\n      transform: state.transform,\n      nodes: {},\n      links: {},\n      edges: {}\n    };\n    state.nodes.forEach(node => {\n      model.nodes[node.key] = {\n        selected: state.selected.has(node.key),\n        x: node.x,\n        y: node.y,\n        width: node.width,\n        height: node.height,\n        class: node.class,\n        data: node.data\n      };\n    });\n    state.edges.forEach(edge => {\n      model.edges[edge.key] = {\n        nodeKey: edge.nodeKey,\n        edgeKey: edge.edgeKey,\n        groupKey: edge.group.groupKey,\n        data: edge.data,\n        class: edge.class\n      };\n    });\n    state.links.forEach(link => {\n      model.links[link.key] = {\n        selected: state.selected.has(link.key),\n        fromNode: link.fromNode,\n        fromEdge: link.fromEdge,\n        toNode: link.toNode,\n        toEdge: link.toEdge,\n        data: link.data\n      };\n    });\n    return model;\n  };\n  /**\r\n   * Build graph from a previous model. Optionally provide a hook which returns HTML content for\r\n   * any items with a content section. This method is asynchronous because of the way clientBoundingRect()\r\n   * is calculated (not synchronously)\r\n   */\n\n\n  const setModel = model => (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(void 0, void 0, void 0, function* () {\n    clear({\n      suppressEvent: true,\n      ignoreAction: true\n    }); //TODO: Set transform???\n\n    Object.entries(model.nodes).forEach(entry => {\n      addNode(entry[0], {\n        x: entry[1].x,\n        y: entry[1].y,\n        width: entry[1].width,\n        height: entry[1].height,\n        class: entry[1].class,\n        suppressEvent: false,\n        ignoreAction: true\n      });\n\n      if (entry[1].selected) {\n        addToSelection([state.nodes.get(entry[0])], {\n          ignoreAction: true\n        });\n      }\n    });\n    Object.entries(model.edges).forEach(entry => {\n      addEdge(entry[1].groupKey, entry[1].nodeKey, entry[1].edgeKey, {\n        ignoreAction: true,\n        data: entry[1].data,\n        class: entry[1].class\n      });\n    });\n    return new Promise(resolve => {\n      requestAnimationFrame(() => {\n        Object.entries(model.links).forEach(entry => {\n          addLink(entry[1].fromNode, entry[1].fromEdge, entry[1].toNode, entry[1].toEdge, {\n            ignoreAction: true\n          });\n\n          if (entry[1].selected) {\n            addToSelection([state.links.get(entry[0])], {\n              ignoreAction: true\n            });\n          }\n        }); //emit('modelChange', model);\n\n        resolve(null);\n      });\n    });\n  });\n  /**\r\n   * Call render on all existing renderable items.\r\n   *\r\n   * @param data - Optional data object w/ any properties to expose to your render function.\r\n   */\n\n\n  const renderAll = function () {\n    let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let items = Array.from(state.nodes.values());\n    items.concat(Array.from(state.edges.values()));\n    items.forEach(item => render(item, data));\n  };\n  /**\r\n   * Call render for a particular item.\r\n   *\r\n   * @param item - A renderable item. Current renderable items are items of type 'node' or 'edge'.\r\n   * @param data - Optional data object w/ any properties to expose to your render function.\r\n   * @returns\r\n   */\n\n\n  const render = function (item) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (api.opts.render) {\n      let cachedContent = api.renderCache.get(item.key); //Get any cached content for the item w/ the given key\n\n      let renderTarget = null,\n          nextContent = api.opts.render(item, cachedContent, data);\n\n      if (item.type === types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowItemType.Node) {\n        renderTarget = item.contentEl;\n        /*\r\n         * Target is an edge, input or output\r\n         */\n      } else if (item.type === types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowItemType.Edge) {\n        renderTarget = item.el;\n      }\n      /**\r\n       * If new content was returned, empty the target element, insert and cache the new content\r\n       */\n\n\n      if (!renderTarget) return;\n\n      if (nextContent) {\n        renderTarget.innerHTML = '';\n\n        if (typeof nextContent === 'string') {\n          renderTarget.insertAdjacentHTML('afterbegin', nextContent);\n        } else {\n          renderTarget.appendChild(nextContent);\n        }\n        /**\r\n         * Cache the HTML content\r\n         */\n\n\n        api.renderCache.set(item.key, renderTarget.firstElementChild);\n      }\n    }\n  };\n  /**\r\n   *\r\n   * @param item\r\n   */\n\n\n  const renderContext = (item, graphX, graphY) => {\n    var _a, _b;\n\n    let renderTarget = dom.contextEl;\n    let nextContent = (_b = (_a = api.opts).renderContext) === null || _b === void 0 ? void 0 : _b.call(_a, item, graphX, graphY);\n\n    if (nextContent) {\n      renderTarget.innerHTML = '';\n\n      if (typeof nextContent === 'string') {\n        renderTarget.insertAdjacentHTML('afterbegin', nextContent);\n      } else {\n        renderTarget.appendChild(nextContent);\n      }\n    }\n\n    dom.contextEl.style.left = `${graphX}px`;\n    dom.contextEl.style.top = `${graphY}px`;\n    dom.contextEl.style.display = 'block';\n  };\n\n  const applyTransform = function () {\n    let transition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    if (typeof transition === 'number' || transition === true) {\n      dom.rootEl.style.transition = `transform ${typeof transition === 'number' ? transition : 300}ms`;\n    }\n\n    dom.rootEl.style.transform = `translate(${transform.x}px, ${transform.y}px) scale(${transform.scale})`;\n  };\n  /**\r\n   * Resolves a set of page coordinates to a position within the graph container.\r\n   *\r\n   * @param graphX\r\n   * @param graphY\r\n   * @returns\r\n   */\n\n\n  const pageToContainerPos = (graphX, graphY) => {\n    let x = graphX - dom.containerEl.offsetLeft;\n    let y = graphY - dom.containerEl.offsetTop;\n    return [x, y];\n  };\n  /**\r\n    * Resolves a set of page coordinates to a position within the graph.\r\n    *\r\n    * @param pageX - The page x position\r\n    * @param pageY - The page y position\r\n    */\n\n\n  const pageToGraphPos = (pageX, pageY) => {\n    let x = (Math.abs(transform.x) + (pageX - dom.containerEl.offsetLeft)) / transform.scale;\n    let y = (Math.abs(transform.y) + (pageY - dom.containerEl.offsetTop)) / transform.scale;\n    return [x, y];\n  };\n  /**\r\n   * Translate or zoom to any coordinates within the graph.\r\n   *\r\n   * @param {Object} opts - Options object\r\n   * @param {number} opts.x - New x coordinate\r\n   * @param {number} opts.y - New y coordinate\r\n   * @param {number} opts.scale - Provide a new scale between the configured min/max. Must be a positive number. Overrides the `scaleSteps` option.\r\n   * @param {number} opts.scaleStep - Alternative zoom method. Provide the number of steps (positive or negative) to zoom. The\r\n   * size of the step is determined by the `panzoom.scaleStep` configuration property.\r\n   * @param {number | boolean} opts.transition - Pass `false` to use no smooth transition, `true` to use the default transition `300ms`, or a custom\r\n   * transition time in milliseconds.\r\n   * @returns\r\n   */\n\n\n  const setView = opts => {\n    var _a, _b, _c, _d, _e, _f;\n\n    if (api.isLocked()) return; //Ignore setView if our control is locked\n\n    let rootRect = dom.rootEl.getBoundingClientRect();\n    let scale = transform.scale;\n    let minScale = ((_a = api.opts.panzoom) === null || _a === void 0 ? void 0 : _a.minScale) || .05;\n    let maxScale = ((_b = api.opts.panzoom) === null || _b === void 0 ? void 0 : _b.maxScale) || 2;\n    let stepIncrement = ((_c = api.opts.panzoom) === null || _c === void 0 ? void 0 : _c.scaleStep) || .25;\n    let scalePageX = (_d = opts.x) !== null && _d !== void 0 ? _d : transform.x; //Get param coordinates or use current transform values\n\n    let scalePageY = (_e = opts.y) !== null && _e !== void 0 ? _e : transform.y;\n    /**\r\n     * Get our next scale either by the given explicit scale or by scale step.\r\n     * If both are provided, the explicit scale is used.\r\n     */\n\n    let nextScale = transform.scale;\n\n    if (opts.scale) {\n      nextScale = opts.scale;\n    } else if (opts.scaleSteps) {\n      nextScale = parseFloat((scale + opts.scaleSteps * stepIncrement).toFixed(2));\n    } //if (nextScale < minScale || nextScale > maxScale) return;\n\n\n    if (nextScale < minScale || nextScale > maxScale) nextScale = transform.scale;\n    /**\r\n     * Get x and y accounting for new scale\r\n     */\n\n    let nextX = -scalePageX * nextScale; //Apply new scale to coordinates\n\n    let nextY = -scalePageY * nextScale;\n    /**\r\n     * Use our next scale to calculate what the max x (left) and y (top) position will be.\r\n     */\n\n    let containerRect = dom.containerEl.getBoundingClientRect();\n    let maxX = rootRect.width - containerRect.width;\n    let maxY = rootRect.height - containerRect.height;\n    /**\r\n     * Enforce max x/y positions.\r\n     */\n\n    if (nextX > 0) nextX = 0;\n    if (nextY > 0) nextY = 0;\n    if (nextX < -maxX) nextX = -maxX;\n    if (nextY < -maxY) nextY = -maxY;\n    /**\r\n     * Update our values and apply\r\n     */\n\n    api.state.transform.scale = nextScale;\n    api.state.transform.x = nextX;\n    api.state.transform.y = nextY;\n    applyTransform((_f = opts.transition) !== null && _f !== void 0 ? _f : true);\n    if (!opts.suppressEvent) emit('transform', Object.assign({}, transform)); // if (!opts.ignoreAction) recordAction('zoom');\n    //TODO: transform action here?\n  };\n  /**\r\n   * Moves the viewport x/y to focus on a particular node.\r\n   *\r\n   * @param node - The Node item to focus\r\n   * @param scale - Optionally set the new scale\r\n   */\n\n\n  const focusNode = (node, scale) => {\n    let containerRect = dom.containerEl.getBoundingClientRect();\n    let nodeRect = node.el.getBoundingClientRect();\n    let x1 = node.x;\n    let y1 = node.y;\n    let w1 = nodeRect.width / transform.scale;\n    let h1 = nodeRect.height / transform.scale;\n    let w2 = containerRect.width / transform.scale;\n    let h2 = containerRect.height / transform.scale;\n    let x2 = x1 + (w1 - w2) / 2;\n    let y2 = y1 + (h1 - h2) / 2;\n    setView({\n      x: x2,\n      y: y2,\n      scale: scale !== null && scale !== void 0 ? scale : transform.scale\n    });\n  };\n\n  const getDom = () => api.dom;\n\n  const getNodes = () => new Map(state.nodes);\n\n  const getEdges = () => new Map(state.edges);\n\n  const getLinks = () => new Map(state.links);\n  /**\r\n   * Set the background. Use the background helper to generate an SVG `grid` or `dots` background.\r\n   *\r\n   * @param html - The html for the background\r\n   */\n\n\n  const setBackground = html => {\n    dom.bgEl.innerHTML = html;\n  };\n\n  return {\n    recordAction,\n    undo,\n    redo,\n    addEdge,\n    removeEdge,\n    addNode,\n    removeNode,\n    //updateNodeTemplate,\n    addLink,\n    removeLink,\n    isLinkValid,\n    isSelected,\n    setSelected,\n    setPreselected,\n    addToSelection,\n    removeFromSelection,\n    removeItem,\n    removeSelectedItems,\n    openContextMenu,\n    closeContextMenu,\n    getItem,\n    resolveItem,\n    clear,\n    getModel,\n    setModel,\n    getDom,\n    getState,\n    getNodes,\n    getEdges,\n    getLinks,\n    eventInGraph,\n    pageToContainerPos,\n    pageToGraphPos,\n    setView,\n    focusNode,\n    render,\n    renderAll,\n    getCompositeScale,\n    setBackground\n  };\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RztBQVVILGNBVkc7QUFXSCxlQVhHO0FBWUgsY0FaRztBQWFILGVBYkc7QUFjSCxrQkFkRztBQWVILGtCQWZHO0FBZ0JILHVCQWhCRztBQWlCSCxjQWpCRztBQWtCSCx1QkFsQkc7QUFtQkgsbUJBbkJHO0FBb0JILG9CQXBCRztBQXFCSCxXQXJCRztBQXNCSCxlQXRCRztBQXVCSCxTQXZCRztBQXdCSCxZQXhCRztBQXlCSCxZQXpCRztBQTBCSCxVQTFCRztBQTJCSCxZQTNCRztBQTRCSCxZQTVCRztBQTZCSCxZQTdCRztBQThCSCxZQTlCRztBQStCSCxnQkEvQkc7QUFnQ0gsc0JBaENHO0FBaUNILGtCQWpDRztBQWtDSCxXQWxDRztBQW1DSCxhQW5DRztBQW9DSCxVQXBDRztBQXFDSCxhQXJDRztBQXNDSCxxQkF0Q0c7QUF1Q0g7QUF2Q0csR0FBUDtBQXlDSCxDQTM0QkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teGZsb3cvLi9zcmMvbWV0aG9kcy50cz8xZTNkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEZsb3dUeXBlcyBmcm9tICd0eXBlcy9mbG93LnR5cGVzLnYyJztcclxuaW1wb3J0ICogYXMgRmxvd1V0aWwgZnJvbSAnLi9mbG93LXV0aWwnO1xyXG5cclxuY29uc3QgQWRkTm9kZURlZmF1bHRPcHRzIDogRmxvd1R5cGVzLkFkZE5vZGVPcHRpb25zID0ge1xyXG4gICAgeDogMCxcclxuICAgIHk6IDAsXHJcbiAgICBzdXBwcmVzc0V2ZW50OiBmYWxzZSxcclxuICAgIGlnbm9yZUFjdGlvbjogZmFsc2UsXHJcbiAgICBlZGdlczogW11cclxufVxyXG5cclxudHlwZSBGbG93TWV0aG9kcyA9IFJldHVyblR5cGU8dHlwZW9mIGdldFB1YmxpY0ludGVyZmFjZT47XHJcbmNvbnN0IGdldFB1YmxpY0ludGVyZmFjZSA9IChhcGk6IEZsb3dUeXBlcy5BcGkpID0+IHtcclxuICAgIC8vY29uc3Qgb3B0cyA9IGFwaS5vcHRzO1xyXG4gICAgY29uc3QgZG9tID0gYXBpLmRvbTtcclxuICAgIGNvbnN0IHN0YXRlID0gYXBpLnN0YXRlO1xyXG4gICAgY29uc3QgdHJhbnNmb3JtID0gYXBpLnN0YXRlLnRyYW5zZm9ybTtcclxuICAgIGNvbnN0IGVtaXQgPSBhcGkuZW1pdDtcclxuXHJcbiAgICBjb25zdCBnZXRDb21wb3NpdGVTY2FsZSA9ICgpIDogbnVtYmVyID0+IHtcclxuICAgICAgICBpZiAoYXBpLm9wdHMucGFyZW50KXtcclxuICAgICAgICAgICAgcmV0dXJuIGFwaS5vcHRzLnBhcmVudC5nZXRDb21wb3NpdGVTY2FsZSgpICsgYXBpLnN0YXRlLnRyYW5zZm9ybS5zY2FsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFwaS5zdGF0ZS50cmFuc2Zvcm0uc2NhbGU7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZ2V0U3RhdGUgPSAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGFwaS5zdGF0ZTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByZWNvcmRBY3Rpb24gPSAoYWN0aW9uOiBGbG93VHlwZXMuQWN0aW9uVHlwZSkgPT4ge1xyXG4gICAgICAgIGlmICghYXBpLm9wdHMudW5kbz8uZW5hYmxlZCkgcmV0dXJuO1xyXG4gICAgICAgIGlmIChhcGkub3B0cy51bmRvPy5hY3Rpb25zPy5pbmNsdWRlcyhhY3Rpb24pKXtcclxuICAgICAgICAgICAgc3RhdGUudW5kby51bnNoaWZ0KHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IGFjdGlvbixcclxuICAgICAgICAgICAgICAgIG1vZGVsOiBnZXRNb2RlbCgpXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKHN0YXRlLnVuZG8ubGVuZ3RoID4gYXBpLm9wdHMudW5kby5tYXgpe1xyXG4gICAgICAgICAgICAgICAgc3RhdGUudW5kby5wb3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2xlYXIgcmVkbyBzdGFjayBhbnkgdGltZSBhIG5ldyBhY3Rpb24gd2FzIHJlY29yZGVkXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBzdGF0ZS5yZWRvID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHVuZG8gPSAoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFhcGkub3B0cy51bmRvPy5lbmFibGVkKSByZXR1cm47XHJcbiAgICAgICAgaWYgKHN0YXRlLnVuZG8ubGVuZ3RoID4gMSl7XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZS51bmRvLmxlbmd0aCA+IDApe1xyXG4gICAgICAgICAgICAgICAgc3RhdGUucmVkby51bnNoaWZ0KHN0YXRlLnVuZG8uc2hpZnQoKSEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNldE1vZGVsKEZsb3dVdGlsLmNsb25lKHN0YXRlLnVuZG9bMF0hLm1vZGVsKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJlZG8gPSAoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFhcGkub3B0cy51bmRvPy5lbmFibGVkKSByZXR1cm47XHJcbiAgICAgICAgaWYgKHN0YXRlLnJlZG8ubGVuZ3RoID4gMCl7XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZS5yZWRvLmxlbmd0aCA+IDApe1xyXG4gICAgICAgICAgICAgICAgc3RhdGUudW5kby51bnNoaWZ0KHN0YXRlLnJlZG8uc2hpZnQoKSEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNldE1vZGVsKEZsb3dVdGlsLmNsb25lKHN0YXRlLnVuZG9bMF0hLm1vZGVsKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSAoaXRlbTogRmxvd1R5cGVzLlNlbGVjdGFibGVJdGVtIHwgc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgbGV0IGtleSA9IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJyA/IGl0ZW0gOiBpdGVtLmtleTtcclxuICAgICAgICByZXR1cm4gc3RhdGUuc2VsZWN0ZWQuaGFzKGtleSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc2V0U2VsZWN0ZWQgPSAoc2VsZWN0ZWQ6IEZsb3dUeXBlcy5TZWxlY3RhYmxlSXRlbVtdIHwgTWFwPHN0cmluZywgRmxvd1R5cGVzLlNlbGVjdGFibGVJdGVtPiwgb3B0cz86IEZsb3dUeXBlcy5BY3Rpb25FeHRlbmRlZE9wdHMpID0+IHtcclxuICAgICAgICBsZXQgcyA9IEFycmF5LmlzQXJyYXkoc2VsZWN0ZWQpID8gbmV3IE1hcChzZWxlY3RlZC5tYXAoaXRlbSA9PiBbaXRlbS5rZXksIGl0ZW1dKSkgOiBzZWxlY3RlZDtcclxuICAgICAgICBpZiAoc3RhdGUuc2VsZWN0ZWQuc2l6ZSAhPT0gMCB8fCBzLnNpemUgIT09IDApIHtcclxuICAgICAgICAgICAgRmxvd1V0aWwucmVtb3ZlSXRlbUNsYXNzKHN0YXRlLnNlbGVjdGVkLCBGbG93VHlwZXMuRmxvd0NsYXNzLkl0ZW1TZWxlY3RlZCk7XHJcbiAgICAgICAgICAgIHN0YXRlLnNlbGVjdGVkID0gcztcclxuICAgICAgICAgICAgRmxvd1V0aWwuYWRkSXRlbUNsYXNzKHN0YXRlLnNlbGVjdGVkLCBGbG93VHlwZXMuRmxvd0NsYXNzLkl0ZW1TZWxlY3RlZCk7XHJcblxyXG4gICAgICAgICAgICAvL0lmIHdlIGRpZG4ndCBqdXN0IHNlbGVjdCBldmVyeXRoaW5nLCBlbmZvcmNlIGxheWVyc1xyXG4gICAgICAgICAgICBpZiAocy5zaXplICE9PSAwICYmIHN0YXRlLnNlbGVjdGVkLnNpemUgPCBzdGF0ZS5ub2Rlcy5zaXplKXtcclxuICAgICAgICAgICAgICAgIGJyaW5nVG9Ub3AoPEZsb3dUeXBlcy5Ob2RlW10+IEFycmF5LmZyb20oc2VsZWN0ZWQudmFsdWVzKCkpLmZpbHRlcihpdGVtID0+IGl0ZW0udHlwZSA9PT0gJ25vZGUnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghb3B0cz8uc3VwcHJlc3NFdmVudCkgZW1pdCgnc2VsZWN0ZWQnLCBuZXcgTWFwKHN0YXRlLnByZXNlbGVjdGVkKSk7XHJcbiAgICAgICAgaWYgKCFvcHRzPy5pZ25vcmVBY3Rpb24pIHJlY29yZEFjdGlvbignc2VsZWN0Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgb25lIG9yIG1vcmUgaXRlbXMgdG8gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAgICovXHJcbiAgICAgY29uc3QgYWRkVG9TZWxlY3Rpb24gPSAoaXRlbXM6IEZsb3dUeXBlcy5TZWxlY3RhYmxlSXRlbVtdLCBvcHRzPzogRmxvd1R5cGVzLkFjdGlvbkV4dGVuZGVkT3B0cykgPT4ge1xyXG4gICAgICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgICAgIHN0YXRlLnNlbGVjdGVkLnNldChpdGVtLmtleSwgaXRlbSk7XHJcbiAgICAgICAgICAgIEZsb3dVdGlsLmFkZEl0ZW1DbGFzcyhpdGVtLCBGbG93VHlwZXMuRmxvd0NsYXNzLkl0ZW1TZWxlY3RlZCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGJyaW5nVG9Ub3AoPEZsb3dUeXBlcy5Ob2RlW10+IEFycmF5LmZyb20oaXRlbXMudmFsdWVzKCkpLmZpbHRlcihpdGVtID0+IGl0ZW0udHlwZSA9PT0gJ25vZGUnKSk7XHJcblxyXG4gICAgICAgIGlmICghb3B0cz8uc3VwcHJlc3NFdmVudCkgZW1pdCgnc2VsZWN0ZWQnLCBuZXcgTWFwKHN0YXRlLnNlbGVjdGVkKSk7XHJcbiAgICAgICAgaWYgKCFvcHRzPy5pZ25vcmVBY3Rpb24pIHJlY29yZEFjdGlvbignc2VsZWN0Jyk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIG9uZSBvciBtb3JlIGl0ZW1zIGZyb20gdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHVzaW5nIGl0ZW0ga2V5cy5cclxuICAgICAqL1xyXG4gICAgY29uc3QgcmVtb3ZlRnJvbVNlbGVjdGlvbiA9IChrZXlzOiBzdHJpbmdbXSwgb3B0cz86IEZsb3dUeXBlcy5BY3Rpb25FeHRlbmRlZE9wdHMpID0+IHtcclxuICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgbGV0IHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGVkLmdldChrZXkpO1xyXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uKXtcclxuICAgICAgICAgICAgICAgIEZsb3dVdGlsLnJlbW92ZUl0ZW1DbGFzcyhzZWxlY3Rpb24sIEZsb3dUeXBlcy5GbG93Q2xhc3MuSXRlbVNlbGVjdGVkKTtcclxuICAgICAgICAgICAgICAgIHN0YXRlLnNlbGVjdGVkLmRlbGV0ZShrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmICghb3B0cz8uc3VwcHJlc3NFdmVudCkgZW1pdCgnc2VsZWN0ZWQnLCBuZXcgTWFwKHN0YXRlLnNlbGVjdGVkKSk7XHJcbiAgICAgICAgaWYgKCFvcHRzPy5pZ25vcmVBY3Rpb24pIHJlY29yZEFjdGlvbignc2VsZWN0Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCcmluZyBvbmUgb3IgbW9yZSBub2RlcyB0byB0aGUgZnJvbnQuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSBub2RlcyAtIEFycmF5IG9mIE5vZGUgaXRlbXMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGJyaW5nVG9Ub3AgPSAobm9kZXM6IEZsb3dUeXBlcy5Ob2RlW10pID0+IHtcclxuICAgICAgICBsZXQgdG9Ub3AgPSBub2Rlcy5zb3J0KChhLCBiKSA9PiAoYS56ID4gYi56KSA/IDEgOiAtMSk7IC8vU29ydCBnaXZlbiBub2Rlc1xyXG4gICAgICAgIGxldCB0b1RvcFNldCA9IG5ldyBTZXQodG9Ub3ApOyBcclxuICAgICAgICBsZXQgYWxsID0gQXJyYXkuZnJvbShzdGF0ZS5ub2Rlcy52YWx1ZXMoKSkuc29ydCgoYSwgYikgPT4gKGEueiA+IGIueikgPyAxIDogLTEpOyAvL1NvcnQgYWxsIG5vZGVzXHJcbiAgICAgICAgXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGFrZSBhbnkgbm9kZSBOT1QgaW4gdGhlIGdpdmVuIG5vZGUgc2V0IGFuZCBtb3ZlIGFsbCB0aGllciBpbmRleGVzIGRvd24uXHJcbiAgICAgICAgICogRm9yIHNvbWUgbm9kZXMsIHRoZSBpbmRleCBtYXkgbW92ZSBkb3duIGJ5IG1vcmUgdGhhbiAxLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGxldCBsYXN0WiA9IGFwaS5vcHRzLnpJbmRleFN0YXJ0ITsgLy9PdXIgY291bnRlclxyXG4gICAgICAgIGFsbC5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRvVG9wU2V0Lmhhcyhub2RlKSl7XHJcbiAgICAgICAgICAgICAgICBub2RlLnogPSBsYXN0WjtcclxuICAgICAgICAgICAgICAgIG5vZGUuZWwuc3R5bGUuekluZGV4ID0gbm9kZS56LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICBsYXN0WiA9IGxhc3RaICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbGF5ZXIgb3VyIGdpdmVuIG5vZGUgc2V0IHRvIHRoZSB0b3Agb2YgdGhlIGxpc3QsIGJ1dCBtYWludGFpbiB0aGVcclxuICAgICAgICAgKiBwcmV2aW91cyB6LWluZGV4ZXMgd2l0aGluIHRoZSBsaXN0ICh0aGlzIGlzIGFscmVhZHkgZG9uZSBieSBzb3J0aW5nKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGxldCB0b1RvcEJhc2VaID0gbGFzdFogKyB0b1RvcC5sZW5ndGg7XHJcbiAgICAgICAgdG9Ub3AuZm9yRWFjaCgobm9kZSwgaSkgPT4ge1xyXG4gICAgICAgICAgICBub2RlLnogPSB0b1RvcEJhc2VaICsgaTtcclxuICAgICAgICAgICAgbm9kZS5lbC5zdHlsZS56SW5kZXggPSBub2RlLnoudG9TdHJpbmcoKTtcclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICAvL1RPRE86XHJcbiAgICAgICAgLy9hcGkuZG9tLmxhc3NvRWwuc3R5bGUuekluZGV4ID0gKHRvVG9wW3RvVG9wLmxlbmd0aCAtIDFdLnogKyAxKS50b1N0cmluZygpO1xyXG4gICAgfSAgIFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHdoaWNoIGl0ZW1zIGFyZSBcInByZXNlbGVjdGVkXCIuIEFueSBleGlzdGluZyBcInByZXNlbGVjdFwiIHN0YXRlcyB3aWxsIGJlIHJlbW92ZWQuIFxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0gcHJlc2VsZWN0ZWQgLSBBcnJheSBvciBtYXAgb2YgaXRlbXMgdG8gcHJlc2VsZWN0LiBcclxuICAgICAqIEBwYXJhbSBvcHRzIFxyXG4gICAgICovXHJcbiAgICBjb25zdCBzZXRQcmVzZWxlY3RlZCA9IChwcmVzZWxlY3RlZDogRmxvd1R5cGVzLlNlbGVjdGFibGVJdGVtW10gfCBNYXA8c3RyaW5nLCBGbG93VHlwZXMuU2VsZWN0YWJsZUl0ZW0+LCBvcHRzPzogUGljazxGbG93VHlwZXMuQWN0aW9uRXh0ZW5kZWRPcHRzLCAnc3VwcHJlc3NFdmVudCc+KSA9PiB7XHJcbiAgICAgICAgbGV0IHMgPSBBcnJheS5pc0FycmF5KHByZXNlbGVjdGVkKSA/IG5ldyBNYXAocHJlc2VsZWN0ZWQubWFwKGl0ZW0gPT4gW2l0ZW0ua2V5LCBpdGVtXSkpIDogcHJlc2VsZWN0ZWQ7XHJcbiAgICAgICAgaWYgKHN0YXRlLnByZXNlbGVjdGVkLnNpemUgIT09IDAgfHwgcy5zaXplICE9PSAwKSB7XHJcbiAgICAgICAgICAgIEZsb3dVdGlsLnJlbW92ZUl0ZW1DbGFzcyhzdGF0ZS5wcmVzZWxlY3RlZCwgRmxvd1R5cGVzLkZsb3dDbGFzcy5JdGVtUHJlc2VsZWN0ZWQpO1xyXG4gICAgICAgICAgICBzdGF0ZS5wcmVzZWxlY3RlZCA9IHM7XHJcbiAgICAgICAgICAgIEZsb3dVdGlsLmFkZEl0ZW1DbGFzcyhzdGF0ZS5wcmVzZWxlY3RlZCwgRmxvd1R5cGVzLkZsb3dDbGFzcy5JdGVtUHJlc2VsZWN0ZWQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFvcHRzPy5zdXBwcmVzc0V2ZW50KSBlbWl0KCdwcmVzZWxlY3RlZCcsIG5ldyBNYXAoc3RhdGUucHJlc2VsZWN0ZWQpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBhbiBpdGVtIGZyb20gdGhlIGdyYXBoXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB0eXBlIC0gVGhlIGl0ZW0gdHlwZSwgb25lIG9mIGBub2RlYCwgYGxpbmtgLCBvciBgZWRnZWBcclxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUgaXRlbSBrZXlcclxuICAgICAqIEBwYXJhbSBvcHRzIC0gRXh0ZW5kZWQgb3B0aW9uc1xyXG4gICAgICogQHBhcmFtIG9wdHMuc3VwcHJlc3NFdmVudCAtIFdoZW4gc2V0IHRvIHRydWUsIG5vIGV2ZW50IHdpbGwgYmUgZW1pdHRlZCBmb3IgdGhpcyBhY3Rpb25cclxuICAgICAqIEBwYXJhbSBvcHRzLmlnbm9yZUFjdGlvbiAtIFdoZW4gc2V0IHRvIHRydWUsIG5vIGFjdGlvbiB3aWxsIGJlIGFkZGVkIHRvIHRoZSBkby91bmRvIHN0YWNrXHJcbiAgICAgKiBAcmV0dXJucyBcclxuICAgICAqL1xyXG4gICAgY29uc3QgcmVtb3ZlSXRlbSA9ICh0eXBlOiBGbG93VHlwZXMuRmxvd0l0ZW1UeXBlLCBrZXk6IHN0cmluZywgb3B0cz86IEZsb3dUeXBlcy5BY3Rpb25FeHRlbmRlZE9wdHMpID0+IHtcclxuICAgICAgICBsZXQgaXRlbSA9IGdldEl0ZW0odHlwZSwga2V5KTtcclxuICAgICAgICBpZiAoaXRlbSl7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoaXRlbS50eXBlKXtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ25vZGUnOiByZW1vdmVOb2RlKGl0ZW0ua2V5LCBvcHRzKTsgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnbGluayc6IHJlbW92ZUxpbmsoaXRlbS5rZXksIG9wdHMpOyByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBjYXNlICdlZGdlJzogcmVtb3ZlRWRnZShpdGVtLmtleSwgb3B0cyk7IHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBjdXJyZW50bHkgc2VsZWN0ZWQgaXRlbXMgZnJvbSB0aGUgZ3JhcGguIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBzZWxlY3RlZCBpdGVtcywgYW5kIGBpZ25vcmVBY3Rpb249ZmFsc2VgLFxyXG4gICAgICogdGhlbiB0aGUgb3BlcmF0aW9ucyB3aWxsIGJlIGJhdGNoZWQgaW50byBhIHNpbmdsZSBhY3Rpb24uXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSBvcHRzLnN1cHByZXNzRXZlbnQgLSBXaGVuIHNldCB0byB0cnVlLCBubyBldmVudCB3aWxsIGJlIGVtaXR0ZWQgZm9yIHRoaXMgYWN0aW9uXHJcbiAgICAgKiBAcGFyYW0gb3B0cy5pZ25vcmVBY3Rpb24gLSBXaGVuIHNldCB0byB0cnVlLCBubyBhY3Rpb24gd2lsbCBiZSBhZGRlZCB0byB0aGUgZG8vdW5kbyBzdGFja1xyXG4gICAgICovMVxyXG4gICAgY29uc3QgcmVtb3ZlU2VsZWN0ZWRJdGVtcyA9IChvcHRzPzogRmxvd1R5cGVzLkFjdGlvbkV4dGVuZGVkT3B0cykgPT4ge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHRoZSBzZWxlY3Rpb24gc2l6ZSBpcyBncmVhdGVyIHRoYW4gb25lLCB3ZSB3YW50IHRvIGlnbm9yZSB0aGUgaW5kaXZpZHVhbCByZW1vdmUgXHJcbiAgICAgICAgICogYWN0aW9ucyBhbmQgcmVjb3JkIHRoZSBiYXRjaCBhY3Rpb24gb25jZSBlYWNoIG9wZXJhdGlvbiBpcyBjb21wbGV0ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBsZXQgaWdub3JlU2luZ2xlQWN0aW9ucyA9IHN0YXRlLnNlbGVjdGVkLnNpemUgPiAxOyBcclxuICAgICAgICBzdGF0ZS5zZWxlY3RlZC5mb3JFYWNoKGl0ZW0gPT4ge1xyXG4gICAgICAgICAgICByZW1vdmVJdGVtKGl0ZW0udHlwZSwgaXRlbS5rZXksIHtcclxuICAgICAgICAgICAgICAgIHN1cHByZXNzRXZlbnQ6IG9wdHM/LnN1cHByZXNzRXZlbnQsXHJcbiAgICAgICAgICAgICAgICBpZ25vcmVBY3Rpb246IG9wdHM/Lmlnbm9yZUFjdGlvbiB8fCBpZ25vcmVTaW5nbGVBY3Rpb25zIC8vV2Ugd2lsbCB1c2UgYmF0Y2ggXCJyZW1vdmVJdGVtc1wiIGlmIG1vcmUgdGhhbiBvbmUgaXRlbSBpcyBiZWluZyByZW1vdmVkXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vUmVjb3JkIG91ciBiYXRjaCBhY3Rpb24gb25seSBpZiBtb3JlIHRoYW4gb25lIGl0ZW0gd2FzIHJlbW92ZWRcclxuICAgICAgICBpZiAoIW9wdHM/Lmlnbm9yZUFjdGlvbiAmJiBpZ25vcmVTaW5nbGVBY3Rpb25zKXtcclxuICAgICAgICAgICAgcmVjb3JkQWN0aW9uKCdyZW1vdmVJdGVtcycpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlIGFuIGV4aXN0aW5nIGl0ZW0gYnkgYHR5cGVgIGFuZCBga2V5YC5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIHR5cGUgLSBUaGUgaXRlbSB0eXBlLCBvbmUgb2YgYGdyYXBoYCwgYG5vZGVgLCBgZWRnZWAsIG9yIGBsaW5rYC5cclxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUgaXRlbSBrZXlcclxuICAgICAqIEByZXR1cm5zIHtGbG93VHlwZXMuRmxvd0l0ZW19XHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGdldEl0ZW0gPSAodHlwZT86IHN0cmluZyB8IG51bGwsIGtleT86IHN0cmluZyB8IG51bGwpIDogRmxvd1R5cGVzLkZsb3dJdGVtIHwgdW5kZWZpbmVkID0+ICB7XHJcbiAgICAgICAgbGV0IGl0ZW06IEZsb3dUeXBlcy5GbG93SXRlbSB8IHVuZGVmaW5lZDtcclxuICAgICAgICBpZiAodHlwZSA9PT0gJ2dyYXBoJyl7XHJcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS5yb290O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ICYmIHR5cGUgPT09ICdub2RlJykge1xyXG4gICAgICAgICAgICBpdGVtID0gc3RhdGUubm9kZXMuZ2V0KGtleSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgJiYgdHlwZSA9PT0gJ2VkZ2UnKSB7XHJcbiAgICAgICAgICAgIGl0ZW0gPSBzdGF0ZS5lZGdlcy5nZXQoa2V5KTtcclxuICAgICAgICB9IGVsc2UgaWYgKGtleSAmJiB0eXBlID09PSAnbGluaycpe1xyXG4gICAgICAgICAgICBpdGVtID0gc3RhdGUubGlua3MuZ2V0KGtleSkhO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaXRlbTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBldmVudCB0YXJnZXQgKGlmIHRoZXJlIGlzIG9uZSkgaXMgd2l0aGluIHRoaXMgZ3JhcGguXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSBlIC0gVGhlIGV2ZW50IGluIHF1ZXN0aW9uXHJcbiAgICAgKiBAcmV0dXJucyBcclxuICAgICAqL1xyXG4gICAgY29uc3QgZXZlbnRJbkdyYXBoID0gKGU6IHsgdGFyZ2V0OiBFdmVudFRhcmdldCB8IG51bGwgfSkgPT4ge1xyXG4gICAgcmV0dXJuICg8RWxlbWVudD4gZS50YXJnZXQpPy5jbG9zZXN0Py4oYC4ke0Zsb3dUeXBlcy5GbG93Q2xhc3MuQ29udGFpbmVyfWApPy5pZCA9PT0gZG9tLmluc3RhbmNlSWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhbiBldmVudCwgcmVzb2x2ZXMgYW4gaXRlbSB3aXRoaW4gdGhlIGdyYXBoIG9yIHJldHVybnMgYHVuZGVmaW5lZGAgaWYgbm8gaXRlbSB3YXMgdGFyZ2V0ZWQuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSBlIC0gVGhlIGV2ZW50IGluIHF1ZXN0aW9uLCBlaXRoZXIgYFBvaW50ZXJFdmVudGAgb3IgYE1vdXNlRXZlbnRgXHJcbiAgICAgKiBAcmV0dXJucyB7Rmxvd1R5cGVzLkZsb3dJdGVtIHwgdW5kZWZpbmVkfVxyXG4gICAgICovXHJcbiAgICBjb25zdCByZXNvbHZlSXRlbSA9IChlOiBQb2ludGVyRXZlbnQgfCBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgICAgaWYgKCFldmVudEluR3JhcGgoZSkpIHJldHVybjtcclxuXHJcbiAgICAgICAgbGV0IGl0ZW06IEZsb3dUeXBlcy5GbG93SXRlbSB8IHVuZGVmaW5lZDtcclxuICAgICAgICBsZXQgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChlLmNsaWVudFgsIGUuY2xpZW50WSk7XHJcbiAgICAgICAgaWYgKHRhcmdldCAvKmUudGFyZ2V0ICYmIGUudGFyZ2V0IGluc3RhbmNlb2YgRWxlbWVudCAqLyl7XHJcbiAgICAgICAgICAgIGxldCBjbG9zZXN0SXRlbSA9IHRhcmdldC5jbG9zZXN0KGBbJHtGbG93VHlwZXMuRmxvd0F0dHIuVHlwZX1dYCk7XHJcbiAgICAgICAgICAgIGlmIChjbG9zZXN0SXRlbSl7XHJcbiAgICAgICAgICAgICAgICBjbG9zZXN0SXRlbS5nZXRBdHRyaWJ1dGVcclxuICAgICAgICAgICAgICAgIGl0ZW0gPSBnZXRJdGVtKFxyXG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RJdGVtLmdldEF0dHJpYnV0ZShGbG93VHlwZXMuRmxvd0F0dHIuVHlwZSksIFxyXG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RJdGVtLmdldEF0dHJpYnV0ZShGbG93VHlwZXMuRmxvd0F0dHIuS2V5KVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaXRlbTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhZGRFZGdlID0gKGdyb3VwOiBzdHJpbmcsIG5vZGVLZXk6IHN0cmluZywgZWRnZUtleTogc3RyaW5nLCBvcHRzPzogRmxvd1R5cGVzLkFkZEVkZ2VPcHRpb25zKSA6IEZsb3dUeXBlcy5FZGdlID0+IHtcclxuICAgICAgICBsZXQga2V5ID0gYCR7bm9kZUtleX06JHtlZGdlS2V5fWA7XHJcbiAgICAgICAgaWYgKCFzdGF0ZS5lZGdlcy5oYXMoa2V5KSl7XHJcbiAgICAgICAgICAgIGxldCBub2RlID0gc3RhdGUubm9kZXMuZ2V0KG5vZGVLZXkpO1xyXG4gICAgICAgICAgICBpZiAobm9kZSl7XHJcbiAgICAgICAgICAgICAgICBsZXQgZWRnZSA9IEZsb3dVdGlsLmNyZWF0ZUVkZ2Uobm9kZSwgZ3JvdXAsIGVkZ2VLZXksIG9wdHM/LmNsYXNzKTtcclxuICAgICAgICAgICAgICAgICAgICBlZGdlLmRhdGEgPSBvcHRzPy5kYXRhIHx8IHt9O1xyXG5cclxuICAgICAgICAgICAgICAgIHN0YXRlLmVkZ2VzLnNldChrZXksIGVkZ2UpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vaWYgKGNvbnRlbnQpIHNldEVkZ2VDb250ZW50KG5vZGVLZXksIGVkZ2VLZXksIGNvbnRlbnQpO1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyKGVkZ2UpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vQXBwZW5kIGVkZ2UgdG8gbm9kZVxyXG4gICAgICAgICAgICAgICAgZWRnZS5ncm91cC5ncm91cEVsLmFwcGVuZENoaWxkKGVkZ2UuZWwpO1xyXG4gICAgICAgICAgICAgICAgLy8gbGV0IHRhcmdldExpc3QgPSB0eXBlID09PSAnaW5wdXQnID8gbm9kZS5pbnB1dHNFbCA6IG5vZGUub3V0cHV0c0VsO1xyXG4gICAgICAgICAgICAgICAgLy8gICAgIHRhcmdldExpc3QuYXBwZW5kQ2hpbGQoZWRnZS5lbCk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmICghb3B0cz8uc3VwcHJlc3NFdmVudCkgZW1pdCgnZWRnZUFkZGVkJywgZWRnZSk7ICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYgKCFvcHRzPy5pZ25vcmVBY3Rpb24pIHJlY29yZEFjdGlvbignYWRkRWRnZScpO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZWRnZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1YRmxvdzogQXR0ZW1wdGVkIHRvIGFkZCBlZGdlIHRvIG5vZGUgd2hpY2ggZG9lc24ndCBleGlzdCAoa2V5PVwiJHtrZXl9XCIpYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTVhGbG93OiBBdHRlbXB0ZWQgdG8gYWRkIGVkZ2Ugd2l0aCBhIGtleSB0aGF0IGFscmVhZHkgZXhpc3RzIChrZXk9XCIke2tleX1cIilgKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByZW1vdmVFZGdlID0gKGtleTogc3RyaW5nLCBvcHRzPzogRmxvd1R5cGVzLkFjdGlvbkV4dGVuZGVkT3B0cykgPT4ge1xyXG4gICAgICAgIGxldCBlZGdlID0gc3RhdGUuZWRnZXMuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYgKGVkZ2Upe1xyXG4gICAgICAgICAgICBpZiAoYXBpLm9wdHMuYmVmb3JlRWRnZVJlbW92ZWQgJiYgIWFwaS5vcHRzLmJlZm9yZUVkZ2VSZW1vdmVkKGVkZ2UpKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAvL1JlbW92ZSBhbnkgbGlua3MgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZWRnZSBhbmQgYmF0Y2ggdGhpcyBhY3Rpb24gaW4gdy8gdGhlIGVkZ2UgcmVtb3ZhbFxyXG4gICAgICAgICAgICBzdGF0ZS5saW5rcy5mb3JFYWNoKGxpbmsgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKChsaW5rLmZyb21Ob2RlID09PSBlZGdlPy5ub2RlS2V5ICYmIGxpbmsuZnJvbUVkZ2UgPT09IGVkZ2U/LmVkZ2VLZXkpIHx8IChsaW5rLnRvTm9kZSA9PT0gZWRnZT8ubm9kZUtleSAmJiBsaW5rLnRvRWRnZSA9PT0gZWRnZT8uZWRnZUtleSkpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUxpbmsobGluay5rZXksIHsgc3VwcHJlc3NFdmVudDogb3B0cz8uc3VwcHJlc3NFdmVudCwgaWdub3JlQWN0aW9uOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGVkZ2UuZWwucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIHN0YXRlLmVkZ2VzLmRlbGV0ZShrZXkpO1xyXG5cclxuICAgICAgICAgICAgRmxvd1V0aWwuYXBwbHlBbGxMaW5rUG9zaXRpb25zKGFwaSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIW9wdHM/LnN1cHByZXNzRXZlbnQpIGVtaXQoJ2VkZ2VSZW1vdmVkJywgZWRnZSk7XHJcbiAgICAgICAgICAgIGlmICghb3B0cz8uaWdub3JlQWN0aW9uKSByZWNvcmRBY3Rpb24oJ3JlbW92ZUVkZ2UnKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNWEZsb3c6IE5vIGVkZ2UgZXhpc3RzIHdpdGgga2V5PVwiJHtrZXl9XCJgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjb25zdCBzZXROb2RlQ29udGVudCA9IChub2RlS2V5OiBzdHJpbmcsIGNvbnRlbnQ6IEhUTUxFbGVtZW50IHwgc3RyaW5nKSA9PiB7XHJcbiAgICAvLyAgICAgbGV0IG5vZGUgPSBzdGF0ZS5ub2Rlcy5nZXQobm9kZUtleSk7XHJcbiAgICAvLyAgICAgaWYgKG5vZGUpe1xyXG4gICAgLy8gICAgICAgICBpZiAoY29udGVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KXtcclxuICAgIC8vICAgICAgICAgICAgIG5vZGUuY29udGVudEVsLmlubmVySFRNTCA9ICcnXHJcbiAgICAvLyAgICAgICAgICAgICBub2RlLmNvbnRlbnRFbC5hcHBlbmRDaGlsZChjb250ZW50KTtcclxuICAgIC8vICAgICAgICAgfSBlbHNlIHtcclxuICAgIC8vICAgICAgICAgICAgIG5vZGUuY29udGVudEVsLmlubmVySFRNTCA9ICcnXHJcbiAgICAvLyAgICAgICAgICAgICBub2RlLmNvbnRlbnRFbC5pbnNlcnRBZGphY2VudEhUTUwoJ2FmdGVyYmVnaW4nLCBjb250ZW50KTtcclxuICAgIC8vICAgICAgICAgfVxyXG4gICAgLy8gICAgIH1cclxuICAgIC8vICAgICB0aHJvdyBuZXcgRXJyb3IoYE1YRmxvdzogQXR0ZW1wdGVkIHRvIHNldCBub2RlIGNvbnRlbnQgb24gbm9kZSB3aGljaCBkb2Vzbid0IGV4aXN0IChrZXk9XCIke25vZGVLZXl9XCIpYCk7XHJcbiAgICAvLyB9XHJcblxyXG4gICAgY29uc3QgYWRkTm9kZSA9IChub2RlS2V5OiBzdHJpbmcsIG9wdGlvbnM6IEZsb3dUeXBlcy5BZGROb2RlT3B0aW9ucyA9IHt9KSA9PiB7XHJcbiAgICAgICAgbGV0IG9wdHMgPSB7IC4uLkFkZE5vZGVEZWZhdWx0T3B0cywgLi4ub3B0aW9ucyB9O1xyXG4gICAgICAgIGlmICghc3RhdGUubm9kZXMuaGFzKG5vZGVLZXkpKXtcclxuICAgICAgICAgICAgbGV0IG5vZGUgPSBGbG93VXRpbC5jcmVhdGVOb2RlKHtcclxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBhcGkub3B0cy5ub2RlSFRNTFRlbXBsYXRlLFxyXG4gICAgICAgICAgICAgICAga2V5OiBub2RlS2V5LFxyXG4gICAgICAgICAgICAgICAgeDogb3B0cy54ID8/IDAsXHJcbiAgICAgICAgICAgICAgICB5OiBvcHRzLnkgPz8gMCxcclxuICAgICAgICAgICAgICAgIHo6IHN0YXRlLm5vZGVzLnNpemUgKyAxLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IG9wdHMud2lkdGgsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG9wdHMuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgbm9kZUNsYXNzOiBvcHRzLmNsYXNzLFxyXG4gICAgICAgICAgICAgICAgZGF0YTogb3B0cy5kYXRhXHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICBzdGF0ZS5ub2Rlcy5zZXQobm9kZUtleSwgbm9kZSk7XHJcblxyXG4gICAgICAgICAgICAvL0NyZWF0ZSBlZGdlc1xyXG4gICAgICAgICAgICBvcHRpb25zLmVkZ2VzPy5mb3JFYWNoKGNvbmZpZyA9PiB7XHJcbiAgICAgICAgICAgICAgICBhZGRFZGdlKGNvbmZpZy5ncm91cCwgbm9kZUtleSwgY29uZmlnLmtleSwgeyBcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjb25maWcuZGF0YSwgXHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M6IGNvbmZpZy5jbGFzcyxcclxuICAgICAgICAgICAgICAgICAgICBzdXBwcmVzc0V2ZW50OiB0cnVlLCBcclxuICAgICAgICAgICAgICAgICAgICBpZ25vcmVBY3Rpb246IHRydWUgXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgcmVuZGVyKG5vZGUpO1xyXG5cclxuICAgICAgICAgICAgLy9BZGQgbm9kZSBhbmQgYmluZCBwb3NpdGlvblxyXG4gICAgICAgICAgICBkb20ubm9kZUNvbnRhaW5lckVsLmFwcGVuZENoaWxkKG5vZGUuZWwpO1xyXG4gICAgICAgICAgICBGbG93VXRpbC5hcHBseU5vZGVQb3NpdGlvbihub2RlKTtcclxuXHJcbiAgICAgICAgICAgIC8vRW1pdCBldmVudCBhbmQgcmVjb3JkIGFjdGlvbiBvZiBjb25maWd1cmVkXHJcbiAgICAgICAgICAgIGlmICghb3B0cz8uc3VwcHJlc3NFdmVudCkgZW1pdCgnbm9kZUFkZGVkJywgbm9kZSk7XHJcbiAgICAgICAgICAgIGlmICghb3B0cz8uaWdub3JlQWN0aW9uKSByZWNvcmRBY3Rpb24oJ2FkZE5vZGUnKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNWEZsb3c6IEF0dGVtcHRlZCB0byBhZGQgYSBub2RlIHdpdGggYSBrZXkgdGhhdCBhbHJlYWR5IGV4aXN0cyAoa2V5PVwiJHtub2RlS2V5fVwiKWApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNvbnN0IHVwZGF0ZU5vZGVUZW1wbGF0ZSA9IChub2RlOiBzdHJpbmcgfCBGbG93VHlwZXMuTm9kZSwgaHRtbFRlbXBsYXRlOiBzdHJpbmcpID0+IHtcclxuICAgIC8vICAgICBpZiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnKXtcclxuICAgIC8vICAgICAgICAgbm9kZSA9IDxGbG93VHlwZXMuTm9kZT4gZ2V0SXRlbSgnbm9kZScsIG5vZGUpO1xyXG4gICAgLy8gICAgICAgICBpZiAoIW5vZGUpe1xyXG4gICAgLy8gICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1cGRhdGVOb2RlVGVtcGxhdGUoKTogTm8gbm9kZSBleGlzdHMgd2l0aCBrZXk9XCIke25vZGV9XCJgKTtcclxuICAgIC8vICAgICAgICAgfVxyXG4gICAgLy8gICAgIH1cclxuXHJcbiAgICAvLyAgICAgRmxvd1V0aWwudXBkYXRlTm9kZVRlbXBsYXRlKGFwaSwgbm9kZSwgaHRtbFRlbXBsYXRlKTtcclxuXHJcbiAgICAvLyAgICAgcmVuZGVyKG5vZGUpOyAvL1JlbmRlciBub2RlXHJcbiAgICAvLyAgICAgc3RhdGUuZWRnZXMuZm9yRWFjaChlZGdlID0+IHsgLy9SZW5kZXIgYW55IG5vZGUgZWRnZXNcclxuICAgIC8vICAgICAgICAgaWYgKGVkZ2Uubm9kZUtleSA9PT0gKDxGbG93VHlwZXMuTm9kZT4gbm9kZSkua2V5KXtcclxuICAgIC8vICAgICAgICAgICAgIHJlbmRlcihlZGdlKTtcclxuICAgIC8vICAgICAgICAgfVxyXG4gICAgLy8gICAgIH0pXHJcbiAgICAvLyB9XHJcblxyXG4gICAgY29uc3QgcmVtb3ZlTm9kZSA9IChrZXk6IHN0cmluZywgb3B0cz86IEZsb3dUeXBlcy5BY3Rpb25FeHRlbmRlZE9wdHMpID0+IHtcclxuICAgICAgICBsZXQgbm9kZSA9IHN0YXRlLm5vZGVzLmdldChrZXkpO1xyXG4gICAgICAgIGlmIChub2RlKXtcclxuICAgICAgICAgICAgaWYgKGFwaS5vcHRzLmJlZm9yZU5vZGVSZW1vdmVkICYmICFhcGkub3B0cy5iZWZvcmVOb2RlUmVtb3ZlZChub2RlKSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgLy9DbGVhciBmcm9tIHNlbGVjdGlvblxyXG4gICAgICAgICAgICBpZiAoc3RhdGUuc2VsZWN0ZWQuaGFzKGtleSkpe1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlRnJvbVNlbGVjdGlvbihba2V5XSwgeyBzdXBwcmVzc0V2ZW50OiB0cnVlLCBpZ25vcmVBY3Rpb246IHRydWUgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vY2xlYXIgbGlua3NcclxuICAgICAgICAgICAgc3RhdGUubGlua3MuZm9yRWFjaChsaW5rID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChsaW5rLmZyb21Ob2RlID09PSBub2RlPy5rZXkgfHwgbGluay50b05vZGUgPT09IG5vZGU/LmtleSl7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluay5lbC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5saW5rcy5kZWxldGUobGluay5rZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vY2xlYXIgZWRnZXNcclxuICAgICAgICAgICAgc3RhdGUuZWRnZXMuZm9yRWFjaCgoZWRnZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVkZ2Uubm9kZUtleSA9PT0gbm9kZT8ua2V5KXtcclxuICAgICAgICAgICAgICAgICAgICBlZGdlLmVsLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmVkZ2VzLmRlbGV0ZShlZGdlLmtleSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICAvL3RoaXMuZW1pdCgnYmVmb3JlTm9kZVJlbW92ZWQnLCBub2RlKTtcclxuICAgICAgICAgICAgbm9kZS5lbC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgc3RhdGUubm9kZXMuZGVsZXRlKGtleSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIW9wdHM/LnN1cHByZXNzRXZlbnQpe1xyXG4gICAgICAgICAgICAgICAgZW1pdCgnbm9kZVJlbW92ZWQnLCBub2RlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9BZGQgYWN0aW9uIHRvIHVuZG8gc3RhY2sgaWYgY29uZmlndXJlZCAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoIW9wdHM/Lmlnbm9yZUFjdGlvbil7XHJcbiAgICAgICAgICAgICAgICByZWNvcmRBY3Rpb24oJ3JlbW92ZU5vZGUnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1YRmxvdzogTm8gbm9kZSBleGlzdHMgd2l0aCBrZXk9XCIke2tleX1cImApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGFkZExpbmsgPSAoZnJvbU5vZGU6IHN0cmluZywgZnJvbUVkZ2U6IHN0cmluZywgdG9Ob2RlOiBzdHJpbmcsIHRvRWRnZTogc3RyaW5nLCBvcHRzPzogRmxvd1R5cGVzLkFkZExpbmtPcHRpb25zKSA9PiB7XHJcbiAgICAgICAgbGV0IHBhcmFtcyA9IHsgZnJvbU5vZGUsIGZyb21FZGdlLCB0b05vZGUsIHRvRWRnZSB9O1xyXG4gICAgICAgIGxldCBmcm9tID0gc3RhdGUuZWRnZXMuZ2V0KGAke2Zyb21Ob2RlfToke2Zyb21FZGdlfWApO1xyXG4gICAgICAgIGxldCB0byA9IHN0YXRlLmVkZ2VzLmdldChgJHt0b05vZGV9OiR7dG9FZGdlfWApO1xyXG4gICAgICAgIGlmICghZnJvbSB8fCAhdG8pe1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1YRmxvdy5hZGRMaW5rKCk6IE9uZSBvciBib3RoIGVkZ2VzIG1pc3NpbmcgXCIke2Zyb21FZGdlfVwiLCBcIiR7dG9FZGdlfVwiYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL1N3YXAgZGlyZWN0aW9uIGlmIHByb3ZpZGVkIGJhY2t3YXJkc1xyXG4gICAgICAgIC8vIGlmIChmcm9tLnR5cGUgPT09ICdpbnB1dCcpe1xyXG4gICAgICAgIC8vICAgICB0aHJvdyBuZXcgRXJyb3IoYE1YZmxvdy5hZGRMaW5rKCk6IFRoZSBcImZyb21cIiBlZGdlIG11c3QgYmUgb2YgdHlwZSAnb3V0cHV0Jy5gKTtcclxuICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgIGlmICghaXNMaW5rVmFsaWQoZnJvbSwgdG8pKXtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNWEZsb3cuYWRkTGluaygpOiBJbnZhbGlkIGxpbmsuYClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBrZXkgPSBGbG93VXRpbC5nZXRMaW5rQ29tcG9zaXRlS2V5KHBhcmFtcyk7XHJcbiAgICAgICAgaWYgKCFzdGF0ZS5saW5rcy5oYXMoa2V5KSl7XHJcbiAgICAgICAgICAgIGxldCBsaW5rID0gRmxvd1V0aWwuY3JlYXRlTGluayhwYXJhbXMsIG9wdHM/LmNsYXNzKTtcclxuICAgICAgICAgICAgICAgIGxpbmsuZGF0YSA9IG9wdHM/LmRhdGEgfHwge307XHJcblxyXG4gICAgICAgICAgICBzdGF0ZS5saW5rcy5zZXQoa2V5LCBsaW5rKTtcclxuICAgICAgICAgICAgZG9tLmxpbmtDb250YWluZXJFbC5hcHBlbmRDaGlsZChsaW5rLmVsKTtcclxuICAgICAgICAgICAgRmxvd1V0aWwuYXBwbHlMaW5rUG9zaXRpb24oYXBpLCBsaW5rKTtcclxuXHJcbiAgICAgICAgICAgIGlmICghb3B0cz8uc3VwcHJlc3NFdmVudCl7XHJcbiAgICAgICAgICAgICAgICBlbWl0KCdsaW5rQWRkZWQnLCBsaW5rKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9BZGQgYWN0aW9uIHRvIHVuZG8gc3RhY2sgaWYgY29uZmlndXJlZCAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoIW9wdHM/Lmlnbm9yZUFjdGlvbil7XHJcbiAgICAgICAgICAgICAgICByZWNvcmRBY3Rpb24oJ2FkZExpbmsnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1YRmxvdzogQXR0ZW1wdGVkIHRvIGFkZCBsaW5rIHdoaWNoIGFscmVhZHkgZXhpc3RzIChrZXk9XCIke2tleX1cIilgKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByZW1vdmVMaW5rID0gKGtleTogc3RyaW5nLCBvcHRzPzogRmxvd1R5cGVzLkFjdGlvbkV4dGVuZGVkT3B0cykgPT4ge1xyXG4gICAgICAgIC8vbGV0IGtleSA9IEZsb3dVdGlsLmdldExpbmtDb21wb3NpdGVLZXkoeyBmcm9tTm9kZSwgZnJvbUVkZ2UsIHRvTm9kZSwgdG9FZGdlIH0pO1xyXG4gICAgICAgIGxldCBsaW5rID0gc3RhdGUubGlua3MuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYgKGxpbmspe1xyXG4gICAgICAgICAgICBpZiAoYXBpLm9wdHMuYmVmb3JlTGlua1JlbW92ZWQgJiYgIWFwaS5vcHRzLmJlZm9yZUxpbmtSZW1vdmVkKGxpbmspKSByZXR1cm47XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZS5zZWxlY3RlZC5oYXMoa2V5KSl7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVGcm9tU2VsZWN0aW9uKFtrZXldLCB7IHN1cHByZXNzRXZlbnQ6IHRydWUsIGlnbm9yZUFjdGlvbjogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGluay5lbC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgc3RhdGUubGlua3MuZGVsZXRlKGtleSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIW9wdHM/LnN1cHByZXNzRXZlbnQpe1xyXG4gICAgICAgICAgICAgICAgZW1pdCgnbGlua1JlbW92ZWQnLCBsaW5rKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9BZGQgYWN0aW9uIHRvIHVuZG8gc3RhY2sgaWYgY29uZmlndXJlZCAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoIW9wdHM/Lmlnbm9yZUFjdGlvbil7XHJcbiAgICAgICAgICAgICAgICByZWNvcmRBY3Rpb24oJ3JlbW92ZUxpbmsnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBpc0xpbmtWYWxpZCA9IChmcm9tRWRnZTogRmxvd1R5cGVzLkVkZ2UsIHRvRWRnZTogRmxvd1R5cGVzLkVkZ2UpID0+IHtcclxuICAgICAgICBpZiAoZnJvbUVkZ2UgJiYgdG9FZGdlKXtcclxuICAgICAgICAgICAgaWYgKGZyb21FZGdlLm5vZGVLZXkgPT09IHRvRWRnZS5ub2RlS2V5KSByZXR1cm4gZmFsc2U7IC8vQ2hlY2sgaWYgZWRnZXMgYXJlIG9uIHNhbWUgbm9kZVxyXG4gICAgICAgICAgICBpZiAoZnJvbUVkZ2UuZ3JvdXAuZ3JvdXBLZXkgPT09IHRvRWRnZS5ncm91cC5ncm91cEtleSkgcmV0dXJuIGZhbHNlOyAvL0NoZWNrIGlmIHR5cGUgbWF0Y2hlc1xyXG4gICAgICAgICAgICBpZiAoc3RhdGUubGlua3MuaGFzKGAke2Zyb21FZGdlLm5vZGVLZXl9OiR7ZnJvbUVkZ2UuZWRnZUtleX06JHt0b0VkZ2Uubm9kZUtleX06JHt0b0VkZ2UuZWRnZUtleX1gKSkgcmV0dXJuIGZhbHNlOyAvL0NoZWNrIGlmIGxpbmsgYWxyZWFkeSBleGlzdHNcclxuICAgICAgICAgICAgaWYgKHN0YXRlLmxpbmtzLmhhcyhgJHt0b0VkZ2Uubm9kZUtleX06JHt0b0VkZ2UuZWRnZUtleX06JHtmcm9tRWRnZS5ub2RlS2V5fToke2Zyb21FZGdlLmVkZ2VLZXl9YCkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKGFwaS5vcHRzLmxpbmtWYWxpZGF0b3IgJiYgIWFwaS5vcHRzLmxpbmtWYWxpZGF0b3IoZnJvbUVkZ2UsIHRvRWRnZSkpIHJldHVybiBmYWxzZTsgLy9Vc2VyIHZhbGlkYXRpb25cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBvcGVuQ29udGV4dE1lbnUgPSAoZ3JhcGhYOiBudW1iZXIsIGdyYXBoWTogbnVtYmVyLCB0YXJnZXQ6IEZsb3dUeXBlcy5GbG93SXRlbSwgb3B0cz86IHsgc3VwcHJlc3NFdmVudDogYm9vbGVhbiB9KSA9PiB7XHJcbiAgICAgICAgcmVuZGVyQ29udGV4dCh0YXJnZXQsIGdyYXBoWCwgZ3JhcGhZKTtcclxuICAgICAgICAvLyBkb20uY29udGV4dEVsLnN0eWxlLmxlZnQgPSBgJHtncmFwaFh9cHhgO1xyXG4gICAgICAgIC8vIGRvbS5jb250ZXh0RWwuc3R5bGUudG9wID0gYCR7Z3JhcGhZfXB4YDtcclxuICAgICAgICAvLyBkb20uY29udGV4dEVsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgICAgIHN0YXRlLmNvbnRleHRPcGVuID0gdHJ1ZTtcclxuICAgICAgICBpZiAoIW9wdHM/LnN1cHByZXNzRXZlbnQpe1xyXG4gICAgICAgICAgICBlbWl0KCdjb250ZXh0T3BlbmVkJywgdGFyZ2V0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY2xvc2VDb250ZXh0TWVudSA9IChvcHRzPzogeyBzdXBwcmVzc0V2ZW50OiBib29sZWFuIH0pID0+IHtcclxuICAgICAgICBkb20uY29udGV4dEVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgc3RhdGUuY29udGV4dE9wZW4gPSBmYWxzZTtcclxuICAgICAgICBpZiAoIW9wdHM/LnN1cHByZXNzRXZlbnQpe1xyXG4gICAgICAgICAgICBlbWl0KCdjb250ZXh0Q2xvc2VkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNsZWFyID0gKG9wdHM/OiBGbG93VHlwZXMuQWN0aW9uRXh0ZW5kZWRPcHRzKSA9PiB7XHJcbiAgICAgICAgc3RhdGUucHJlc2VsZWN0ZWQuY2xlYXIoKTtcclxuICAgICAgICBzdGF0ZS5zZWxlY3RlZC5jbGVhcigpO1xyXG4gICAgICAgIHN0YXRlLm5vZGVzLmNsZWFyKCk7XHJcbiAgICAgICAgc3RhdGUuZWRnZXMuY2xlYXIoKTtcclxuICAgICAgICBzdGF0ZS5saW5rcy5jbGVhcigpO1xyXG4gICAgICAgIGRvbS5saW5rQ29udGFpbmVyRWwuaW5uZXJIVE1MID0gJyc7XHJcbiAgICAgICAgZG9tLm5vZGVDb250YWluZXJFbC5pbm5lckhUTUwgPSAnJztcclxuICAgICAgICBpZiAoIW9wdHM/LnN1cHByZXNzRXZlbnQpIGVtaXQoJ2NsZWFyZWQnKTtcclxuICAgICAgICBpZiAoIW9wdHM/Lmlnbm9yZUFjdGlvbikgcmVjb3JkQWN0aW9uKCdjbGVhcicpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHRoZSBjdXJyZW50IG1vZGVsIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHJlc2V0IHRvIGEgcHJldmlvdXMgc3RhdGVcclxuICAgICAqIHVzaW5nIHNldE1vZGVsKClcclxuICAgICAqL1xyXG4gICAgIGNvbnN0IGdldE1vZGVsID0gKCkgOiBGbG93VHlwZXMuTW9kZWwgPT4ge1xyXG4gICAgICAgIGxldCBtb2RlbCA6IEZsb3dUeXBlcy5Nb2RlbCA9IHtcclxuICAgICAgICAgICAgdHJhbnNmb3JtOiBzdGF0ZS50cmFuc2Zvcm0sXHJcbiAgICAgICAgICAgIG5vZGVzOiB7fSxcclxuICAgICAgICAgICAgbGlua3M6IHt9LFxyXG4gICAgICAgICAgICBlZGdlczoge31cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXRlLm5vZGVzLmZvckVhY2gobm9kZSA9PiB7XHJcbiAgICAgICAgICAgIG1vZGVsLm5vZGVzW25vZGUua2V5XSA9IHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBzdGF0ZS5zZWxlY3RlZC5oYXMobm9kZS5rZXkpLFxyXG4gICAgICAgICAgICAgICAgeDogbm9kZS54LFxyXG4gICAgICAgICAgICAgICAgeTogbm9kZS55LFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IG5vZGUud2lkdGgsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG5vZGUuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgY2xhc3M6IG5vZGUuY2xhc3MsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBub2RlLmRhdGFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIHN0YXRlLmVkZ2VzLmZvckVhY2goZWRnZSA9PiB7XHJcbiAgICAgICAgICAgIG1vZGVsLmVkZ2VzW2VkZ2Uua2V5XSA9IHtcclxuICAgICAgICAgICAgICAgIG5vZGVLZXk6IGVkZ2Uubm9kZUtleSxcclxuICAgICAgICAgICAgICAgIGVkZ2VLZXk6IGVkZ2UuZWRnZUtleSxcclxuICAgICAgICAgICAgICAgIGdyb3VwS2V5OiBlZGdlLmdyb3VwLmdyb3VwS2V5LFxyXG4gICAgICAgICAgICAgICAgZGF0YTogZWRnZS5kYXRhLFxyXG4gICAgICAgICAgICAgICAgY2xhc3M6IGVkZ2UuY2xhc3NcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcblxyXG4gICAgICAgIHN0YXRlLmxpbmtzLmZvckVhY2gobGluayA9PiB7XHJcbiAgICAgICAgICAgIG1vZGVsLmxpbmtzW2xpbmsua2V5XSA9IHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBzdGF0ZS5zZWxlY3RlZC5oYXMobGluay5rZXkpLFxyXG4gICAgICAgICAgICAgICAgZnJvbU5vZGU6IGxpbmsuZnJvbU5vZGUsXHJcbiAgICAgICAgICAgICAgICBmcm9tRWRnZTogbGluay5mcm9tRWRnZSxcclxuICAgICAgICAgICAgICAgIHRvTm9kZTogbGluay50b05vZGUsXHJcbiAgICAgICAgICAgICAgICB0b0VkZ2U6IGxpbmsudG9FZGdlLFxyXG4gICAgICAgICAgICAgICAgZGF0YTogbGluay5kYXRhXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICByZXR1cm4gbW9kZWw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZCBncmFwaCBmcm9tIGEgcHJldmlvdXMgbW9kZWwuIE9wdGlvbmFsbHkgcHJvdmlkZSBhIGhvb2sgd2hpY2ggcmV0dXJucyBIVE1MIGNvbnRlbnQgZm9yIFxyXG4gICAgICogYW55IGl0ZW1zIHdpdGggYSBjb250ZW50IHNlY3Rpb24uIFRoaXMgbWV0aG9kIGlzIGFzeW5jaHJvbm91cyBiZWNhdXNlIG9mIHRoZSB3YXkgY2xpZW50Qm91bmRpbmdSZWN0KClcclxuICAgICAqIGlzIGNhbGN1bGF0ZWQgKG5vdCBzeW5jaHJvbm91c2x5KVxyXG4gICAgICovXHJcbiAgICBjb25zdCBzZXRNb2RlbCA9IGFzeW5jIChtb2RlbDogRmxvd1R5cGVzLk1vZGVsKSA9PiB7XHJcbiAgICAgICAgY2xlYXIoeyBzdXBwcmVzc0V2ZW50OiB0cnVlLCBpZ25vcmVBY3Rpb246IHRydWUgfSk7XHJcblxyXG4gICAgICAgIC8vVE9ETzogU2V0IHRyYW5zZm9ybT8/P1xyXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKG1vZGVsLm5vZGVzKS5mb3JFYWNoKGVudHJ5ID0+IHtcclxuICAgICAgICAgICAgYWRkTm9kZShlbnRyeVswXSwge1xyXG4gICAgICAgICAgICAgICAgeDogZW50cnlbMV0ueCxcclxuICAgICAgICAgICAgICAgIHk6IGVudHJ5WzFdLnksXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogZW50cnlbMV0ud2lkdGgsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGVudHJ5WzFdLmhlaWdodCxcclxuICAgICAgICAgICAgICAgIGNsYXNzOiBlbnRyeVsxXS5jbGFzcyxcclxuICAgICAgICAgICAgICAgIHN1cHByZXNzRXZlbnQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgaWdub3JlQWN0aW9uOiB0cnVlXHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICBpZiAoZW50cnlbMV0uc2VsZWN0ZWQpe1xyXG4gICAgICAgICAgICAgICAgYWRkVG9TZWxlY3Rpb24oW3N0YXRlLm5vZGVzLmdldChlbnRyeVswXSkhXSwgeyBpZ25vcmVBY3Rpb246IHRydWUgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG5cclxuICAgICAgICBPYmplY3QuZW50cmllcyhtb2RlbC5lZGdlcykuZm9yRWFjaChlbnRyeSA9PiB7XHJcbiAgICAgICAgICAgIGFkZEVkZ2UoXHJcbiAgICAgICAgICAgICAgICBlbnRyeVsxXS5ncm91cEtleSwgXHJcbiAgICAgICAgICAgICAgICBlbnRyeVsxXS5ub2RlS2V5LCBcclxuICAgICAgICAgICAgICAgIGVudHJ5WzFdLmVkZ2VLZXksXHJcbiAgICAgICAgICAgICAgICB7IFxyXG4gICAgICAgICAgICAgICAgICAgIGlnbm9yZUFjdGlvbjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBlbnRyeVsxXS5kYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzOiBlbnRyeVsxXS5jbGFzc1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZW50cmllcyhtb2RlbC5saW5rcykuZm9yRWFjaChlbnRyeSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkTGluayhcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW50cnlbMV0uZnJvbU5vZGUsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeVsxXS5mcm9tRWRnZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW50cnlbMV0udG9Ob2RlLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW50cnlbMV0udG9FZGdlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7IGlnbm9yZUFjdGlvbjogdHJ1ZSB9XHJcbiAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeVsxXS5zZWxlY3RlZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFRvU2VsZWN0aW9uKFtzdGF0ZS5saW5rcy5nZXQoZW50cnlbMF0pIV0sIHsgaWdub3JlQWN0aW9uOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICAgICAgLy9lbWl0KCdtb2RlbENoYW5nZScsIG1vZGVsKTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsIHJlbmRlciBvbiBhbGwgZXhpc3RpbmcgcmVuZGVyYWJsZSBpdGVtcy5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIGRhdGEgLSBPcHRpb25hbCBkYXRhIG9iamVjdCB3LyBhbnkgcHJvcGVydGllcyB0byBleHBvc2UgdG8geW91ciByZW5kZXIgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IHJlbmRlckFsbCA9IChkYXRhOiB7IFtrZXk6c3RyaW5nXTogYW55IH0gPSB7fSkgPT4ge1xyXG4gICAgICAgIGxldCBpdGVtcyA6IEZsb3dUeXBlcy5SZW5kZXJhYmxlSXRlbVtdID0gQXJyYXkuZnJvbShzdGF0ZS5ub2Rlcy52YWx1ZXMoKSk7XHJcbiAgICAgICAgICAgIGl0ZW1zLmNvbmNhdChBcnJheS5mcm9tKHN0YXRlLmVkZ2VzLnZhbHVlcygpKSk7XHJcbiAgICAgICAgICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiByZW5kZXIoaXRlbSwgZGF0YSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbCByZW5kZXIgZm9yIGEgcGFydGljdWxhciBpdGVtLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0gaXRlbSAtIEEgcmVuZGVyYWJsZSBpdGVtLiBDdXJyZW50IHJlbmRlcmFibGUgaXRlbXMgYXJlIGl0ZW1zIG9mIHR5cGUgJ25vZGUnIG9yICdlZGdlJy5cclxuICAgICAqIEBwYXJhbSBkYXRhIC0gT3B0aW9uYWwgZGF0YSBvYmplY3Qgdy8gYW55IHByb3BlcnRpZXMgdG8gZXhwb3NlIHRvIHlvdXIgcmVuZGVyIGZ1bmN0aW9uLlxyXG4gICAgICogQHJldHVybnMgXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IHJlbmRlciA9IChpdGVtOiBGbG93VHlwZXMuUmVuZGVyYWJsZUl0ZW0sIGRhdGE6IHsgW2tleTpzdHJpbmddOiBhbnkgfSA9IHt9KSA9PiB7XHJcbiAgICAgICAgaWYgKGFwaS5vcHRzLnJlbmRlcil7XHJcbiAgICAgICAgICAgIGxldCBjYWNoZWRDb250ZW50ID0gYXBpLnJlbmRlckNhY2hlLmdldChpdGVtLmtleSk7IC8vR2V0IGFueSBjYWNoZWQgY29udGVudCBmb3IgdGhlIGl0ZW0gdy8gdGhlIGdpdmVuIGtleVxyXG4gICAgICAgICAgICBsZXQgcmVuZGVyVGFyZ2V0OiBIVE1MRWxlbWVudCB8IG51bGwgPSBudWxsLCBcclxuICAgICAgICAgICAgbmV4dENvbnRlbnQgPSBhcGkub3B0cy5yZW5kZXIoaXRlbSwgY2FjaGVkQ29udGVudCwgZGF0YSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoaXRlbS50eXBlID09PSBGbG93VHlwZXMuRmxvd0l0ZW1UeXBlLk5vZGUpe1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyVGFyZ2V0ID0gaXRlbS5jb250ZW50RWw7XHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAqIFRhcmdldCBpcyBhbiBlZGdlLCBpbnB1dCBvciBvdXRwdXRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS50eXBlID09PSBGbG93VHlwZXMuRmxvd0l0ZW1UeXBlLkVkZ2Upe1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyVGFyZ2V0ID0gaXRlbS5lbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIElmIG5ldyBjb250ZW50IHdhcyByZXR1cm5lZCwgZW1wdHkgdGhlIHRhcmdldCBlbGVtZW50LCBpbnNlcnQgYW5kIGNhY2hlIHRoZSBuZXcgY29udGVudFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaWYgKCFyZW5kZXJUYXJnZXQpIHJldHVybjtcclxuICAgICAgICAgICAgaWYgKG5leHRDb250ZW50KXtcclxuICAgICAgICAgICAgICAgIHJlbmRlclRhcmdldC5pbm5lckhUTUwgPSAnJztcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmV4dENvbnRlbnQgPT09ICdzdHJpbmcnKXtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJUYXJnZXQuaW5zZXJ0QWRqYWNlbnRIVE1MKCdhZnRlcmJlZ2luJywgbmV4dENvbnRlbnQpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJUYXJnZXQuYXBwZW5kQ2hpbGQobmV4dENvbnRlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ2FjaGUgdGhlIEhUTUwgY29udGVudFxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBhcGkucmVuZGVyQ2FjaGUuc2V0KGl0ZW0ua2V5LCByZW5kZXJUYXJnZXQuZmlyc3RFbGVtZW50Q2hpbGQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0gaXRlbSBcclxuICAgICAqL1xyXG4gICAgY29uc3QgcmVuZGVyQ29udGV4dCA9IChpdGVtOiBGbG93VHlwZXMuRmxvd0l0ZW0sIGdyYXBoWDogbnVtYmVyLCBncmFwaFk6IG51bWJlcikgPT4ge1xyXG4gICAgICAgIGxldCByZW5kZXJUYXJnZXQgPSBkb20uY29udGV4dEVsO1xyXG4gICAgICAgIGxldCBuZXh0Q29udGVudCA9IGFwaS5vcHRzLnJlbmRlckNvbnRleHQ/LihpdGVtLCBncmFwaFgsIGdyYXBoWSk7XHJcbiAgICAgICAgaWYgKG5leHRDb250ZW50KXtcclxuICAgICAgICAgICAgcmVuZGVyVGFyZ2V0LmlubmVySFRNTCA9ICcnO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG5leHRDb250ZW50ID09PSAnc3RyaW5nJyl7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJUYXJnZXQuaW5zZXJ0QWRqYWNlbnRIVE1MKCdhZnRlcmJlZ2luJywgbmV4dENvbnRlbnQpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyVGFyZ2V0LmFwcGVuZENoaWxkKG5leHRDb250ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZG9tLmNvbnRleHRFbC5zdHlsZS5sZWZ0ID0gYCR7Z3JhcGhYfXB4YDtcclxuICAgICAgICBkb20uY29udGV4dEVsLnN0eWxlLnRvcCA9IGAke2dyYXBoWX1weGA7XHJcbiAgICAgICAgZG9tLmNvbnRleHRFbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhcHBseVRyYW5zZm9ybSA9ICh0cmFuc2l0aW9uOiBib29sZWFuIHwgbnVtYmVyID0gZmFsc2UpID0+IHtcclxuICAgICAgICBpZiAodHlwZW9mIHRyYW5zaXRpb24gPT09ICdudW1iZXInIHx8IHRyYW5zaXRpb24gPT09IHRydWUpe1xyXG4gICAgICAgICAgICBkb20ucm9vdEVsLnN0eWxlLnRyYW5zaXRpb24gPSBgdHJhbnNmb3JtICR7dHlwZW9mIHRyYW5zaXRpb24gPT09ICdudW1iZXInID8gdHJhbnNpdGlvbiA6IDMwMH1tc2A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRvbS5yb290RWwuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke3RyYW5zZm9ybS54fXB4LCAke3RyYW5zZm9ybS55fXB4KSBzY2FsZSgke3RyYW5zZm9ybS5zY2FsZX0pYDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc29sdmVzIGEgc2V0IG9mIHBhZ2UgY29vcmRpbmF0ZXMgdG8gYSBwb3NpdGlvbiB3aXRoaW4gdGhlIGdyYXBoIGNvbnRhaW5lci5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIGdyYXBoWFxyXG4gICAgICogQHBhcmFtIGdyYXBoWSBcclxuICAgICAqIEByZXR1cm5zIFxyXG4gICAgICovXHJcbiAgICBjb25zdCBwYWdlVG9Db250YWluZXJQb3MgPSAoZ3JhcGhYOiBudW1iZXIsIGdyYXBoWTogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgbGV0IHggPSAoZ3JhcGhYIC0gZG9tLmNvbnRhaW5lckVsLm9mZnNldExlZnQpO1xyXG4gICAgICAgIGxldCB5ID0gKGdyYXBoWSAtIGRvbS5jb250YWluZXJFbC5vZmZzZXRUb3ApO1xyXG4gICAgICAgIHJldHVybiBbeCwgeV07XHJcbiAgICB9XHJcblxyXG4gICAvKipcclxuICAgICAqIFJlc29sdmVzIGEgc2V0IG9mIHBhZ2UgY29vcmRpbmF0ZXMgdG8gYSBwb3NpdGlvbiB3aXRoaW4gdGhlIGdyYXBoLlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0gcGFnZVggLSBUaGUgcGFnZSB4IHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gcGFnZVkgLSBUaGUgcGFnZSB5IHBvc2l0aW9uXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IHBhZ2VUb0dyYXBoUG9zID0gKHBhZ2VYOiBudW1iZXIsIHBhZ2VZOiBudW1iZXIpID0+IHtcclxuICAgICAgICBsZXQgeCA9IChNYXRoLmFicyh0cmFuc2Zvcm0ueCkgKyAocGFnZVggLSBkb20uY29udGFpbmVyRWwub2Zmc2V0TGVmdCkpIC8gdHJhbnNmb3JtLnNjYWxlO1xyXG4gICAgICAgIGxldCB5ID0gKE1hdGguYWJzKHRyYW5zZm9ybS55KSArIChwYWdlWSAtIGRvbS5jb250YWluZXJFbC5vZmZzZXRUb3ApKSAvIHRyYW5zZm9ybS5zY2FsZTtcclxuICAgICAgICByZXR1cm4gW3gsIHldO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNsYXRlIG9yIHpvb20gdG8gYW55IGNvb3JkaW5hdGVzIHdpdGhpbiB0aGUgZ3JhcGguXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gT3B0aW9ucyBvYmplY3RcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLnggLSBOZXcgeCBjb29yZGluYXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0cy55IC0gTmV3IHkgY29vcmRpbmF0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdHMuc2NhbGUgLSBQcm92aWRlIGEgbmV3IHNjYWxlIGJldHdlZW4gdGhlIGNvbmZpZ3VyZWQgbWluL21heC4gTXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlci4gT3ZlcnJpZGVzIHRoZSBgc2NhbGVTdGVwc2Agb3B0aW9uLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdHMuc2NhbGVTdGVwIC0gQWx0ZXJuYXRpdmUgem9vbSBtZXRob2QuIFByb3ZpZGUgdGhlIG51bWJlciBvZiBzdGVwcyAocG9zaXRpdmUgb3IgbmVnYXRpdmUpIHRvIHpvb20uIFRoZVxyXG4gICAgICogc2l6ZSBvZiB0aGUgc3RlcCBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBgcGFuem9vbS5zY2FsZVN0ZXBgIGNvbmZpZ3VyYXRpb24gcHJvcGVydHkuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlciB8IGJvb2xlYW59IG9wdHMudHJhbnNpdGlvbiAtIFBhc3MgYGZhbHNlYCB0byB1c2Ugbm8gc21vb3RoIHRyYW5zaXRpb24sIGB0cnVlYCB0byB1c2UgdGhlIGRlZmF1bHQgdHJhbnNpdGlvbiBgMzAwbXNgLCBvciBhIGN1c3RvbVxyXG4gICAgICogdHJhbnNpdGlvbiB0aW1lIGluIG1pbGxpc2Vjb25kcy5cclxuICAgICAqIEByZXR1cm5zIFxyXG4gICAgICovXHJcbiAgICBjb25zdCBzZXRWaWV3ID0gKG9wdHM6IEZsb3dUeXBlcy5TZXRWaWV3T3B0aW9ucykgPT4ge1xyXG4gICAgICAgIGlmIChhcGkuaXNMb2NrZWQoKSkgcmV0dXJuOyAvL0lnbm9yZSBzZXRWaWV3IGlmIG91ciBjb250cm9sIGlzIGxvY2tlZFxyXG5cclxuICAgICAgICBsZXQgcm9vdFJlY3QgPSBkb20ucm9vdEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIGxldCBzY2FsZSA9IHRyYW5zZm9ybS5zY2FsZTtcclxuICAgICAgICBsZXQgbWluU2NhbGUgPSBhcGkub3B0cy5wYW56b29tPy5taW5TY2FsZSB8fCAuMDU7XHJcbiAgICAgICAgbGV0IG1heFNjYWxlID0gYXBpLm9wdHMucGFuem9vbT8ubWF4U2NhbGUgfHwgMjtcclxuICAgICAgICBsZXQgc3RlcEluY3JlbWVudCA9IGFwaS5vcHRzLnBhbnpvb20/LnNjYWxlU3RlcCB8fCAuMjU7XHJcbiAgICAgICAgbGV0IHNjYWxlUGFnZVggPSBvcHRzLnggPz8gdHJhbnNmb3JtLng7IC8vR2V0IHBhcmFtIGNvb3JkaW5hdGVzIG9yIHVzZSBjdXJyZW50IHRyYW5zZm9ybSB2YWx1ZXNcclxuICAgICAgICBsZXQgc2NhbGVQYWdlWSA9IG9wdHMueSA/PyB0cmFuc2Zvcm0ueTsgXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCBvdXIgbmV4dCBzY2FsZSBlaXRoZXIgYnkgdGhlIGdpdmVuIGV4cGxpY2l0IHNjYWxlIG9yIGJ5IHNjYWxlIHN0ZXAuXHJcbiAgICAgICAgICogSWYgYm90aCBhcmUgcHJvdmlkZWQsIHRoZSBleHBsaWNpdCBzY2FsZSBpcyB1c2VkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGxldCBuZXh0U2NhbGU6IG51bWJlciA9IHRyYW5zZm9ybS5zY2FsZTtcclxuICAgICAgICBpZiAob3B0cy5zY2FsZSl7XHJcbiAgICAgICAgICAgIG5leHRTY2FsZSA9IG9wdHMuc2NhbGU7XHJcbiAgICAgICAgfSBlbHNlIGlmIChvcHRzLnNjYWxlU3RlcHMpIHtcclxuICAgICAgICAgICAgbmV4dFNjYWxlID0gcGFyc2VGbG9hdCgoc2NhbGUgKyAob3B0cy5zY2FsZVN0ZXBzICogc3RlcEluY3JlbWVudCkpLnRvRml4ZWQoMikpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9pZiAobmV4dFNjYWxlIDwgbWluU2NhbGUgfHwgbmV4dFNjYWxlID4gbWF4U2NhbGUpIHJldHVybjtcclxuICAgICAgICBpZiAobmV4dFNjYWxlIDwgbWluU2NhbGUgfHwgbmV4dFNjYWxlID4gbWF4U2NhbGUpIG5leHRTY2FsZSA9IHRyYW5zZm9ybS5zY2FsZTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IHggYW5kIHkgYWNjb3VudGluZyBmb3IgbmV3IHNjYWxlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbGV0IG5leHRYID0gLXNjYWxlUGFnZVggKiBuZXh0U2NhbGU7IC8vQXBwbHkgbmV3IHNjYWxlIHRvIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgbGV0IG5leHRZID0gLXNjYWxlUGFnZVkgKiBuZXh0U2NhbGU7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVzZSBvdXIgbmV4dCBzY2FsZSB0byBjYWxjdWxhdGUgd2hhdCB0aGUgbWF4IHggKGxlZnQpIGFuZCB5ICh0b3ApIHBvc2l0aW9uIHdpbGwgYmUuXHJcbiAgICAgICAgICovIFxyXG4gICAgICAgIGxldCBjb250YWluZXJSZWN0ID0gZG9tLmNvbnRhaW5lckVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIGxldCBtYXhYID0gcm9vdFJlY3Qud2lkdGggLSBjb250YWluZXJSZWN0LndpZHRoO1xyXG4gICAgICAgIGxldCBtYXhZID0gcm9vdFJlY3QuaGVpZ2h0IC0gY29udGFpbmVyUmVjdC5oZWlnaHQ7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuZm9yY2UgbWF4IHgveSBwb3NpdGlvbnMuIFxyXG4gICAgICAgICAqLyBcclxuICAgICAgICBpZiAobmV4dFggPiAwKSBuZXh0WCA9IDA7XHJcbiAgICAgICAgaWYgKG5leHRZID4gMCkgbmV4dFkgPSAwO1xyXG4gICAgICAgIGlmIChuZXh0WCA8IC1tYXhYKSBuZXh0WCA9IC1tYXhYO1xyXG4gICAgICAgIGlmIChuZXh0WSA8IC1tYXhZKSBuZXh0WSA9IC1tYXhZO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGUgb3VyIHZhbHVlcyBhbmQgYXBwbHlcclxuICAgICAgICAgKi8gXHJcbiAgICAgICAgYXBpLnN0YXRlLnRyYW5zZm9ybS5zY2FsZSA9IG5leHRTY2FsZTtcclxuICAgICAgICBhcGkuc3RhdGUudHJhbnNmb3JtLnggPSBuZXh0WDtcclxuICAgICAgICBhcGkuc3RhdGUudHJhbnNmb3JtLnkgPSBuZXh0WTtcclxuXHJcbiAgICAgICAgYXBwbHlUcmFuc2Zvcm0ob3B0cy50cmFuc2l0aW9uID8/IHRydWUpO1xyXG5cclxuICAgICAgICBpZiAoIW9wdHMuc3VwcHJlc3NFdmVudCkgZW1pdCgndHJhbnNmb3JtJywgeyAuLi50cmFuc2Zvcm0gfSk7XHJcbiAgICAgICAgLy8gaWYgKCFvcHRzLmlnbm9yZUFjdGlvbikgcmVjb3JkQWN0aW9uKCd6b29tJyk7XHJcblxyXG4gICAgICAgIC8vVE9ETzogdHJhbnNmb3JtIGFjdGlvbiBoZXJlP1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTW92ZXMgdGhlIHZpZXdwb3J0IHgveSB0byBmb2N1cyBvbiBhIHBhcnRpY3VsYXIgbm9kZS5cclxuICAgICAqIFxyXG4gICAgICogQHBhcmFtIG5vZGUgLSBUaGUgTm9kZSBpdGVtIHRvIGZvY3VzXHJcbiAgICAgKiBAcGFyYW0gc2NhbGUgLSBPcHRpb25hbGx5IHNldCB0aGUgbmV3IHNjYWxlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGZvY3VzTm9kZSA9IChub2RlOiBGbG93VHlwZXMuTm9kZSwgc2NhbGU/OiBudW1iZXIpID0+IHtcclxuICAgICAgICBsZXQgY29udGFpbmVyUmVjdCA9IGRvbS5jb250YWluZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICBsZXQgbm9kZVJlY3QgPSBub2RlLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIGxldCB4MSA9IG5vZGUueDtcclxuICAgICAgICBsZXQgeTEgPSBub2RlLnk7XHJcbiAgICAgICAgbGV0IHcxID0gbm9kZVJlY3Qud2lkdGggLyB0cmFuc2Zvcm0uc2NhbGU7XHJcbiAgICAgICAgbGV0IGgxID0gbm9kZVJlY3QuaGVpZ2h0IC8gdHJhbnNmb3JtLnNjYWxlO1xyXG4gICAgICAgIGxldCB3MiA9IGNvbnRhaW5lclJlY3Qud2lkdGggLyB0cmFuc2Zvcm0uc2NhbGU7XHJcbiAgICAgICAgbGV0IGgyID0gY29udGFpbmVyUmVjdC5oZWlnaHQgLyB0cmFuc2Zvcm0uc2NhbGU7XHJcbiAgICAgICAgbGV0IHgyID0geDEgKyAoKHcxIC0gdzIpIC8gMik7XHJcbiAgICAgICAgbGV0IHkyID0geTEgKyAoKGgxIC0gaDIpIC8gMik7XHJcbiAgICAgICAgc2V0Vmlldyh7IHg6IHgyLCB5OiB5Miwgc2NhbGU6IHNjYWxlID8/IHRyYW5zZm9ybS5zY2FsZSB9KTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBnZXREb20gPSAoKSA9PiBhcGkuZG9tO1xyXG4gICAgY29uc3QgZ2V0Tm9kZXMgPSAoKSA9PiBuZXcgTWFwKHN0YXRlLm5vZGVzKTtcclxuICAgIGNvbnN0IGdldEVkZ2VzID0gKCkgPT4gbmV3IE1hcChzdGF0ZS5lZGdlcyk7XHJcbiAgICBjb25zdCBnZXRMaW5rcyA9ICgpID0+IG5ldyBNYXAoc3RhdGUubGlua3MpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBiYWNrZ3JvdW5kLiBVc2UgdGhlIGJhY2tncm91bmQgaGVscGVyIHRvIGdlbmVyYXRlIGFuIFNWRyBgZ3JpZGAgb3IgYGRvdHNgIGJhY2tncm91bmQuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSBodG1sIC0gVGhlIGh0bWwgZm9yIHRoZSBiYWNrZ3JvdW5kXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IHNldEJhY2tncm91bmQgPSAoaHRtbDogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgZG9tLmJnRWwuaW5uZXJIVE1MID0gaHRtbDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlY29yZEFjdGlvbixcclxuICAgICAgICB1bmRvLFxyXG4gICAgICAgIHJlZG8sXHJcbiAgICAgICAgYWRkRWRnZSxcclxuICAgICAgICByZW1vdmVFZGdlLFxyXG4gICAgICAgIGFkZE5vZGUsXHJcbiAgICAgICAgcmVtb3ZlTm9kZSxcclxuICAgICAgICAvL3VwZGF0ZU5vZGVUZW1wbGF0ZSxcclxuICAgICAgICBhZGRMaW5rLFxyXG4gICAgICAgIHJlbW92ZUxpbmssXHJcbiAgICAgICAgaXNMaW5rVmFsaWQsXHJcbiAgICAgICAgaXNTZWxlY3RlZCxcclxuICAgICAgICBzZXRTZWxlY3RlZCxcclxuICAgICAgICBzZXRQcmVzZWxlY3RlZCxcclxuICAgICAgICBhZGRUb1NlbGVjdGlvbixcclxuICAgICAgICByZW1vdmVGcm9tU2VsZWN0aW9uLFxyXG4gICAgICAgIHJlbW92ZUl0ZW0sXHJcbiAgICAgICAgcmVtb3ZlU2VsZWN0ZWRJdGVtcyxcclxuICAgICAgICBvcGVuQ29udGV4dE1lbnUsXHJcbiAgICAgICAgY2xvc2VDb250ZXh0TWVudSxcclxuICAgICAgICBnZXRJdGVtLFxyXG4gICAgICAgIHJlc29sdmVJdGVtLFxyXG4gICAgICAgIGNsZWFyLFxyXG4gICAgICAgIGdldE1vZGVsLFxyXG4gICAgICAgIHNldE1vZGVsLFxyXG4gICAgICAgIGdldERvbSxcclxuICAgICAgICBnZXRTdGF0ZSxcclxuICAgICAgICBnZXROb2RlcyxcclxuICAgICAgICBnZXRFZGdlcyxcclxuICAgICAgICBnZXRMaW5rcyxcclxuICAgICAgICBldmVudEluR3JhcGgsXHJcbiAgICAgICAgcGFnZVRvQ29udGFpbmVyUG9zLFxyXG4gICAgICAgIHBhZ2VUb0dyYXBoUG9zLFxyXG4gICAgICAgIHNldFZpZXcsXHJcbiAgICAgICAgZm9jdXNOb2RlLFxyXG4gICAgICAgIHJlbmRlcixcclxuICAgICAgICByZW5kZXJBbGwsXHJcbiAgICAgICAgZ2V0Q29tcG9zaXRlU2NhbGUsXHJcbiAgICAgICAgc2V0QmFja2dyb3VuZFxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgeyBnZXRQdWJsaWNJbnRlcmZhY2UsIEZsb3dNZXRob2RzIH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/methods.ts\n");

/***/ }),

/***/ "./src/systems/context.ts":
/*!********************************!*\
  !*** ./src/systems/context.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\r\n * Drag node tool\r\n */\nfunction MXFlowContextTool(api, methods, interactions) {\n  const handleDown = e => {\n    if (e.source.target && e.source.target instanceof HTMLElement) {\n      if (e.source.target === api.dom.contextEl || api.dom.contextEl.contains(e.source.target)) return;\n      methods.closeContextMenu();\n    }\n  };\n\n  const handleWheel = () => methods.closeContextMenu();\n\n  const handleContext = e => {\n    if (e.item) {\n      let [x, y] = methods.pageToContainerPos(e.source.pageX, e.source.pageY);\n      methods.openContextMenu(x, y, e.item);\n    }\n  };\n\n  interactions.on('contextmenu', handleContext);\n  interactions.on('down', handleDown);\n  interactions.on('wheel', handleWheel);\n\n  const dispose = () => {\n    interactions.removeListener('contextmenu', handleContext);\n    interactions.removeListener('down', handleDown);\n    interactions.removeListener('wheel', handleWheel);\n  };\n\n  return {\n    name: 'context',\n    dispose\n  };\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MXFlowContextTool);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3lzdGVtcy9jb250ZXh0LnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFJQTs7QUFFRztBQUNILFNBQVMsaUJBQVQsQ0FBMkIsR0FBM0IsRUFBK0MsT0FBL0MsRUFBK0YsWUFBL0YsRUFBNkk7QUFFekksUUFBTSxVQUFVLEdBQUksQ0FBRCxJQUFvQztBQUNuRCxRQUFJLENBQUMsQ0FBQyxNQUFGLENBQVMsTUFBVCxJQUFtQixDQUFDLENBQUMsTUFBRixDQUFTLE1BQVQsWUFBMkIsV0FBbEQsRUFBOEQ7QUFDMUQsVUFBSSxDQUFDLENBQUMsTUFBRixDQUFTLE1BQVQsS0FBb0IsR0FBRyxDQUFDLEdBQUosQ0FBUSxTQUE1QixJQUF5QyxHQUFHLENBQUMsR0FBSixDQUFRLFNBQVIsQ0FBa0IsUUFBbEIsQ0FBMkIsQ0FBQyxDQUFDLE1BQUYsQ0FBUyxNQUFwQyxDQUE3QyxFQUEwRjtBQUMxRixhQUFPLENBQUMsZ0JBQVI7QUFDSDtBQUNKLEdBTEQ7O0FBT0EsUUFBTSxXQUFXLEdBQUcsTUFBTyxPQUFPLENBQUMsZ0JBQVIsRUFBM0I7O0FBQ0EsUUFBTSxhQUFhLEdBQUksQ0FBRCxJQUF3QztBQUMxRCxRQUFJLENBQUMsQ0FBQyxJQUFOLEVBQVc7QUFDUCxVQUFJLENBQUMsQ0FBRCxFQUFHLENBQUgsSUFBUSxPQUFPLENBQUMsa0JBQVIsQ0FBMkIsQ0FBQyxDQUFDLE1BQUYsQ0FBUyxLQUFwQyxFQUEyQyxDQUFDLENBQUMsTUFBRixDQUFTLEtBQXBELENBQVo7QUFDQSxhQUFPLENBQUMsZUFBUixDQUF3QixDQUF4QixFQUEyQixDQUEzQixFQUE4QixDQUFDLENBQUMsSUFBaEM7QUFDSDtBQUNKLEdBTEQ7O0FBT0EsY0FBWSxDQUFDLEVBQWIsQ0FBZ0IsYUFBaEIsRUFBK0IsYUFBL0I7QUFDQSxjQUFZLENBQUMsRUFBYixDQUFnQixNQUFoQixFQUF3QixVQUF4QjtBQUNBLGNBQVksQ0FBQyxFQUFiLENBQWdCLE9BQWhCLEVBQXlCLFdBQXpCOztBQUNBLFFBQU0sT0FBTyxHQUFHLE1BQUs7QUFDakIsZ0JBQVksQ0FBQyxjQUFiLENBQTRCLGFBQTVCLEVBQTJDLGFBQTNDO0FBQ0EsZ0JBQVksQ0FBQyxjQUFiLENBQTRCLE1BQTVCLEVBQW9DLFVBQXBDO0FBQ0EsZ0JBQVksQ0FBQyxjQUFiLENBQTRCLE9BQTVCLEVBQXFDLFdBQXJDO0FBQ0gsR0FKRDs7QUFNQSxTQUFlO0FBQ1gsUUFBSSxFQUFFLFNBREs7QUFFWDtBQUZXLEdBQWY7QUFJSDs7QUFFRCxpRUFBZSxpQkFBZiIsInNvdXJjZXMiOlsid2VicGFjazovL214Zmxvdy8uL3NyYy9zeXN0ZW1zL2NvbnRleHQudHM/M2U3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBJbnRlcmFjdFR5cGVzIGZyb20gJ3R5cGVzL2ludGVyYWN0LnR5cGVzJztcclxuaW1wb3J0ICogYXMgRmxvd1R5cGVzIGZyb20gJ3R5cGVzL2Zsb3cudHlwZXMudjInO1xyXG5pbXBvcnQgeyBnZXRQdWJsaWNJbnRlcmZhY2UgfSBmcm9tICcuLi9tZXRob2RzJztcclxuXHJcbi8qKlxyXG4gKiBEcmFnIG5vZGUgdG9vbFxyXG4gKi9cclxuZnVuY3Rpb24gTVhGbG93Q29udGV4dFRvb2woYXBpOiBGbG93VHlwZXMuQXBpLCBtZXRob2RzOiBSZXR1cm5UeXBlPHR5cGVvZiBnZXRQdWJsaWNJbnRlcmZhY2U+LCBpbnRlcmFjdGlvbnM6IEludGVyYWN0VHlwZXMuSW50ZXJhY3Rpb25FbWl0dGVyKSA6IEZsb3dUeXBlcy5BY3Rpb25IYW5kbGVyIHtcclxuICAgIFxyXG4gICAgY29uc3QgaGFuZGxlRG93biA9IChlOiBJbnRlcmFjdFR5cGVzLk1YUG9pbnRlckV2ZW50KSA9PiB7XHJcbiAgICAgICAgaWYgKGUuc291cmNlLnRhcmdldCAmJiBlLnNvdXJjZS50YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCl7XHJcbiAgICAgICAgICAgIGlmIChlLnNvdXJjZS50YXJnZXQgPT09IGFwaS5kb20uY29udGV4dEVsIHx8IGFwaS5kb20uY29udGV4dEVsLmNvbnRhaW5zKGUuc291cmNlLnRhcmdldCkpIHJldHVybjtcclxuICAgICAgICAgICAgbWV0aG9kcy5jbG9zZUNvbnRleHRNZW51KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBoYW5kbGVXaGVlbCA9ICgpID0+ICBtZXRob2RzLmNsb3NlQ29udGV4dE1lbnUoKTtcclxuICAgIGNvbnN0IGhhbmRsZUNvbnRleHQgPSAoZTogSW50ZXJhY3RUeXBlcy5NWENvbnRleHRNZW51RXZlbnQpID0+IHtcclxuICAgICAgICBpZiAoZS5pdGVtKXtcclxuICAgICAgICAgICAgbGV0IFt4LHldID0gbWV0aG9kcy5wYWdlVG9Db250YWluZXJQb3MoZS5zb3VyY2UucGFnZVgsIGUuc291cmNlLnBhZ2VZKTtcclxuICAgICAgICAgICAgbWV0aG9kcy5vcGVuQ29udGV4dE1lbnUoeCwgeSwgZS5pdGVtKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaW50ZXJhY3Rpb25zLm9uKCdjb250ZXh0bWVudScsIGhhbmRsZUNvbnRleHQpO1xyXG4gICAgaW50ZXJhY3Rpb25zLm9uKCdkb3duJywgaGFuZGxlRG93bik7XHJcbiAgICBpbnRlcmFjdGlvbnMub24oJ3doZWVsJywgaGFuZGxlV2hlZWwpO1xyXG4gICAgY29uc3QgZGlzcG9zZSA9ICgpID0+IHtcclxuICAgICAgICBpbnRlcmFjdGlvbnMucmVtb3ZlTGlzdGVuZXIoJ2NvbnRleHRtZW51JywgaGFuZGxlQ29udGV4dCk7XHJcbiAgICAgICAgaW50ZXJhY3Rpb25zLnJlbW92ZUxpc3RlbmVyKCdkb3duJywgaGFuZGxlRG93bik7XHJcbiAgICAgICAgaW50ZXJhY3Rpb25zLnJlbW92ZUxpc3RlbmVyKCd3aGVlbCcsIGhhbmRsZVdoZWVsKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gPGNvbnN0PiB7XHJcbiAgICAgICAgbmFtZTogJ2NvbnRleHQnLFxyXG4gICAgICAgIGRpc3Bvc2VcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTVhGbG93Q29udGV4dFRvb2w7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/systems/context.ts\n");

/***/ }),

/***/ "./src/systems/drag.ts":
/*!*****************************!*\
  !*** ./src/systems/drag.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! types/flow.types.v2 */ \"./src/types/flow.types.v2.ts\");\n/* harmony import */ var _flow_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../flow-util */ \"./src/flow-util.ts\");\n\n\n/**\r\n * Drag node tool\r\n */\n\nfunction MXFlowDragTool(api, methods, interactions) {\n  let state = api.state;\n  let items = [];\n  let gridX = api.opts.drag.gridX || 0;\n  let gridY = api.opts.drag.gridY || 0;\n  let deltaChanged = false;\n\n  const update = api => {\n    state = api.state;\n    gridX = api.opts.drag.gridX || 0;\n    gridY = api.opts.drag.gridY || 0;\n  };\n\n  const isValid = (e, item) => {\n    return !interactions.isModActive('multiSelectModifier') && state.selected.size !== 0 && item && item.type === 'node' && (e.pointerType !== 'mouse' || e.button === api.opts.controls.selectButton);\n  };\n\n  const applyDrag = function (e) {\n    let finalize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let deltaX = gridX !== 0 ? gridX * Math.floor(e.scaledDeltaX / gridX) : e.scaledDeltaX;\n    let deltaY = gridY !== 0 ? gridY * Math.floor(e.scaledDeltaY / gridY) : e.scaledDeltaY; //Track when delta changes. We don't want to record any action when grid dragging unless an item actually moved\n\n    if (!deltaChanged && (deltaX !== 0 || deltaY !== 0)) {\n      deltaChanged = true;\n    }\n\n    items.forEach(item => {\n      /**\r\n       * Calculate an item's offset from the grid and factor it into the deltas.\r\n       * This prevents each item from being on a \"different grid\" if the grid was\r\n       * activated after some items were already dragged freely without it.\r\n       *\r\n       * TODO: Make this optionally the bounding box offset?\r\n       */\n      let gridOffsetX = gridX !== 0 ? item.x % gridX : 0;\n      let gridOffsetY = gridY !== 0 ? item.y % gridY : 0;\n      /**\r\n       * Set deltas and apply new position\r\n       */\n\n      if (finalize) {\n        let finalX = item.x + (deltaX - gridOffsetX);\n        let finalY = item.y + (deltaY - gridOffsetY);\n        item.x = finalX;\n        item.y = finalY;\n        item.deltaX = 0;\n        item.deltaY = 0;\n      } else {\n        item.deltaX = deltaX - gridOffsetX;\n        item.deltaY = deltaY - gridOffsetY;\n      }\n\n      _flow_util__WEBPACK_IMPORTED_MODULE_1__.applyNodePosition(item);\n    });\n    _flow_util__WEBPACK_IMPORTED_MODULE_1__.applyAllLinkPositions(api);\n  };\n\n  const handleDragStart = e => {\n    let item = methods.resolveItem(e.source);\n\n    if (isValid(e.source, item)) {\n      items = Array.from(state.selected.values()).filter(item => item.type === types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowItemType.Node);\n      interactions.on('drag', handleDrag);\n      interactions.on('dragend', handleDragEnd);\n      deltaChanged = false;\n      applyDrag(e);\n    }\n  };\n\n  const handleDrag = e => {\n    applyDrag(e);\n  };\n\n  const handleDragEnd = e => {\n    applyDrag(e, true);\n    items = [];\n    interactions.removeListener('drag', handleDrag);\n    interactions.removeListener('dragend', handleDragEnd);\n    /**\r\n     * If our deltas actually changed during this drag (may not have if grid is enabled),\r\n     * record our drag action\r\n     */\n\n    if (deltaChanged) {\n      methods.recordAction(types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.ActionTypes.DRAG);\n    }\n  };\n\n  interactions.on('dragstart', handleDragStart);\n\n  const dispose = () => {\n    interactions.removeListener('dragstart', handleDragStart);\n    interactions.removeListener('drag', handleDrag);\n    interactions.removeListener('dragend', handleDragEnd);\n  };\n\n  return {\n    name: 'drag',\n    update,\n    dispose\n  };\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MXFlowDragTool);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDLEVBQWIsQ0FBZ0IsV0FBaEIsRUFBNkIsZUFBN0I7O0FBQ0EsUUFBTSxPQUFPLEdBQUcsTUFBSztBQUNqQixnQkFBWSxDQUFDLGNBQWIsQ0FBNEIsV0FBNUIsRUFBeUMsZUFBekM7QUFDQSxnQkFBWSxDQUFDLGNBQWIsQ0FBNEIsTUFBNUIsRUFBb0MsVUFBcEM7QUFDQSxnQkFBWSxDQUFDLGNBQWIsQ0FBNEIsU0FBNUIsRUFBdUMsYUFBdkM7QUFDSCxHQUpEOztBQU1BLFNBQWU7QUFDWCxRQUFJLEVBQUUsTUFESztBQUVYLFVBRlc7QUFHWDtBQUhXLEdBQWY7QUFLSDs7QUFFRCxpRUFBZSxjQUFmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXhmbG93Ly4vc3JjL3N5c3RlbXMvZHJhZy50cz9kMzY4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEludGVyYWN0VHlwZXMgZnJvbSAndHlwZXMvaW50ZXJhY3QudHlwZXMnO1xyXG5pbXBvcnQgKiBhcyBGbG93VHlwZXMgZnJvbSAndHlwZXMvZmxvdy50eXBlcy52Mic7XHJcbmltcG9ydCAqIGFzIEZsb3dVdGlsIGZyb20gJy4uL2Zsb3ctdXRpbCc7XHJcblxyXG4vKipcclxuICogRHJhZyBub2RlIHRvb2xcclxuICovXHJcbmZ1bmN0aW9uIE1YRmxvd0RyYWdUb29sKGFwaTogRmxvd1R5cGVzLkFwaSwgbWV0aG9kczogRmxvd1R5cGVzLk1ldGhvZHMsIGludGVyYWN0aW9uczogSW50ZXJhY3RUeXBlcy5JbnRlcmFjdGlvbkVtaXR0ZXIpIDogRmxvd1R5cGVzLkFjdGlvbkhhbmRsZXIge1xyXG4gICAgbGV0IHN0YXRlID0gYXBpLnN0YXRlO1xyXG4gICAgbGV0IGl0ZW1zOiBGbG93VHlwZXMuTm9kZVtdID0gW107XHJcbiAgICBsZXQgZ3JpZFggPSBhcGkub3B0cy5kcmFnLmdyaWRYIHx8IDA7XHJcbiAgICBsZXQgZ3JpZFkgPSBhcGkub3B0cy5kcmFnLmdyaWRZIHx8IDA7XHJcbiAgICBsZXQgZGVsdGFDaGFuZ2VkID0gZmFsc2U7XHJcblxyXG4gICAgY29uc3QgdXBkYXRlID0gKGFwaTogRmxvd1R5cGVzLkFwaSkgPT4ge1xyXG4gICAgICAgIHN0YXRlID0gYXBpLnN0YXRlO1xyXG4gICAgICAgIGdyaWRYID0gYXBpLm9wdHMuZHJhZy5ncmlkWCB8fCAwO1xyXG4gICAgICAgIGdyaWRZID0gYXBpLm9wdHMuZHJhZy5ncmlkWSB8fCAwO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGlzVmFsaWQgPSAoZTogUG9pbnRlckV2ZW50LCBpdGVtPzogRmxvd1R5cGVzLkZsb3dJdGVtKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuICFpbnRlcmFjdGlvbnMuaXNNb2RBY3RpdmUoJ211bHRpU2VsZWN0TW9kaWZpZXInKSAmJiBcclxuICAgICAgICAgICAgICAgIHN0YXRlLnNlbGVjdGVkLnNpemUgIT09IDAgJiYgXHJcbiAgICAgICAgICAgICAgICBpdGVtICYmIGl0ZW0udHlwZSA9PT0gJ25vZGUnICYmIFxyXG4gICAgICAgICAgICAgICAgKGUucG9pbnRlclR5cGUgIT09ICdtb3VzZScgfHwgZS5idXR0b24gPT09IGFwaS5vcHRzLmNvbnRyb2xzLnNlbGVjdEJ1dHRvbik7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYXBwbHlEcmFnID0gKGU6IEludGVyYWN0VHlwZXMuTVhEcmFnRXZlbnQsIGZpbmFsaXplOiBib29sZWFuID0gZmFsc2UpID0+IHtcclxuICAgICAgICBsZXQgZGVsdGFYOiBudW1iZXIgPSBncmlkWCAhPT0gMCA/IChncmlkWCAqIE1hdGguZmxvb3IoZS5zY2FsZWREZWx0YVggLyBncmlkWCkpIDogZS5zY2FsZWREZWx0YVg7XHJcbiAgICAgICAgbGV0IGRlbHRhWTogbnVtYmVyID0gZ3JpZFkgIT09IDAgPyAoZ3JpZFkgKiBNYXRoLmZsb29yKGUuc2NhbGVkRGVsdGFZIC8gZ3JpZFkpKSA6IGUuc2NhbGVkRGVsdGFZO1xyXG5cclxuICAgICAgICAvL1RyYWNrIHdoZW4gZGVsdGEgY2hhbmdlcy4gV2UgZG9uJ3Qgd2FudCB0byByZWNvcmQgYW55IGFjdGlvbiB3aGVuIGdyaWQgZHJhZ2dpbmcgdW5sZXNzIGFuIGl0ZW0gYWN0dWFsbHkgbW92ZWRcclxuICAgICAgICBpZiAoIWRlbHRhQ2hhbmdlZCAmJiAoZGVsdGFYICE9PSAwIHx8IGRlbHRhWSAhPT0gMCkpe1xyXG4gICAgICAgICAgICBkZWx0YUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIENhbGN1bGF0ZSBhbiBpdGVtJ3Mgb2Zmc2V0IGZyb20gdGhlIGdyaWQgYW5kIGZhY3RvciBpdCBpbnRvIHRoZSBkZWx0YXMuIFxyXG4gICAgICAgICAgICAgKiBUaGlzIHByZXZlbnRzIGVhY2ggaXRlbSBmcm9tIGJlaW5nIG9uIGEgXCJkaWZmZXJlbnQgZ3JpZFwiIGlmIHRoZSBncmlkIHdhc1xyXG4gICAgICAgICAgICAgKiBhY3RpdmF0ZWQgYWZ0ZXIgc29tZSBpdGVtcyB3ZXJlIGFscmVhZHkgZHJhZ2dlZCBmcmVlbHkgd2l0aG91dCBpdC5cclxuICAgICAgICAgICAgICogXHJcbiAgICAgICAgICAgICAqIFRPRE86IE1ha2UgdGhpcyBvcHRpb25hbGx5IHRoZSBib3VuZGluZyBib3ggb2Zmc2V0P1xyXG4gICAgICAgICAgICAgKi8gXHJcbiAgICAgICAgICAgIGxldCBncmlkT2Zmc2V0WCA9IGdyaWRYICE9PSAwID8gaXRlbS54ICUgZ3JpZFggOiAwO1xyXG4gICAgICAgICAgICBsZXQgZ3JpZE9mZnNldFkgPSBncmlkWSAhPT0gMCA/IGl0ZW0ueSAlIGdyaWRZIDogMDtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldCBkZWx0YXMgYW5kIGFwcGx5IG5ldyBwb3NpdGlvblxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaWYgKGZpbmFsaXplKXtcclxuICAgICAgICAgICAgICAgIGxldCBmaW5hbFggPSBpdGVtLnggKyAoZGVsdGFYIC0gZ3JpZE9mZnNldFgpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGZpbmFsWSA9IGl0ZW0ueSArIChkZWx0YVkgLSBncmlkT2Zmc2V0WSk7XHJcbiAgICAgICAgICAgICAgICBpdGVtLnggPSBmaW5hbFg7XHJcbiAgICAgICAgICAgICAgICBpdGVtLnkgPSBmaW5hbFk7XHJcbiAgICAgICAgICAgICAgICBpdGVtLmRlbHRhWCA9IDA7XHJcbiAgICAgICAgICAgICAgICBpdGVtLmRlbHRhWSA9IDA7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtLmRlbHRhWCA9IGRlbHRhWCAtIGdyaWRPZmZzZXRYO1xyXG4gICAgICAgICAgICAgICAgaXRlbS5kZWx0YVkgPSBkZWx0YVkgLSBncmlkT2Zmc2V0WTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgRmxvd1V0aWwuYXBwbHlOb2RlUG9zaXRpb24oaXRlbSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICBcclxuICAgICAgICBGbG93VXRpbC5hcHBseUFsbExpbmtQb3NpdGlvbnMoYXBpKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBoYW5kbGVEcmFnU3RhcnQgPSAoZTogSW50ZXJhY3RUeXBlcy5NWERyYWdFdmVudCkgPT4ge1xyXG4gICAgICAgIGxldCBpdGVtID0gbWV0aG9kcy5yZXNvbHZlSXRlbShlLnNvdXJjZSk7XHJcbiAgICAgICAgaWYgKGlzVmFsaWQoZS5zb3VyY2UsIGl0ZW0pKXtcclxuICAgICAgICAgICAgaXRlbXMgPSA8Rmxvd1R5cGVzLk5vZGVbXT4gQXJyYXkuZnJvbShzdGF0ZS5zZWxlY3RlZC52YWx1ZXMoKSlcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLnR5cGUgPT09IEZsb3dUeXBlcy5GbG93SXRlbVR5cGUuTm9kZSk7XHJcblxyXG4gICAgICAgICAgICBpbnRlcmFjdGlvbnMub24oJ2RyYWcnLCBoYW5kbGVEcmFnKTtcclxuICAgICAgICAgICAgaW50ZXJhY3Rpb25zLm9uKCdkcmFnZW5kJywgaGFuZGxlRHJhZ0VuZCk7XHJcblxyXG4gICAgICAgICAgICBkZWx0YUNoYW5nZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgYXBwbHlEcmFnKGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBoYW5kbGVEcmFnID0gKGU6IEludGVyYWN0VHlwZXMuTVhEcmFnRXZlbnQpID0+IHtcclxuICAgICAgICBhcHBseURyYWcoZSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaGFuZGxlRHJhZ0VuZCA9IChlOiBJbnRlcmFjdFR5cGVzLk1YRHJhZ0V2ZW50KSA9PiB7XHJcbiAgICAgICAgYXBwbHlEcmFnKGUsIHRydWUpO1xyXG4gICAgICAgIGl0ZW1zID0gW107XHJcbiAgICAgICAgaW50ZXJhY3Rpb25zLnJlbW92ZUxpc3RlbmVyKCdkcmFnJywgaGFuZGxlRHJhZyk7XHJcbiAgICAgICAgaW50ZXJhY3Rpb25zLnJlbW92ZUxpc3RlbmVyKCdkcmFnZW5kJywgaGFuZGxlRHJhZ0VuZCk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIG91ciBkZWx0YXMgYWN0dWFsbHkgY2hhbmdlZCBkdXJpbmcgdGhpcyBkcmFnIChtYXkgbm90IGhhdmUgaWYgZ3JpZCBpcyBlbmFibGVkKSxcclxuICAgICAgICAgKiByZWNvcmQgb3VyIGRyYWcgYWN0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaWYgKGRlbHRhQ2hhbmdlZCl7XHJcbiAgICAgICAgICAgIG1ldGhvZHMucmVjb3JkQWN0aW9uKEZsb3dUeXBlcy5BY3Rpb25UeXBlcy5EUkFHKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaW50ZXJhY3Rpb25zLm9uKCdkcmFnc3RhcnQnLCBoYW5kbGVEcmFnU3RhcnQpO1xyXG4gICAgY29uc3QgZGlzcG9zZSA9ICgpID0+IHtcclxuICAgICAgICBpbnRlcmFjdGlvbnMucmVtb3ZlTGlzdGVuZXIoJ2RyYWdzdGFydCcsIGhhbmRsZURyYWdTdGFydCk7XHJcbiAgICAgICAgaW50ZXJhY3Rpb25zLnJlbW92ZUxpc3RlbmVyKCdkcmFnJywgaGFuZGxlRHJhZyk7XHJcbiAgICAgICAgaW50ZXJhY3Rpb25zLnJlbW92ZUxpc3RlbmVyKCdkcmFnZW5kJywgaGFuZGxlRHJhZ0VuZCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIDxjb25zdD4ge1xyXG4gICAgICAgIG5hbWU6ICdkcmFnJyxcclxuICAgICAgICB1cGRhdGUsXHJcbiAgICAgICAgZGlzcG9zZVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBNWEZsb3dEcmFnVG9vbDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/systems/drag.ts\n");

/***/ }),

/***/ "./src/systems/lasso.ts":
/*!******************************!*\
  !*** ./src/systems/lasso.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _flow_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../flow-util */ \"./src/flow-util.ts\");\n\n/**\r\n * MXFlow tool which handles lasso selection\r\n */\n\nfunction MXFlowLassoTool(api, methods, interactions) {\n  let state = api.state;\n  let dom = api.dom;\n\n  const update = api => {\n    state = api.state;\n    dom = api.dom;\n  };\n\n  const isValid = (e, item) => {\n    if (!item || item.type !== 'graph') return; //if (interactions.isModActive('multiSelectModifier')) return;\n\n    if (api.opts.controls.lassoModifier) {\n      return e.button === api.opts.controls.lassoButton && interactions.isModActive('lassoModifier');\n    }\n\n    return e.button === api.opts.controls.lassoButton;\n  };\n\n  const handleDragStart = e => {\n    let item = methods.resolveItem(e.source);\n\n    if (isValid(e.source, item)) {\n      dom.lassoEl.style.display = 'block';\n      api.lock('lasso');\n      interactions.on('drag', handleDrag);\n      interactions.on('dragend', handleDragEnd);\n    }\n  };\n\n  const handleDrag = e => {\n    let preselected = new Map();\n    let width = Math.abs(e.deltaX);\n    let height = Math.abs(e.deltaY);\n    let left, top;\n    [left, top] = methods.pageToContainerPos(Math.min(e.start.pageX, e.source.pageX), Math.min(e.start.pageY, e.source.pageY));\n    dom.lassoEl.setAttribute('x', left + 'px');\n    dom.lassoEl.setAttribute('y', top + 'px');\n    dom.lassoEl.setAttribute('width', width + 'px');\n    dom.lassoEl.setAttribute('height', height + 'px'); // dom.lassoEl.style.left = left + 'px';\n    // dom.lassoEl.style.top = top + 'px';\n    // dom.lassoEl.style.width = width + 'px';\n    // dom.lassoEl.style.height = height + 'px';\n\n    let lassoRect = dom.lassoEl.getBoundingClientRect();\n    state.nodes.forEach(node => {\n      let nodeRect = node.el.getBoundingClientRect();\n\n      if (_flow_util__WEBPACK_IMPORTED_MODULE_0__.intersectRect(nodeRect, lassoRect)) {\n        preselected.set(node.key, node);\n      }\n    });\n    methods.setPreselected(preselected);\n  };\n\n  const handleDragEnd = e => {\n    dom.lassoEl.style.display = 'none';\n    dom.lassoEl.setAttribute('width', '0px');\n    dom.lassoEl.setAttribute('height', '0px'); //Emit events\n\n    methods.setSelected(new Map(state.preselected)); //Clear preselection and unlock api\n\n    methods.setPreselected(new Map());\n    api.unlock(); //Remove our active handlers\n\n    interactions.removeListener('drag', handleDrag);\n    interactions.removeListener('dragend', handleDragEnd);\n  };\n\n  interactions.on('dragstart', handleDragStart);\n\n  const dispose = () => {\n    interactions.removeListener('dragstart', handleDragStart);\n    interactions.removeListener('drag', handleDrag);\n    interactions.removeListener('dragend', handleDragEnd);\n  };\n\n  return {\n    name: 'lasso',\n    dispose,\n    update\n  };\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MXFlowLassoTool);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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YixDQUE0QixTQUE1QixFQUF1QyxhQUF2QztBQUNILEdBSkQ7O0FBTUEsU0FBZTtBQUNYLFFBQUksRUFBRSxPQURLO0FBRVgsV0FGVztBQUdYO0FBSFcsR0FBZjtBQUtIOztBQUVELGlFQUFlLGVBQWYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teGZsb3cvLi9zcmMvc3lzdGVtcy9sYXNzby50cz9kOTllIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEludGVyYWN0VHlwZXMgZnJvbSAndHlwZXMvaW50ZXJhY3QudHlwZXMnO1xyXG5pbXBvcnQgKiBhcyBGbG93VHlwZXMgZnJvbSAndHlwZXMvZmxvdy50eXBlcy52Mic7XHJcbmltcG9ydCAqIGFzIEZsb3dVdGlsIGZyb20gJy4uL2Zsb3ctdXRpbCc7XHJcbmltcG9ydCB7IGdldFB1YmxpY0ludGVyZmFjZSB9IGZyb20gJy4uL21ldGhvZHMnO1xyXG5cclxuLyoqXHJcbiAqIE1YRmxvdyB0b29sIHdoaWNoIGhhbmRsZXMgbGFzc28gc2VsZWN0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBNWEZsb3dMYXNzb1Rvb2woYXBpOiBGbG93VHlwZXMuQXBpLCBtZXRob2RzOiBSZXR1cm5UeXBlPHR5cGVvZiBnZXRQdWJsaWNJbnRlcmZhY2U+LCBpbnRlcmFjdGlvbnM6IEludGVyYWN0VHlwZXMuSW50ZXJhY3Rpb25FbWl0dGVyKSA6IEZsb3dUeXBlcy5BY3Rpb25IYW5kbGVyIHtcclxuICAgIGxldCBzdGF0ZSA9IGFwaS5zdGF0ZTtcclxuICAgIGxldCBkb20gPSBhcGkuZG9tO1xyXG5cclxuICAgIGNvbnN0IHVwZGF0ZSA9IChhcGk6IEZsb3dUeXBlcy5BcGkpID0+IHtcclxuICAgICAgICBzdGF0ZSA9IGFwaS5zdGF0ZTtcclxuICAgICAgICBkb20gPSBhcGkuZG9tO1xyXG4gICAgfVxyXG5cclxuICAgICBjb25zdCBpc1ZhbGlkID0gKGU6IFBvaW50ZXJFdmVudCwgaXRlbT86IEZsb3dUeXBlcy5GbG93SXRlbSkgPT4ge1xyXG4gICAgICAgIGlmICghaXRlbSB8fCBpdGVtLnR5cGUgIT09ICdncmFwaCcpIHJldHVybjtcclxuICAgICAgICAvL2lmIChpbnRlcmFjdGlvbnMuaXNNb2RBY3RpdmUoJ211bHRpU2VsZWN0TW9kaWZpZXInKSkgcmV0dXJuO1xyXG4gICAgICAgIGlmIChhcGkub3B0cy5jb250cm9scy5sYXNzb01vZGlmaWVyKXtcclxuICAgICAgICAgICAgcmV0dXJuIGUuYnV0dG9uID09PSAgYXBpLm9wdHMuY29udHJvbHMubGFzc29CdXR0b24gJiYgaW50ZXJhY3Rpb25zLmlzTW9kQWN0aXZlKCdsYXNzb01vZGlmaWVyJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlLmJ1dHRvbiA9PT0gIGFwaS5vcHRzLmNvbnRyb2xzLmxhc3NvQnV0dG9uO1xyXG4gICAgfVxyXG5cclxuICAgIFxyXG4gICAgY29uc3QgaGFuZGxlRHJhZ1N0YXJ0ID0gKGU6IEludGVyYWN0VHlwZXMuTVhEcmFnRXZlbnQpID0+IHtcclxuICAgICAgICBsZXQgaXRlbSA9IG1ldGhvZHMucmVzb2x2ZUl0ZW0oZS5zb3VyY2UpO1xyXG4gICAgICAgIGlmIChpc1ZhbGlkKGUuc291cmNlLCBpdGVtKSl7XHJcbiAgICAgICAgICAgIGRvbS5sYXNzb0VsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgICAgICAgICBhcGkubG9jaygnbGFzc28nKTtcclxuXHJcbiAgICAgICAgICAgIGludGVyYWN0aW9ucy5vbignZHJhZycsIGhhbmRsZURyYWcpO1xyXG4gICAgICAgICAgICBpbnRlcmFjdGlvbnMub24oJ2RyYWdlbmQnLCBoYW5kbGVEcmFnRW5kKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaGFuZGxlRHJhZyA9IChlOiBJbnRlcmFjdFR5cGVzLk1YRHJhZ0V2ZW50KSA9PiB7XHJcbiAgICAgICAgbGV0IHByZXNlbGVjdGVkID0gbmV3IE1hcDxzdHJpbmcsIEZsb3dUeXBlcy5TZWxlY3RhYmxlSXRlbT4oKTtcclxuXHJcbiAgICAgICAgbGV0IHdpZHRoID0gTWF0aC5hYnMoZS5kZWx0YVgpXHJcbiAgICAgICAgbGV0IGhlaWdodCA9IE1hdGguYWJzKGUuZGVsdGFZKTtcclxuICAgICAgICBsZXQgbGVmdCwgdG9wOyBbbGVmdCwgdG9wXSA9IG1ldGhvZHMucGFnZVRvQ29udGFpbmVyUG9zKFxyXG4gICAgICAgICAgICBNYXRoLm1pbihlLnN0YXJ0LnBhZ2VYLCBlLnNvdXJjZS5wYWdlWCksICBcclxuICAgICAgICAgICAgTWF0aC5taW4oZS5zdGFydC5wYWdlWSwgZS5zb3VyY2UucGFnZVkpXHJcbiAgICAgICAgKTtcclxuICAgICAgICBcclxuICAgICAgICBkb20ubGFzc29FbC5zZXRBdHRyaWJ1dGUoJ3gnLCBsZWZ0ICsgJ3B4Jyk7XHJcbiAgICAgICAgZG9tLmxhc3NvRWwuc2V0QXR0cmlidXRlKCd5JywgdG9wICsgJ3B4Jyk7XHJcbiAgICAgICAgZG9tLmxhc3NvRWwuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHdpZHRoICsgJ3B4Jyk7XHJcbiAgICAgICAgZG9tLmxhc3NvRWwuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBoZWlnaHQgKyAncHgnKTtcclxuXHJcbiAgICAgICAgLy8gZG9tLmxhc3NvRWwuc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnO1xyXG4gICAgICAgIC8vIGRvbS5sYXNzb0VsLnN0eWxlLnRvcCA9IHRvcCArICdweCc7XHJcbiAgICAgICAgLy8gZG9tLmxhc3NvRWwuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XHJcbiAgICAgICAgLy8gZG9tLmxhc3NvRWwuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcclxuXHJcbiAgICAgICAgbGV0IGxhc3NvUmVjdCA9IGRvbS5sYXNzb0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyBcclxuICAgICAgICBzdGF0ZS5ub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbm9kZVJlY3QgPSBub2RlLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICBpZiAoRmxvd1V0aWwuaW50ZXJzZWN0UmVjdChub2RlUmVjdCwgbGFzc29SZWN0KSl7XHJcbiAgICAgICAgICAgICAgICBwcmVzZWxlY3RlZC5zZXQobm9kZS5rZXksIG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuXHJcbiAgICAgICAgbWV0aG9kcy5zZXRQcmVzZWxlY3RlZChwcmVzZWxlY3RlZCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaGFuZGxlRHJhZ0VuZCA9IChlOiBJbnRlcmFjdFR5cGVzLk1YRHJhZ0V2ZW50KSA9PiB7XHJcbiAgICAgICAgZG9tLmxhc3NvRWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICBkb20ubGFzc29FbC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgJzBweCcpO1xyXG4gICAgICAgIGRvbS5sYXNzb0VsLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgJzBweCcpO1xyXG5cclxuICAgICAgICAvL0VtaXQgZXZlbnRzXHJcbiAgICAgICAgbWV0aG9kcy5zZXRTZWxlY3RlZChuZXcgTWFwKHN0YXRlLnByZXNlbGVjdGVkKSk7XHJcblxyXG4gICAgICAgIC8vQ2xlYXIgcHJlc2VsZWN0aW9uIGFuZCB1bmxvY2sgYXBpXHJcbiAgICAgICAgbWV0aG9kcy5zZXRQcmVzZWxlY3RlZChuZXcgTWFwKCkpO1xyXG4gICAgICAgIGFwaS51bmxvY2soKTtcclxuXHJcbiAgICAgICAgLy9SZW1vdmUgb3VyIGFjdGl2ZSBoYW5kbGVyc1xyXG4gICAgICAgIGludGVyYWN0aW9ucy5yZW1vdmVMaXN0ZW5lcignZHJhZycsIGhhbmRsZURyYWcpO1xyXG4gICAgICAgIGludGVyYWN0aW9ucy5yZW1vdmVMaXN0ZW5lcignZHJhZ2VuZCcsIGhhbmRsZURyYWdFbmQpO1xyXG4gICAgfVxyXG5cclxuICAgIGludGVyYWN0aW9ucy5vbignZHJhZ3N0YXJ0JywgaGFuZGxlRHJhZ1N0YXJ0KTtcclxuICAgIGNvbnN0IGRpc3Bvc2UgPSAoKSA9PiB7XHJcbiAgICAgICAgaW50ZXJhY3Rpb25zLnJlbW92ZUxpc3RlbmVyKCdkcmFnc3RhcnQnLCBoYW5kbGVEcmFnU3RhcnQpO1xyXG4gICAgICAgIGludGVyYWN0aW9ucy5yZW1vdmVMaXN0ZW5lcignZHJhZycsIGhhbmRsZURyYWcpO1xyXG4gICAgICAgIGludGVyYWN0aW9ucy5yZW1vdmVMaXN0ZW5lcignZHJhZ2VuZCcsIGhhbmRsZURyYWdFbmQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiA8Y29uc3Q+IHtcclxuICAgICAgICBuYW1lOiAnbGFzc28nLFxyXG4gICAgICAgIGRpc3Bvc2UsXHJcbiAgICAgICAgdXBkYXRlXHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1YRmxvd0xhc3NvVG9vbDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/systems/lasso.ts\n");

/***/ }),

/***/ "./src/systems/linker.ts":
/*!*******************************!*\
  !*** ./src/systems/linker.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! types/flow.types.v2 */ \"./src/types/flow.types.v2.ts\");\n/* harmony import */ var _flow_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../flow-util */ \"./src/flow-util.ts\");\n\n\n/**\r\n * MXFlow tool which handles lasso selection\r\n */\n\nfunction MXFlowLinkerTool(api, methods, interactions) {\n  const state = api.state;\n  const dom = api.dom; //let active = false;\n\n  let fromEdge = null;\n  let lastEdge;\n\n  const applyGhostLinkPosition = (e, toEdge) => {\n    let transform = state.transform;\n    let containerRect = dom.containerEl.getBoundingClientRect();\n    let offsetY = containerRect.top;\n    let offsetX = containerRect.left;\n    let latchFrom = _flow_util__WEBPACK_IMPORTED_MODULE_1__.getEdgeLatchPos(fromEdge, offsetX, offsetY);\n    let x1 = latchFrom.x;\n    let y1 = latchFrom.y;\n    let x2, y2;\n\n    if (toEdge) {\n      let latchTo = _flow_util__WEBPACK_IMPORTED_MODULE_1__.getEdgeLatchPos(toEdge, offsetX, offsetY);\n      x2 = latchTo.x;\n      y2 = latchTo.y;\n    } else {\n      //[x2, y2] = methods.pageToGraphPos(e.pageX, e.pageY);\n      // x2 = e.pageX - offsetX;\n      // y2 = e.pageY - offsetY;\n      x2 = e.pageX - api.dom.containerEl.offsetLeft;\n      y2 = e.pageY - api.dom.containerEl.offsetTop;\n    }\n    /**\r\n     * Reverse link direction so that it stays uniform regardless of which end it was dragged from\r\n     */\n\n\n    if (x1 > x2) {\n      [x1, x2] = _flow_util__WEBPACK_IMPORTED_MODULE_1__.swapValues(x1, x2);\n      [y1, y2] = _flow_util__WEBPACK_IMPORTED_MODULE_1__.swapValues(y1, y2);\n    }\n\n    dom.ghostLinkEl.setAttribute('d', _flow_util__WEBPACK_IMPORTED_MODULE_1__.getBezierPath((x1 - transform.x) / transform.scale, (y1 - transform.y) / transform.scale, (x2 - transform.x) / transform.scale, (y2 - transform.y) / transform.scale, api.opts.bezierWeight));\n  };\n\n  const isValidEvent = (e, item) => {\n    return e.isPrimary && item && item.type === 'edge' && (e.pointerType !== 'mouse' || e.button === api.opts.controls.selectButton);\n  };\n\n  const handleDown = e => {\n    let item = methods.resolveItem(e.source);\n\n    if (isValidEvent(e.source, item)) {\n      item = item;\n\n      if (api.opts.beforeLinkStart(item)) {\n        fromEdge = item;\n        dom.ghostLinkEl.style.display = \"block\";\n        api.lock('linker');\n        applyGhostLinkPosition(e.source);\n        interactions.on('move', handleMove);\n        interactions.on('up', handleUp);\n      }\n    }\n  };\n\n  const handleMove = e => {\n    if (e.source.isPrimary) {\n      let item = methods.resolveItem(e.source);\n\n      if (item && item.key !== (fromEdge === null || fromEdge === void 0 ? void 0 : fromEdge.key) && item.type === 'edge') {\n        lastEdge = item;\n        let isValid = methods.isLinkValid(fromEdge, item);\n\n        if (isValid) {\n          dom.ghostLinkEl.classList.remove(types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.LinkInvalid);\n          dom.ghostLinkEl.classList.add(types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.LinkValid);\n          item.el.classList.remove(types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.EdgeInvalid);\n          item.el.classList.add(types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.EdgeValid);\n        } else {\n          dom.ghostLinkEl.classList.remove(types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.LinkValid);\n          dom.ghostLinkEl.classList.add(types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.LinkInvalid);\n          item.el.classList.remove(types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.EdgeValid);\n          item.el.classList.add(types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.EdgeInvalid);\n        }\n\n        applyGhostLinkPosition(e.source, item);\n        return;\n      } else {\n        dom.ghostLinkEl.classList.remove(types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.LinkValid);\n        dom.ghostLinkEl.classList.remove(types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.LinkInvalid);\n\n        if (lastEdge) {\n          lastEdge.el.classList.remove(types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.EdgeValid);\n          lastEdge.el.classList.remove(types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.EdgeInvalid);\n          lastEdge = null;\n        }\n      }\n\n      applyGhostLinkPosition(e.source);\n    }\n  };\n\n  const handleUp = e => {\n    let item = methods.resolveItem(e.source);\n    if (e.source.isPrimary) endLinking();\n    if (!isValidEvent(e.source, item)) return;\n    item = item;\n    if (e.source.button !== api.opts.controls.selectButton) return;\n    if (!api.opts.beforeLinkEnd(fromEdge, item)) return;\n\n    if (methods.isLinkValid(fromEdge, item)) {\n      //Internal validation\n      methods.addLink(fromEdge.nodeKey, fromEdge.edgeKey, item.nodeKey, item.edgeKey);\n    }\n  };\n\n  const endLinking = () => {\n    dom.ghostLinkEl.style.display = \"none\";\n\n    if (lastEdge) {\n      lastEdge.el.classList.remove(types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.EdgeValid);\n      lastEdge.el.classList.remove(types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.EdgeInvalid);\n      lastEdge = null;\n    }\n\n    interactions.removeListener('move', handleMove);\n    interactions.removeListener('up', handleUp);\n    api.unlock();\n  };\n\n  interactions.on('down', handleDown);\n\n  const dispose = () => {\n    interactions.removeListener('down', handleDown);\n    interactions.removeListener('move', handleMove);\n    interactions.removeListener('up', handleUp);\n  };\n\n  return {\n    name: 'linker',\n    dispose\n  };\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MXFlowLinkerTool);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LENBQUMsY0FBYixDQUE0QixNQUE1QixFQUFvQyxVQUFwQztBQUNBLGdCQUFZLENBQUMsY0FBYixDQUE0QixJQUE1QixFQUFrQyxRQUFsQztBQUNILEdBSkQ7O0FBTUEsU0FBZTtBQUNYLFFBQUksRUFBRSxRQURLO0FBRVg7QUFGVyxHQUFmO0FBSUg7O0FBRUQsaUVBQWUsZ0JBQWYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teGZsb3cvLi9zcmMvc3lzdGVtcy9saW5rZXIudHM/NDQyYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBJbnRlcmFjdFR5cGVzIGZyb20gJ3R5cGVzL2ludGVyYWN0LnR5cGVzJztcclxuaW1wb3J0ICogYXMgRmxvd1R5cGVzIGZyb20gJ3R5cGVzL2Zsb3cudHlwZXMudjInO1xyXG5pbXBvcnQgKiBhcyBGbG93VXRpbCBmcm9tICcuLi9mbG93LXV0aWwnO1xyXG5pbXBvcnQgeyBnZXRQdWJsaWNJbnRlcmZhY2UgfSBmcm9tICcuLi9tZXRob2RzJztcclxuXHJcbi8qKlxyXG4gKiBNWEZsb3cgdG9vbCB3aGljaCBoYW5kbGVzIGxhc3NvIHNlbGVjdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gTVhGbG93TGlua2VyVG9vbChhcGk6IEZsb3dUeXBlcy5BcGksIG1ldGhvZHM6IFJldHVyblR5cGU8dHlwZW9mIGdldFB1YmxpY0ludGVyZmFjZT4sIGludGVyYWN0aW9uczogSW50ZXJhY3RUeXBlcy5JbnRlcmFjdGlvbkVtaXR0ZXIpIDogRmxvd1R5cGVzLkFjdGlvbkhhbmRsZXIge1xyXG4gICAgY29uc3Qgc3RhdGUgPSBhcGkuc3RhdGU7XHJcbiAgICBjb25zdCBkb20gPSBhcGkuZG9tO1xyXG4gICAgLy9sZXQgYWN0aXZlID0gZmFsc2U7XHJcbiAgICBsZXQgZnJvbUVkZ2U6IEZsb3dUeXBlcy5FZGdlIHwgbnVsbCA9IG51bGw7XHJcbiAgICBsZXQgbGFzdEVkZ2U6IEZsb3dUeXBlcy5FZGdlIHwgbnVsbDtcclxuXHJcbiAgICBjb25zdCBhcHBseUdob3N0TGlua1Bvc2l0aW9uID0gKGU6IFBvaW50ZXJFdmVudCwgdG9FZGdlPzogRmxvd1R5cGVzLkVkZ2UpID0+IHtcclxuICAgICAgICBsZXQgdHJhbnNmb3JtID0gc3RhdGUudHJhbnNmb3JtO1xyXG4gICAgICAgIGxldCBjb250YWluZXJSZWN0ID0gZG9tLmNvbnRhaW5lckVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIGxldCBvZmZzZXRZID0gY29udGFpbmVyUmVjdC50b3A7XHJcbiAgICAgICAgbGV0IG9mZnNldFggPSBjb250YWluZXJSZWN0LmxlZnQ7XHJcblxyXG4gICAgICAgIGxldCBsYXRjaEZyb20gPSBGbG93VXRpbC5nZXRFZGdlTGF0Y2hQb3MoZnJvbUVkZ2UhLCBvZmZzZXRYLCBvZmZzZXRZKTtcclxuICAgICAgICBsZXQgeDEgPSBsYXRjaEZyb20ueDtcclxuICAgICAgICBsZXQgeTEgPSBsYXRjaEZyb20ueTtcclxuXHJcbiAgICAgICAgbGV0IHgyLCB5MjtcclxuICAgICAgICBpZiAodG9FZGdlKXtcclxuICAgICAgICAgICAgbGV0IGxhdGNoVG8gPSBGbG93VXRpbC5nZXRFZGdlTGF0Y2hQb3ModG9FZGdlLCBvZmZzZXRYLCBvZmZzZXRZKTtcclxuICAgICAgICAgICAgeDIgPSBsYXRjaFRvLng7XHJcbiAgICAgICAgICAgIHkyID0gbGF0Y2hUby55O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vW3gyLCB5Ml0gPSBtZXRob2RzLnBhZ2VUb0dyYXBoUG9zKGUucGFnZVgsIGUucGFnZVkpO1xyXG4gICAgICAgICAgICAvLyB4MiA9IGUucGFnZVggLSBvZmZzZXRYO1xyXG4gICAgICAgICAgICAvLyB5MiA9IGUucGFnZVkgLSBvZmZzZXRZO1xyXG4gICAgICAgICAgICB4MiA9IGUucGFnZVggLSBhcGkuZG9tLmNvbnRhaW5lckVsLm9mZnNldExlZnQ7XHJcbiAgICAgICAgICAgIHkyID0gZS5wYWdlWSAtIGFwaS5kb20uY29udGFpbmVyRWwub2Zmc2V0VG9wO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV2ZXJzZSBsaW5rIGRpcmVjdGlvbiBzbyB0aGF0IGl0IHN0YXlzIHVuaWZvcm0gcmVnYXJkbGVzcyBvZiB3aGljaCBlbmQgaXQgd2FzIGRyYWdnZWQgZnJvbVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlmICh4MSA+IHgyKXtcclxuICAgICAgICAgICAgW3gxLCB4Ml0gPSBGbG93VXRpbC5zd2FwVmFsdWVzKHgxLCB4Mik7XHJcbiAgICAgICAgICAgIFt5MSwgeTJdID0gRmxvd1V0aWwuc3dhcFZhbHVlcyh5MSwgeTIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZG9tLmdob3N0TGlua0VsLnNldEF0dHJpYnV0ZSgnZCcsIFxyXG4gICAgICAgICAgICBGbG93VXRpbC5nZXRCZXppZXJQYXRoKFxyXG4gICAgICAgICAgICAgICAgKHgxIC0gdHJhbnNmb3JtLngpIC8gdHJhbnNmb3JtLnNjYWxlLFxyXG4gICAgICAgICAgICAgICAgKHkxIC0gdHJhbnNmb3JtLnkpIC8gdHJhbnNmb3JtLnNjYWxlLFxyXG4gICAgICAgICAgICAgICAgKHgyIC0gdHJhbnNmb3JtLngpIC8gdHJhbnNmb3JtLnNjYWxlLFxyXG4gICAgICAgICAgICAgICAgKHkyIC0gdHJhbnNmb3JtLnkpIC8gdHJhbnNmb3JtLnNjYWxlLFxyXG4gICAgICAgICAgICAgICAgYXBpLm9wdHMuYmV6aWVyV2VpZ2h0XHJcbiAgICAgICAgICAgIClcclxuICAgICAgICApXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaXNWYWxpZEV2ZW50ID0gKGU6IFBvaW50ZXJFdmVudCwgaXRlbT86IEZsb3dUeXBlcy5GbG93SXRlbSkgPT4ge1xyXG4gICAgICAgIHJldHVybiBlLmlzUHJpbWFyeSAmJiBpdGVtICYmIGl0ZW0udHlwZSA9PT0gJ2VkZ2UnICYmIChlLnBvaW50ZXJUeXBlICE9PSAnbW91c2UnIHx8IGUuYnV0dG9uID09PSBhcGkub3B0cy5jb250cm9scy5zZWxlY3RCdXR0b24pO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGhhbmRsZURvd24gPSAoZTogSW50ZXJhY3RUeXBlcy5NWFBvaW50ZXJFdmVudCkgPT4ge1xyXG4gICAgICAgIGxldCBpdGVtID0gbWV0aG9kcy5yZXNvbHZlSXRlbShlLnNvdXJjZSk7XHJcbiAgICAgICAgaWYgKGlzVmFsaWRFdmVudChlLnNvdXJjZSwgaXRlbSkpe1xyXG4gICAgICAgICAgICBpdGVtID0gPEZsb3dUeXBlcy5FZGdlPiBpdGVtO1xyXG4gICAgICAgICAgICBpZiAoYXBpLm9wdHMuYmVmb3JlTGlua1N0YXJ0KGl0ZW0pKXtcclxuICAgICAgICAgICAgICAgIGZyb21FZGdlID0gaXRlbTsgICBcclxuICAgICAgICAgICAgICAgIGRvbS5naG9zdExpbmtFbC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xyXG4gICAgICAgICAgICAgICAgYXBpLmxvY2soJ2xpbmtlcicpO1xyXG4gICAgICAgICAgICAgICAgYXBwbHlHaG9zdExpbmtQb3NpdGlvbihlLnNvdXJjZSk7XHJcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbnMub24oJ21vdmUnLCBoYW5kbGVNb3ZlKTtcclxuICAgICAgICAgICAgICAgIGludGVyYWN0aW9ucy5vbigndXAnLCBoYW5kbGVVcCk7IFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGhhbmRsZU1vdmUgPSAoZTogSW50ZXJhY3RUeXBlcy5NWFBvaW50ZXJFdmVudCkgPT4ge1xyXG4gICAgICAgIGlmIChlLnNvdXJjZS5pc1ByaW1hcnkpe1xyXG4gICAgICAgICAgICBsZXQgaXRlbSA9IG1ldGhvZHMucmVzb2x2ZUl0ZW0oZS5zb3VyY2UpO1xyXG4gICAgICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLmtleSAhPT0gZnJvbUVkZ2U/LmtleSAmJiBpdGVtLnR5cGUgPT09ICdlZGdlJyl7XHJcbiAgICAgICAgICAgICAgICBsYXN0RWRnZSA9IGl0ZW07XHJcbiAgICAgICAgICAgICAgICBsZXQgaXNWYWxpZCA9IG1ldGhvZHMuaXNMaW5rVmFsaWQoZnJvbUVkZ2UhLCBpdGVtKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkKXtcclxuICAgICAgICAgICAgICAgICAgICBkb20uZ2hvc3RMaW5rRWwuY2xhc3NMaXN0LnJlbW92ZShGbG93VHlwZXMuRmxvd0NsYXNzLkxpbmtJbnZhbGlkKTtcclxuICAgICAgICAgICAgICAgICAgICBkb20uZ2hvc3RMaW5rRWwuY2xhc3NMaXN0LmFkZChGbG93VHlwZXMuRmxvd0NsYXNzLkxpbmtWYWxpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5lbC5jbGFzc0xpc3QucmVtb3ZlKEZsb3dUeXBlcy5GbG93Q2xhc3MuRWRnZUludmFsaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZWwuY2xhc3NMaXN0LmFkZChGbG93VHlwZXMuRmxvd0NsYXNzLkVkZ2VWYWxpZCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvbS5naG9zdExpbmtFbC5jbGFzc0xpc3QucmVtb3ZlKEZsb3dUeXBlcy5GbG93Q2xhc3MuTGlua1ZhbGlkKTtcclxuICAgICAgICAgICAgICAgICAgICBkb20uZ2hvc3RMaW5rRWwuY2xhc3NMaXN0LmFkZChGbG93VHlwZXMuRmxvd0NsYXNzLkxpbmtJbnZhbGlkKTtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtLmVsLmNsYXNzTGlzdC5yZW1vdmUoRmxvd1R5cGVzLkZsb3dDbGFzcy5FZGdlVmFsaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uZWwuY2xhc3NMaXN0LmFkZChGbG93VHlwZXMuRmxvd0NsYXNzLkVkZ2VJbnZhbGlkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBhcHBseUdob3N0TGlua1Bvc2l0aW9uKGUuc291cmNlLCBpdGVtKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkb20uZ2hvc3RMaW5rRWwuY2xhc3NMaXN0LnJlbW92ZShGbG93VHlwZXMuRmxvd0NsYXNzLkxpbmtWYWxpZCk7XHJcbiAgICAgICAgICAgICAgICBkb20uZ2hvc3RMaW5rRWwuY2xhc3NMaXN0LnJlbW92ZShGbG93VHlwZXMuRmxvd0NsYXNzLkxpbmtJbnZhbGlkKTtcclxuICAgICAgICAgICAgICAgIGlmIChsYXN0RWRnZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdEVkZ2UuZWwuY2xhc3NMaXN0LnJlbW92ZShGbG93VHlwZXMuRmxvd0NsYXNzLkVkZ2VWYWxpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdEVkZ2UuZWwuY2xhc3NMaXN0LnJlbW92ZShGbG93VHlwZXMuRmxvd0NsYXNzLkVkZ2VJbnZhbGlkKTtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0RWRnZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGFwcGx5R2hvc3RMaW5rUG9zaXRpb24oZS5zb3VyY2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBoYW5kbGVVcCA9IChlOiBJbnRlcmFjdFR5cGVzLk1YUG9pbnRlckV2ZW50KSA9PiB7XHJcbiAgICAgICAgbGV0IGl0ZW0gPSBtZXRob2RzLnJlc29sdmVJdGVtKGUuc291cmNlKVxyXG4gICAgICAgIGlmIChlLnNvdXJjZS5pc1ByaW1hcnkpIGVuZExpbmtpbmcoKTtcclxuICAgICAgICBpZiAoIWlzVmFsaWRFdmVudChlLnNvdXJjZSwgaXRlbSkpIHJldHVybjtcclxuXHJcbiAgICAgICAgaXRlbSA9IDxGbG93VHlwZXMuRWRnZT4gaXRlbTtcclxuXHJcbiAgICAgICAgaWYgKGUuc291cmNlLmJ1dHRvbiAhPT0gYXBpLm9wdHMuY29udHJvbHMuc2VsZWN0QnV0dG9uKSByZXR1cm47XHJcbiAgICAgICAgaWYgKCFhcGkub3B0cy5iZWZvcmVMaW5rRW5kKGZyb21FZGdlISwgaXRlbSkpIHJldHVybjtcclxuICAgICAgICBpZiAobWV0aG9kcy5pc0xpbmtWYWxpZChmcm9tRWRnZSEsIGl0ZW0pKXsgLy9JbnRlcm5hbCB2YWxpZGF0aW9uXHJcbiAgICAgICAgICAgIG1ldGhvZHMuYWRkTGluayhmcm9tRWRnZSEubm9kZUtleSwgZnJvbUVkZ2UhLmVkZ2VLZXksIGl0ZW0ubm9kZUtleSwgaXRlbS5lZGdlS2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZW5kTGlua2luZyA9ICgpID0+IHtcclxuICAgICAgICBkb20uZ2hvc3RMaW5rRWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gICAgICAgIGlmIChsYXN0RWRnZSl7XHJcbiAgICAgICAgICAgIGxhc3RFZGdlLmVsLmNsYXNzTGlzdC5yZW1vdmUoRmxvd1R5cGVzLkZsb3dDbGFzcy5FZGdlVmFsaWQpO1xyXG4gICAgICAgICAgICBsYXN0RWRnZS5lbC5jbGFzc0xpc3QucmVtb3ZlKEZsb3dUeXBlcy5GbG93Q2xhc3MuRWRnZUludmFsaWQpO1xyXG4gICAgICAgICAgICBsYXN0RWRnZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnRlcmFjdGlvbnMucmVtb3ZlTGlzdGVuZXIoJ21vdmUnLCBoYW5kbGVNb3ZlKTtcclxuICAgICAgICBpbnRlcmFjdGlvbnMucmVtb3ZlTGlzdGVuZXIoJ3VwJywgaGFuZGxlVXApOyBcclxuICAgICAgICBhcGkudW5sb2NrKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaW50ZXJhY3Rpb25zLm9uKCdkb3duJywgaGFuZGxlRG93bik7XHJcbiAgICBjb25zdCBkaXNwb3NlID0gKCkgPT4ge1xyXG4gICAgICAgIGludGVyYWN0aW9ucy5yZW1vdmVMaXN0ZW5lcignZG93bicsIGhhbmRsZURvd24pO1xyXG4gICAgICAgIGludGVyYWN0aW9ucy5yZW1vdmVMaXN0ZW5lcignbW92ZScsIGhhbmRsZU1vdmUpO1xyXG4gICAgICAgIGludGVyYWN0aW9ucy5yZW1vdmVMaXN0ZW5lcigndXAnLCBoYW5kbGVVcCk7IFxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiA8Y29uc3Q+IHtcclxuICAgICAgICBuYW1lOiAnbGlua2VyJyxcclxuICAgICAgICBkaXNwb3NlXHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1YRmxvd0xpbmtlclRvb2w7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/systems/linker.ts\n");

/***/ }),

/***/ "./src/systems/panzoom.ts":
/*!********************************!*\
  !*** ./src/systems/panzoom.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! types/flow.types.v2 */ \"./src/types/flow.types.v2.ts\");\n/* harmony import */ var _flow_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../flow-util */ \"./src/flow-util.ts\");\n\n\n\nconst distance = (x1, y1, x2, y2) => {\n  return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n};\n\nconst midpoint = (x1, y1, x2, y2) => {\n  return [(x1 + x2) / 2, (y1 + y2) / 2];\n};\n/**\r\n * MXFlow tool which handles lasso selection.\r\n */\n\n\nfunction MXFlowPanZoomTool(api, methods, interactions) {\n  let controls = api.opts.controls;\n  let opts = api.opts.panzoom;\n  let state = api.state;\n  let dom = api.dom;\n  let transform = state.transform;\n  let panning = false;\n  let pinching = false;\n  let width = api.opts.width; //dom. //dom.rootEl.getBoundingClientRect().width;\n\n  let height = api.opts.height; //5000;//dom.rootEl.getBoundingClientRect().height;\n\n  let deltaX = 0;\n  let deltaY = 0;\n  let panStartX = 0;\n  let panStartY = 0;\n  let maxDeltaBottom = 0;\n  let maxDeltaRight = 0; //let lastMoveEvent: PointerEvent | null = null;\n  // let startDiff: number = 0;\n  // let pointer1: PointerEvent | null = null;\n  // let pointer2: PointerEvent | null = null;\n  // let pinchStartDistance = 0;\n  // let canvasRect = dom.rootEl.getBoundingClientRect(); //Probably doesn't need to recalculated\n\n  const update = api => {\n    opts = api.opts.panzoom;\n    state = api.state;\n    dom = api.dom;\n    transform = state.transform;\n  };\n\n  const isValidDragPan = (e, item) => {\n    let modActive = controls.panModifier ? interactions.isModActive('panModifier') : true;\n    return !api.isLocked() && e.isPrimary && (item === null || item === void 0 ? void 0 : item.type) === 'graph'\n    /*&& opts.panFilter!(e) */\n    && modActive && (e.pointerType !== 'mouse' || e.button === controls.panButton);\n  };\n\n  const applyTransform = function () {\n    let transition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    dom.rootEl.style.transition = transition ? 'transform .3s' : '';\n    dom.rootEl.style.transform = `translate(${transform.x + deltaX}px, ${transform.y + deltaY}px) scale(${transform.scale})`;\n  };\n\n  const updateMaxDeltas = () => {\n    /**\r\n     * Calculate max deltas. Note: Can substitute canvas element rect width/height for this\r\n     * calculation `(api.opts.width * transform.scale)`. Not sure which is more performant, or concise.\r\n     */\n    let containerRect = dom.containerEl.getBoundingClientRect();\n    maxDeltaRight = api.opts.width * transform.scale - (Math.abs(transform.x) + containerRect.width);\n    maxDeltaBottom = api.opts.height * transform.scale - (Math.abs(transform.y) + containerRect.height);\n  };\n\n  const handleDragStart = e => {\n    if (isValidDragPan(e.source, methods.resolveItem(e.source))) {\n      updateMaxDeltas();\n      /**\r\n       * Add our drag handlers\r\n       */\n\n      panning = true;\n      interactions.on('drag', handleDrag);\n      interactions.on('dragend', handleDragEnd);\n      /**\r\n       * Add our pan class\r\n       */\n\n      api.dom.rootEl.classList.add(types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.RootPanning);\n    }\n  };\n\n  const handleDrag = e => {\n    updateMaxDeltas();\n    deltaX = -(0,_flow_util__WEBPACK_IMPORTED_MODULE_1__.clamp)(-e.deltaX, transform.x, maxDeltaRight);\n    deltaY = -(0,_flow_util__WEBPACK_IMPORTED_MODULE_1__.clamp)(-e.deltaY, transform.y, maxDeltaBottom);\n    applyTransform(false);\n  };\n\n  const handleDragEnd = e => {\n    /**\r\n     * Merge deltas with transform and zero out detlas, clear listeners\r\n     */\n    transform.x = transform.x + deltaX;\n    transform.y = transform.y + deltaY;\n    deltaX = 0;\n    deltaY = 0;\n    interactions.removeListener('drag', handleDrag);\n    interactions.removeListener('dragend', handleDragEnd);\n    panning = false;\n    api.dom.rootEl.classList.remove(types_flow_types_v2__WEBPACK_IMPORTED_MODULE_0__.FlowClass.RootPanning);\n    applyTransform();\n  };\n\n  const stepPan = (stepX, stepY) => {\n    deltaX = 0; // clear any existing delta values\n\n    deltaY = 0;\n    let containerRect = dom.containerEl.getBoundingClientRect();\n    transform.x = -(0,_flow_util__WEBPACK_IMPORTED_MODULE_1__.clamp)(-(transform.x + stepX), 0, width * transform.scale - containerRect.width);\n    transform.y = -(0,_flow_util__WEBPACK_IMPORTED_MODULE_1__.clamp)(-(transform.y + stepY), 0, height * transform.scale - containerRect.height);\n    applyTransform();\n  };\n\n  const handleKeyDown = e => {\n    if (api.opts.controls.panOnArrowKeys && methods.eventInGraph(e.source)) {\n      switch (e.source.key) {\n        case 'ArrowUp':\n          stepPan(0, 75);\n          break;\n\n        case 'ArrowRight':\n          stepPan(-75, 0);\n          break;\n\n        case 'ArrowDown':\n          stepPan(0, -75);\n          break;\n\n        case 'ArrowLeft':\n          stepPan(75, 0);\n          break;\n      }\n    }\n  };\n\n  const handleWheel = e => {\n    if (panning) return;\n    let delta = Math.max(-1, Math.min(1, -e.source.deltaY));\n    /**\r\n     * Handle pan via wheel. This control supercededs zooming via pan.\r\n     */\n\n    if (api.opts.controls.panOnWheel) {\n      if (api.dom.containerEl === document.activeElement || api.dom.containerEl.contains(document.activeElement)) {\n        let step = delta * 75;\n\n        if (interactions.isModKeyActive('Shift')) {\n          stepPan(step, 0);\n        } else {\n          stepPan(0, step);\n        }\n\n        applyTransform();\n      }\n\n      return;\n    }\n    /**\r\n     * Handle zoom via wheel.\r\n     */\n\n\n    if (api.opts.controls.zoomOnWheel) {\n      handleZoom(e.source);\n    }\n  };\n  /**\r\n   * ------------------------------------------------------------------------------------------------\r\n   * Resize Handler\r\n   * ------------------------------------------------------------------------------------------------\r\n   */\n\n  /**\r\n   * Calculates \"inherent\" min scale based on window size and returns whichever is largest between the\r\n   * inherent min and the min scale give in options.\r\n   *\r\n   * @param containerRect\r\n   * @returns\r\n   */\n\n\n  const getMinScale = containerRect => {\n    containerRect = containerRect !== null && containerRect !== void 0 ? containerRect : dom.containerEl.getBoundingClientRect();\n    return Math.max(Math.max(containerRect.width / width, opts.minScale), Math.max(containerRect.height / height, opts.minScale));\n  };\n\n  const handleResize = () => {\n    /**\r\n     * Enforce min/max scale and positioning on resize.\r\n     *\r\n     * NOTE: This behavior doesn't seem quite right (sometimes resetting position overzealously),\r\n     * but it does effectively ensure that we don't end up w/ invalid scale or positioning which is enough for now.\r\n     */\n    let containerRect = dom.containerEl.getBoundingClientRect();\n    let minScale = getMinScale(containerRect);\n    let nextScale = Math.max(transform.scale, minScale);\n    let maxX = width * nextScale - containerRect.width;\n    let maxY = height * nextScale - containerRect.height;\n    let nextX = -Math.min(maxX, Math.abs(transform.x));\n    let nextY = -Math.min(maxY, Math.abs(transform.y));\n    transform.scale = nextScale;\n    transform.x = nextX;\n    transform.y = nextY;\n    applyTransform();\n  };\n\n  const handleResizeThrottled = (0,_flow_util__WEBPACK_IMPORTED_MODULE_1__.throttle)(handleResize, 500);\n  /**\r\n   * ------------------------------------------------------------------------------------------------\r\n   * Event binding\r\n   * ------------------------------------------------------------------------------------------------\r\n   */\n\n  interactions.on('dragstart', handleDragStart);\n  interactions.on('wheel', handleWheel);\n  interactions.on('keydown', handleKeyDown);\n  window.addEventListener('resize', handleResizeThrottled);\n\n  const dispose = () => {\n    interactions.removeListener('dragstart', handleDragStart);\n    interactions.removeListener('drag', handleDrag);\n    interactions.removeListener('dragend', handleDragEnd);\n    interactions.removeListener('wheel', handleWheel);\n    interactions.removeListener('keydown', handleKeyDown);\n    window.removeEventListener('resize', handleResizeThrottled);\n  };\n\n  const handleZoom = e => {\n    //if (!methods.eventInGraph(e) || panning || api.isLocked()) return;\n    //e.preventDefault();\n    //e.stopPropagation();\n    let containerRect = dom.containerEl.getBoundingClientRect();\n    let delta = Math.max(-1, Math.min(1, -e.deltaY));\n    let scalePageX = e.pageX - dom.containerEl.offsetLeft;\n    let scalePageY = e.pageY - dom.containerEl.offsetTop;\n    let translateX = -((scalePageX - transform.x) / transform.scale);\n    let translateY = -((scalePageY - transform.y) / transform.scale);\n    /**\r\n     * Calculate our min and max scale. For min scale we must enforce \"inherent\" minimum to prevent\r\n     * our root element from ever being scaled so small that it does span the entire width of the\r\n     * container.\r\n     */\n\n    let minScale = getMinScale(containerRect);\n    let maxScale = opts === null || opts === void 0 ? void 0 : opts.maxScale;\n    /**\r\n     * Calculate our next scale and return if it violates min/max constraints.\r\n     * Uncomment scale to make the zooming feel more porpotional (at the cost\r\n     * if easily divisible scale).\r\n     */\n\n    let nextScale = parseFloat((transform.scale + delta * (opts === null || opts === void 0 ? void 0 : opts.scaleStep)\n    /* * scale */\n    ).toFixed(2));\n    if (nextScale < minScale || nextScale > maxScale) return;\n    /**\r\n     * Get our potential next x and y positions\r\n     */\n\n    let nextX = translateX * nextScale + scalePageX;\n    let nextY = translateY * nextScale + scalePageY;\n    /**\r\n     * Use our next scale to calculate what the max x (left) and y (top) position will be.\r\n     */\n\n    let maxX = width * nextScale - containerRect.width;\n    let maxY = height * nextScale - containerRect.height;\n    /**\r\n     * Enforce max x/y positions.\r\n     *\r\n     * NOTE: Tried to use clamp() method here but it seemed to introduce\r\n     * tiny offsets when zooming against a boundary. Maybe something to do w/\r\n     * Math.min/math.max.\r\n     *\r\n     */\n\n    if (nextX > 0) nextX = 0;\n    if (nextY > 0) nextY = 0;\n    if (nextX < -maxX) nextX = -maxX;\n    if (nextY < -maxY) nextY = -maxY;\n    /**\r\n     * Update our values and apply\r\n     */\n\n    transform.scale = nextScale;\n    transform.x = nextX;\n    transform.y = nextY;\n    applyTransform(true);\n    api.emit('transform', Object.assign({}, transform));\n    methods.recordAction('transform');\n  };\n  /**\r\n   * Enforce resize\r\n   */\n\n\n  handleResize();\n  return {\n    name: 'panzoom',\n    update,\n    dispose\n  };\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MXFlowPanZoomTool);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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d2VicGFjazovL214Zmxvdy8uL3NyYy9zeXN0ZW1zL3Bhbnpvb20udHM/YTRhZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBGbG93VHlwZXMgZnJvbSAndHlwZXMvZmxvdy50eXBlcy52Mic7XHJcbmltcG9ydCAqIGFzIEludGVyYWN0VHlwZXMgZnJvbSAndHlwZXMvaW50ZXJhY3QudHlwZXMnO1xyXG5pbXBvcnQgeyBjbGFtcCwgdGhyb3R0bGUgfSBmcm9tICcuLi9mbG93LXV0aWwnO1xyXG5cclxuY29uc3QgZGlzdGFuY2UgPSAoeDE6IG51bWJlciwgeTE6IG51bWJlciwgeDI6IG51bWJlciwgeTI6IG51bWJlcikgPT4ge1xyXG4gICAgcmV0dXJuIE1hdGguc3FydCggTWF0aC5wb3coKHgxLXgyKSwgMikgKyBNYXRoLnBvdygoeTEteTIpLCAyKSApO1xyXG59XHJcblxyXG5jb25zdCBtaWRwb2ludCA9ICh4MTogbnVtYmVyLCB5MTogbnVtYmVyLCB4MjogbnVtYmVyLCB5MjogbnVtYmVyKSA9PiB7XHJcblx0cmV0dXJuIFsoeDEgKyB4MikgLyAyLCAoeTEgKyB5MikgLyAyXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIE1YRmxvdyB0b29sIHdoaWNoIGhhbmRsZXMgbGFzc28gc2VsZWN0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gTVhGbG93UGFuWm9vbVRvb2woYXBpOiBGbG93VHlwZXMuQXBpLCBtZXRob2RzOiBGbG93VHlwZXMuTWV0aG9kcywgaW50ZXJhY3Rpb25zOiBJbnRlcmFjdFR5cGVzLkludGVyYWN0aW9uRW1pdHRlcikgOiBGbG93VHlwZXMuQWN0aW9uSGFuZGxlciB7XHJcbiAgICBsZXQgY29udHJvbHMgPSBhcGkub3B0cy5jb250cm9scztcclxuICAgIGxldCBvcHRzID0gYXBpLm9wdHMucGFuem9vbTtcclxuICAgIGxldCBzdGF0ZSA9IGFwaS5zdGF0ZTtcclxuICAgIGxldCBkb20gPSBhcGkuZG9tO1xyXG4gICAgbGV0IHRyYW5zZm9ybSA9IHN0YXRlLnRyYW5zZm9ybTtcclxuICAgIGxldCBwYW5uaW5nID0gZmFsc2U7XHJcbiAgICBsZXQgcGluY2hpbmcgPSBmYWxzZTtcclxuICAgIGxldCB3aWR0aCA9IGFwaS5vcHRzLndpZHRoOyAvL2RvbS4gLy9kb20ucm9vdEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xyXG4gICAgbGV0IGhlaWdodCA9IGFwaS5vcHRzLmhlaWdodDsgLy81MDAwOy8vZG9tLnJvb3RFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XHJcbiAgICBsZXQgZGVsdGFYID0gMDtcclxuICAgIGxldCBkZWx0YVkgPSAwO1xyXG4gICAgbGV0IHBhblN0YXJ0WCA9IDA7XHJcbiAgICBsZXQgcGFuU3RhcnRZID0gMDtcclxuICAgIGxldCBtYXhEZWx0YUJvdHRvbSA9IDA7XHJcbiAgICBsZXQgbWF4RGVsdGFSaWdodCA9IDA7XHJcbiAgICAvL2xldCBsYXN0TW92ZUV2ZW50OiBQb2ludGVyRXZlbnQgfCBudWxsID0gbnVsbDtcclxuICAgIC8vIGxldCBzdGFydERpZmY6IG51bWJlciA9IDA7XHJcbiAgICAvLyBsZXQgcG9pbnRlcjE6IFBvaW50ZXJFdmVudCB8IG51bGwgPSBudWxsO1xyXG4gICAgLy8gbGV0IHBvaW50ZXIyOiBQb2ludGVyRXZlbnQgfCBudWxsID0gbnVsbDtcclxuICAgIC8vIGxldCBwaW5jaFN0YXJ0RGlzdGFuY2UgPSAwO1xyXG5cclxuICAgIC8vIGxldCBjYW52YXNSZWN0ID0gZG9tLnJvb3RFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy9Qcm9iYWJseSBkb2Vzbid0IG5lZWQgdG8gcmVjYWxjdWxhdGVkXHJcblxyXG4gICAgY29uc3QgdXBkYXRlID0gKGFwaTogRmxvd1R5cGVzLkFwaSkgPT4ge1xyXG4gICAgICAgIG9wdHMgPSBhcGkub3B0cy5wYW56b29tO1xyXG4gICAgICAgIHN0YXRlID0gYXBpLnN0YXRlO1xyXG4gICAgICAgIGRvbSA9IGFwaS5kb207XHJcbiAgICAgICAgdHJhbnNmb3JtID0gc3RhdGUudHJhbnNmb3JtO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGlzVmFsaWREcmFnUGFuID0gKGU6IFBvaW50ZXJFdmVudCwgaXRlbT86IEZsb3dUeXBlcy5GbG93SXRlbSkgPT4ge1xyXG4gICAgICAgIGxldCBtb2RBY3RpdmUgPSBjb250cm9scy5wYW5Nb2RpZmllciA/IGludGVyYWN0aW9ucy5pc01vZEFjdGl2ZSgncGFuTW9kaWZpZXInKSA6IHRydWU7XHJcbiAgICAgICAgcmV0dXJuICFhcGkuaXNMb2NrZWQoKSAmJiBlLmlzUHJpbWFyeSAmJiBpdGVtPy50eXBlID09PSAnZ3JhcGgnIC8qJiYgb3B0cy5wYW5GaWx0ZXIhKGUpICovICYmIG1vZEFjdGl2ZSAmJiAoZS5wb2ludGVyVHlwZSAhPT0gJ21vdXNlJyB8fCBlLmJ1dHRvbiA9PT0gY29udHJvbHMucGFuQnV0dG9uKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhcHBseVRyYW5zZm9ybSA9ICh0cmFuc2l0aW9uOiBib29sZWFuID0gZmFsc2UpID0+IHtcclxuICAgICAgICBkb20ucm9vdEVsLnN0eWxlLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uID8gJ3RyYW5zZm9ybSAuM3MnIDogJyc7XHJcbiAgICAgICAgZG9tLnJvb3RFbC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7dHJhbnNmb3JtLnggKyBkZWx0YVh9cHgsICR7dHJhbnNmb3JtLnkgKyBkZWx0YVl9cHgpIHNjYWxlKCR7dHJhbnNmb3JtLnNjYWxlfSlgO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCB1cGRhdGVNYXhEZWx0YXMgPSAoKSA9PiB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsY3VsYXRlIG1heCBkZWx0YXMuIE5vdGU6IENhbiBzdWJzdGl0dXRlIGNhbnZhcyBlbGVtZW50IHJlY3Qgd2lkdGgvaGVpZ2h0IGZvciB0aGlzIFxyXG4gICAgICAgICAqIGNhbGN1bGF0aW9uIGAoYXBpLm9wdHMud2lkdGggKiB0cmFuc2Zvcm0uc2NhbGUpYC4gTm90IHN1cmUgd2hpY2ggaXMgbW9yZSBwZXJmb3JtYW50LCBvciBjb25jaXNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGxldCBjb250YWluZXJSZWN0ID0gZG9tLmNvbnRhaW5lckVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIG1heERlbHRhUmlnaHQgPSAoIChhcGkub3B0cy53aWR0aCAqIHRyYW5zZm9ybS5zY2FsZSkgLSAoTWF0aC5hYnModHJhbnNmb3JtLngpICsgY29udGFpbmVyUmVjdC53aWR0aCkpO1xyXG4gICAgICAgIG1heERlbHRhQm90dG9tID0gKCAoYXBpLm9wdHMuaGVpZ2h0ICogdHJhbnNmb3JtLnNjYWxlKSAgLSAoTWF0aC5hYnModHJhbnNmb3JtLnkpICsgY29udGFpbmVyUmVjdC5oZWlnaHQpKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBoYW5kbGVEcmFnU3RhcnQgPSAoZTogSW50ZXJhY3RUeXBlcy5NWERyYWdFdmVudCkgPT4ge1xyXG4gICAgICAgIGlmIChpc1ZhbGlkRHJhZ1BhbihlLnNvdXJjZSwgbWV0aG9kcy5yZXNvbHZlSXRlbShlLnNvdXJjZSkpKXtcclxuICAgICAgICAgICAgdXBkYXRlTWF4RGVsdGFzKCk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBZGQgb3VyIGRyYWcgaGFuZGxlcnNcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHBhbm5pbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICBpbnRlcmFjdGlvbnMub24oJ2RyYWcnLCBoYW5kbGVEcmFnKTtcclxuICAgICAgICAgICAgaW50ZXJhY3Rpb25zLm9uKCdkcmFnZW5kJywgaGFuZGxlRHJhZ0VuZCk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBZGQgb3VyIHBhbiBjbGFzc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgYXBpLmRvbS5yb290RWwuY2xhc3NMaXN0LmFkZChGbG93VHlwZXMuRmxvd0NsYXNzLlJvb3RQYW5uaW5nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaGFuZGxlRHJhZyA9IChlOiBJbnRlcmFjdFR5cGVzLk1YRHJhZ0V2ZW50KSA9PiB7XHJcbiAgICAgICAgdXBkYXRlTWF4RGVsdGFzKCk7XHJcbiAgICAgICAgZGVsdGFYID0gLWNsYW1wKC1lLmRlbHRhWCwgdHJhbnNmb3JtLngsIG1heERlbHRhUmlnaHQpO1xyXG4gICAgICAgIGRlbHRhWSA9IC1jbGFtcCgtZS5kZWx0YVksIHRyYW5zZm9ybS55LCBtYXhEZWx0YUJvdHRvbSk7XHJcbiAgICAgICAgYXBwbHlUcmFuc2Zvcm0oZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCBoYW5kbGVEcmFnRW5kID0gKGU6IEludGVyYWN0VHlwZXMuTVhEcmFnRXZlbnQpID0+IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNZXJnZSBkZWx0YXMgd2l0aCB0cmFuc2Zvcm0gYW5kIHplcm8gb3V0IGRldGxhcywgY2xlYXIgbGlzdGVuZXJzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdHJhbnNmb3JtLnggPSB0cmFuc2Zvcm0ueCArIGRlbHRhWDtcclxuICAgICAgICB0cmFuc2Zvcm0ueSA9IHRyYW5zZm9ybS55ICsgZGVsdGFZO1xyXG4gICAgICAgIGRlbHRhWCA9IDA7XHJcbiAgICAgICAgZGVsdGFZID0gMDtcclxuICAgICAgICBpbnRlcmFjdGlvbnMucmVtb3ZlTGlzdGVuZXIoJ2RyYWcnLCBoYW5kbGVEcmFnKTtcclxuICAgICAgICBpbnRlcmFjdGlvbnMucmVtb3ZlTGlzdGVuZXIoJ2RyYWdlbmQnLCBoYW5kbGVEcmFnRW5kKTtcclxuICAgICAgICBwYW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgYXBpLmRvbS5yb290RWwuY2xhc3NMaXN0LnJlbW92ZShGbG93VHlwZXMuRmxvd0NsYXNzLlJvb3RQYW5uaW5nKTtcclxuICAgICAgICBhcHBseVRyYW5zZm9ybSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHN0ZXBQYW4gPSAoc3RlcFg6IG51bWJlciwgc3RlcFk6IG51bWJlcikgPT4ge1xyXG4gICAgICAgIGRlbHRhWCA9IDA7IC8vIGNsZWFyIGFueSBleGlzdGluZyBkZWx0YSB2YWx1ZXNcclxuICAgICAgICBkZWx0YVkgPSAwO1xyXG4gICAgICAgIGxldCBjb250YWluZXJSZWN0ID0gZG9tLmNvbnRhaW5lckVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIHRyYW5zZm9ybS54ID0gLWNsYW1wKC0odHJhbnNmb3JtLnggKyBzdGVwWCksIDAsICh3aWR0aCAqIHRyYW5zZm9ybS5zY2FsZSAtIGNvbnRhaW5lclJlY3Qud2lkdGgpKTtcclxuICAgICAgICB0cmFuc2Zvcm0ueSA9IC1jbGFtcCgtKHRyYW5zZm9ybS55ICsgc3RlcFkpLCAwLCAoaGVpZ2h0ICogdHJhbnNmb3JtLnNjYWxlIC0gY29udGFpbmVyUmVjdC5oZWlnaHQpKTtcclxuICAgICAgICBhcHBseVRyYW5zZm9ybSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGhhbmRsZUtleURvd24gPSAoZTogSW50ZXJhY3RUeXBlcy5NWEtleWJvYXJkRXZlbnQpID0+IHtcclxuICAgICAgICBpZiAoYXBpLm9wdHMuY29udHJvbHMucGFuT25BcnJvd0tleXMgJiYgbWV0aG9kcy5ldmVudEluR3JhcGgoZS5zb3VyY2UpKXtcclxuICAgICAgICAgICAgc3dpdGNoIChlLnNvdXJjZS5rZXkpe1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnQXJyb3dVcCc6IHN0ZXBQYW4oMCwgNzUpOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ0Fycm93UmlnaHQnOiBzdGVwUGFuKC03NSwgMCk7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnQXJyb3dEb3duJzogc3RlcFBhbigwLCAtNzUpOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ0Fycm93TGVmdCc6IHN0ZXBQYW4oNzUsIDApOyBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBoYW5kbGVXaGVlbCA9IChlOiBJbnRlcmFjdFR5cGVzLk1YV2hlZWxFdmVudCkgPT4ge1xyXG4gICAgICAgIGlmIChwYW5uaW5nKSByZXR1cm47XHJcbiAgICAgICAgbGV0IGRlbHRhID0gTWF0aC5tYXgoLTEsIE1hdGgubWluKDEsIC1lLnNvdXJjZS5kZWx0YVkpKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIYW5kbGUgcGFuIHZpYSB3aGVlbC4gVGhpcyBjb250cm9sIHN1cGVyY2VkZWRzIHpvb21pbmcgdmlhIHBhbi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBpZiAoYXBpLm9wdHMuY29udHJvbHMucGFuT25XaGVlbCl7XHJcbiAgICAgICAgICAgIGlmIChhcGkuZG9tLmNvbnRhaW5lckVsID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50IHx8IGFwaS5kb20uY29udGFpbmVyRWwuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpe1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0ZXAgPSAoZGVsdGEgKiA3NSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJhY3Rpb25zLmlzTW9kS2V5QWN0aXZlKCdTaGlmdCcpKXtcclxuICAgICAgICAgICAgICAgICAgICBzdGVwUGFuKHN0ZXAsIDApO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGVwUGFuKDAsIHN0ZXApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIYW5kbGUgem9vbSB2aWEgd2hlZWwuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaWYgKGFwaS5vcHRzLmNvbnRyb2xzLnpvb21PbldoZWVsKXtcclxuICAgICAgICAgICAgaGFuZGxlWm9vbShlLnNvdXJjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICogUmVzaXplIEhhbmRsZXJcclxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIFwiaW5oZXJlbnRcIiBtaW4gc2NhbGUgYmFzZWQgb24gd2luZG93IHNpemUgYW5kIHJldHVybnMgd2hpY2hldmVyIGlzIGxhcmdlc3QgYmV0d2VlbiB0aGVcclxuICAgICAqIGluaGVyZW50IG1pbiBhbmQgdGhlIG1pbiBzY2FsZSBnaXZlIGluIG9wdGlvbnMuXHJcbiAgICAgKiBcclxuICAgICAqIEBwYXJhbSBjb250YWluZXJSZWN0IFxyXG4gICAgICogQHJldHVybnMgXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGdldE1pblNjYWxlID0gKGNvbnRhaW5lclJlY3Q/OiBET01SZWN0KSA9PiB7XHJcbiAgICAgICAgY29udGFpbmVyUmVjdCA9IGNvbnRhaW5lclJlY3QgPz8gZG9tLmNvbnRhaW5lckVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIHJldHVybiBNYXRoLm1heChcclxuICAgICAgICAgICAgTWF0aC5tYXgoY29udGFpbmVyUmVjdC53aWR0aCAvIHdpZHRoLCBvcHRzLm1pblNjYWxlKSxcclxuICAgICAgICAgICAgTWF0aC5tYXgoY29udGFpbmVyUmVjdC5oZWlnaHQgLyBoZWlnaHQsIG9wdHMubWluU2NhbGUpLFxyXG4gICAgICAgICkgICBcclxuICAgICAgICBcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBoYW5kbGVSZXNpemUgPSAoKSA9PiB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5mb3JjZSBtaW4vbWF4IHNjYWxlIGFuZCBwb3NpdGlvbmluZyBvbiByZXNpemUuIFxyXG4gICAgICAgICAqIFxyXG4gICAgICAgICAqIE5PVEU6IFRoaXMgYmVoYXZpb3IgZG9lc24ndCBzZWVtIHF1aXRlIHJpZ2h0IChzb21ldGltZXMgcmVzZXR0aW5nIHBvc2l0aW9uIG92ZXJ6ZWFsb3VzbHkpLCBcclxuICAgICAgICAgKiBidXQgaXQgZG9lcyBlZmZlY3RpdmVseSBlbnN1cmUgdGhhdCB3ZSBkb24ndCBlbmQgdXAgdy8gaW52YWxpZCBzY2FsZSBvciBwb3NpdGlvbmluZyB3aGljaCBpcyBlbm91Z2ggZm9yIG5vdy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBsZXQgY29udGFpbmVyUmVjdCA9IGRvbS5jb250YWluZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICBsZXQgbWluU2NhbGUgPSBnZXRNaW5TY2FsZShjb250YWluZXJSZWN0KTtcclxuICAgICAgICBsZXQgbmV4dFNjYWxlID0gTWF0aC5tYXgodHJhbnNmb3JtLnNjYWxlLCBtaW5TY2FsZSk7XHJcbiAgICAgICAgbGV0IG1heFggPSAod2lkdGggKiBuZXh0U2NhbGUgLSBjb250YWluZXJSZWN0LndpZHRoKTtcclxuICAgICAgICBsZXQgbWF4WSA9IChoZWlnaHQgKiBuZXh0U2NhbGUgLSBjb250YWluZXJSZWN0LmhlaWdodCk7XHJcbiAgICAgICAgbGV0IG5leHRYID0gLU1hdGgubWluKG1heFgsIE1hdGguYWJzKHRyYW5zZm9ybS54KSk7XHJcbiAgICAgICAgbGV0IG5leHRZID0gLU1hdGgubWluKG1heFksIE1hdGguYWJzKHRyYW5zZm9ybS55KSk7XHJcblxyXG4gICAgICAgIHRyYW5zZm9ybS5zY2FsZSA9IG5leHRTY2FsZVxyXG4gICAgICAgIHRyYW5zZm9ybS54ID0gbmV4dFg7XHJcbiAgICAgICAgdHJhbnNmb3JtLnkgPSBuZXh0WTtcclxuICAgICAgICBhcHBseVRyYW5zZm9ybSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGhhbmRsZVJlc2l6ZVRocm90dGxlZCA9IHRocm90dGxlKGhhbmRsZVJlc2l6ZSwgNTAwKTtcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgICAqIEV2ZW50IGJpbmRpbmdcclxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICovXHJcbiAgICBpbnRlcmFjdGlvbnMub24oJ2RyYWdzdGFydCcsIGhhbmRsZURyYWdTdGFydCk7XHJcbiAgICBpbnRlcmFjdGlvbnMub24oJ3doZWVsJywgaGFuZGxlV2hlZWwpO1xyXG4gICAgaW50ZXJhY3Rpb25zLm9uKCdrZXlkb3duJywgaGFuZGxlS2V5RG93bik7XHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplVGhyb3R0bGVkKTtcclxuICAgIGNvbnN0IGRpc3Bvc2UgPSAoKSA9PiB7XHJcbiAgICAgICAgaW50ZXJhY3Rpb25zLnJlbW92ZUxpc3RlbmVyKCdkcmFnc3RhcnQnLCBoYW5kbGVEcmFnU3RhcnQpO1xyXG4gICAgICAgIGludGVyYWN0aW9ucy5yZW1vdmVMaXN0ZW5lcignZHJhZycsIGhhbmRsZURyYWcpO1xyXG4gICAgICAgIGludGVyYWN0aW9ucy5yZW1vdmVMaXN0ZW5lcignZHJhZ2VuZCcsIGhhbmRsZURyYWdFbmQpO1xyXG4gICAgICAgIGludGVyYWN0aW9ucy5yZW1vdmVMaXN0ZW5lcignd2hlZWwnLCBoYW5kbGVXaGVlbCk7XHJcbiAgICAgICAgaW50ZXJhY3Rpb25zLnJlbW92ZUxpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlS2V5RG93bik7XHJcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZVRocm90dGxlZCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaGFuZGxlWm9vbSA9IChlOiBXaGVlbEV2ZW50KSA9PiB7XHJcbiAgICAgICAgLy9pZiAoIW1ldGhvZHMuZXZlbnRJbkdyYXBoKGUpIHx8IHBhbm5pbmcgfHwgYXBpLmlzTG9ja2VkKCkpIHJldHVybjtcclxuXHJcbiAgICAgICAgLy9lLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgLy9lLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuICAgICAgICBsZXQgY29udGFpbmVyUmVjdCA9IGRvbS5jb250YWluZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICBsZXQgZGVsdGEgPSBNYXRoLm1heCgtMSwgTWF0aC5taW4oMSwgLWUuZGVsdGFZKSk7XHJcbiAgICAgICAgbGV0IHNjYWxlUGFnZVggPSBlLnBhZ2VYIC0gZG9tLmNvbnRhaW5lckVsLm9mZnNldExlZnQ7XHJcbiAgICAgICAgbGV0IHNjYWxlUGFnZVkgPSBlLnBhZ2VZIC0gZG9tLmNvbnRhaW5lckVsLm9mZnNldFRvcDtcclxuICAgICAgICBsZXQgdHJhbnNsYXRlWCA9IC0oKHNjYWxlUGFnZVggLSB0cmFuc2Zvcm0ueCkgLyB0cmFuc2Zvcm0uc2NhbGUpO1xyXG4gICAgICAgIGxldCB0cmFuc2xhdGVZID0gLSgoc2NhbGVQYWdlWSAtIHRyYW5zZm9ybS55KSAvIHRyYW5zZm9ybS5zY2FsZSk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGN1bGF0ZSBvdXIgbWluIGFuZCBtYXggc2NhbGUuIEZvciBtaW4gc2NhbGUgd2UgbXVzdCBlbmZvcmNlIFwiaW5oZXJlbnRcIiBtaW5pbXVtIHRvIHByZXZlbnQgXHJcbiAgICAgICAgICogb3VyIHJvb3QgZWxlbWVudCBmcm9tIGV2ZXIgYmVpbmcgc2NhbGVkIHNvIHNtYWxsIHRoYXQgaXQgZG9lcyBzcGFuIHRoZSBlbnRpcmUgd2lkdGggb2YgdGhlXHJcbiAgICAgICAgICogY29udGFpbmVyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGxldCBtaW5TY2FsZSA9IGdldE1pblNjYWxlKGNvbnRhaW5lclJlY3QpO1xyXG4gICAgICAgIGxldCBtYXhTY2FsZSA9IG9wdHM/Lm1heFNjYWxlITtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsY3VsYXRlIG91ciBuZXh0IHNjYWxlIGFuZCByZXR1cm4gaWYgaXQgdmlvbGF0ZXMgbWluL21heCBjb25zdHJhaW50cy5cclxuICAgICAgICAgKiBVbmNvbW1lbnQgc2NhbGUgdG8gbWFrZSB0aGUgem9vbWluZyBmZWVsIG1vcmUgcG9ycG90aW9uYWwgKGF0IHRoZSBjb3N0XHJcbiAgICAgICAgICogaWYgZWFzaWx5IGRpdmlzaWJsZSBzY2FsZSkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbGV0IG5leHRTY2FsZSA9IHBhcnNlRmxvYXQoICh0cmFuc2Zvcm0uc2NhbGUgKyAoZGVsdGEgKiBvcHRzPy5zY2FsZVN0ZXAhIC8qICogc2NhbGUgKi8pKS50b0ZpeGVkKDIpICk7XHJcbiAgICAgICAgaWYgKG5leHRTY2FsZSA8IG1pblNjYWxlIHx8IG5leHRTY2FsZSA+IG1heFNjYWxlKSByZXR1cm47XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCBvdXIgcG90ZW50aWFsIG5leHQgeCBhbmQgeSBwb3NpdGlvbnNcclxuICAgICAgICAgKi8gXHJcbiAgICAgICAgbGV0IG5leHRYID0gdHJhbnNsYXRlWCAqIG5leHRTY2FsZSArIHNjYWxlUGFnZVg7XHJcbiAgICAgICAgbGV0IG5leHRZID0gdHJhbnNsYXRlWSAqIG5leHRTY2FsZSArIHNjYWxlUGFnZVk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVzZSBvdXIgbmV4dCBzY2FsZSB0byBjYWxjdWxhdGUgd2hhdCB0aGUgbWF4IHggKGxlZnQpIGFuZCB5ICh0b3ApIHBvc2l0aW9uIHdpbGwgYmUuXHJcbiAgICAgICAgICovIFxyXG4gICAgICAgIGxldCBtYXhYID0gKHdpZHRoICogbmV4dFNjYWxlIC0gY29udGFpbmVyUmVjdC53aWR0aCk7XHJcbiAgICAgICAgbGV0IG1heFkgPSAoaGVpZ2h0ICogbmV4dFNjYWxlIC0gY29udGFpbmVyUmVjdC5oZWlnaHQpO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmZvcmNlIG1heCB4L3kgcG9zaXRpb25zLiBcclxuICAgICAgICAgKiBcclxuICAgICAgICAgKiBOT1RFOiBUcmllZCB0byB1c2UgY2xhbXAoKSBtZXRob2QgaGVyZSBidXQgaXQgc2VlbWVkIHRvIGludHJvZHVjZVxyXG4gICAgICAgICAqIHRpbnkgb2Zmc2V0cyB3aGVuIHpvb21pbmcgYWdhaW5zdCBhIGJvdW5kYXJ5LiBNYXliZSBzb21ldGhpbmcgdG8gZG8gdy9cclxuICAgICAgICAgKiBNYXRoLm1pbi9tYXRoLm1heC4gXHJcbiAgICAgICAgICogXHJcbiAgICAgICAgICovIFxyXG4gICAgICAgIGlmIChuZXh0WCA+IDApIG5leHRYID0gMDtcclxuICAgICAgICBpZiAobmV4dFkgPiAwKSBuZXh0WSA9IDA7XHJcbiAgICAgICAgaWYgKG5leHRYIDwgLW1heFgpIG5leHRYID0gLW1heFg7XHJcbiAgICAgICAgaWYgKG5leHRZIDwgLW1heFkpIG5leHRZID0gLW1heFk7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZSBvdXIgdmFsdWVzIGFuZCBhcHBseVxyXG4gICAgICAgICAqLyBcclxuICAgICAgICB0cmFuc2Zvcm0uc2NhbGUgPSBuZXh0U2NhbGU7XHJcbiAgICAgICAgdHJhbnNmb3JtLnggPSBuZXh0WDtcclxuICAgICAgICB0cmFuc2Zvcm0ueSA9IG5leHRZO1xyXG5cclxuICAgICAgICBhcHBseVRyYW5zZm9ybSh0cnVlKTtcclxuICAgICAgICBhcGkuZW1pdCgndHJhbnNmb3JtJywgeyAuLi50cmFuc2Zvcm0gfSk7XHJcbiAgICAgICAgbWV0aG9kcy5yZWNvcmRBY3Rpb24oJ3RyYW5zZm9ybScpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW5mb3JjZSByZXNpemUgXHJcbiAgICAgKi9cclxuICAgIGhhbmRsZVJlc2l6ZSgpO1xyXG4gICAgcmV0dXJuIDxjb25zdD4ge1xyXG4gICAgICAgIG5hbWU6ICdwYW56b29tJyxcclxuICAgICAgICB1cGRhdGUsXHJcbiAgICAgICAgZGlzcG9zZVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBNWEZsb3dQYW5ab29tVG9vbDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/systems/panzoom.ts\n");

/***/ }),

/***/ "./src/systems/select.ts":
/*!*******************************!*\
  !*** ./src/systems/select.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\r\n * MXFlow tool which handles basic selections w/ down and down + shift;\r\n */\nfunction MXFlowSelectTool(api, methods, interactions) {\n  let state = api.state;\n  let dragged = false;\n\n  const update = api => state = api.state;\n\n  const handleDragStart = () => dragged = true;\n\n  const handleDown = evt => {\n    let e = evt.source,\n        item = methods.resolveItem(evt.source);\n    if (!item || !methods.eventInGraph(e)) return; //Clear selection when down event is on graph\n\n    let multi = interactions.isModActive('multiSelectModifier');\n\n    if (item.type === 'graph') {\n      if (multi) return;\n      if (interactions.isModActive('lassoModifier') && e.button === api.opts.controls.lassoButton) return;\n\n      if (e.button === api.opts.controls.selectButton\n      /* && api.dom.containerEl.contains(<HTMLElement> e.target) */\n      ) {\n        methods.setSelected([]);\n      }\n    }\n\n    if (item.type !== 'link' && item.type !== 'node') return;\n\n    if (e.button === api.opts.controls.selectButton) {\n      let noselect = false; //TODO - Check whether target has no-select attribute\n\n      switch (true) {\n        /**\r\n         * Down on a single item, without shift, when there are either no items currently\r\n         * selected, or there is only one and it is the target of the event. Begins drag on a\r\n         * single item.\r\n         */\n        case !multi && !methods.isSelected(item):\n          //case !multi && methods.isSelected(item) && state.selected.size === 1: //Removed because leftover from old drag code?\n          methods.setSelected([item]);\n          break;\n\n        /**\r\n         * With shift held down, mouse down on an item that is not yet selected.\r\n         * Adds the target item to the selections.\r\n         */\n\n        case multi && !methods.isSelected(item):\n          methods.addToSelection([item]);\n          break;\n\n        /**\r\n         * With shift held down, mouse down on an item that is already selected.\r\n         * Deselects the target item.\r\n         */\n\n        case multi && methods.isSelected(item):\n          methods.removeFromSelection([item.key]);\n          break;\n      }\n    }\n  };\n  /**\r\n   * Returns true if all conditions are met under which an up event should be handled\r\n   */\n\n\n  const shouldHandleUpEvt = (e, item) => {\n    return !dragged && !interactions.isModActive('multiSelectModifier') && methods.eventInGraph(e.source) && item && (item.type === 'link' || item.type === 'node') && state.selected.size > 1;\n  };\n  /**\r\n   * Handles the specific case of an `up` event on a node when multiple nodes are selected\r\n   * and no drag event occurred. Deselects all other nodes.\r\n   */\n\n\n  const handleUp = evt => {\n    let item = methods.resolveItem(evt.source);\n\n    if (shouldHandleUpEvt(evt, item)) {\n      methods.setSelected([item]);\n    }\n\n    dragged = false;\n  };\n\n  interactions.on('dragstart', handleDragStart);\n  interactions.on('down', handleDown);\n  interactions.on('up', handleUp);\n\n  const dispose = () => {\n    interactions.removeListener('dragstart', handleDragStart);\n    interactions.removeListener('down', handleDown);\n    interactions.removeListener('up', handleUp);\n  };\n\n  return {\n    name: 'select',\n    dispose,\n    update\n  };\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MXFlowSelectTool);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q25ELFFBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxXQUFSLENBQW9CLEdBQUcsQ0FBQyxNQUF4QixDQUFYOztBQUNBLFFBQUksaUJBQWlCLENBQUMsR0FBRCxFQUFNLElBQU4sQ0FBckIsRUFBaUM7QUFDN0IsYUFBTyxDQUFDLFdBQVIsQ0FBb0IsQ0FBNEIsSUFBNUIsQ0FBcEI7QUFDSDs7QUFDRCxXQUFPLEdBQUcsS0FBVjtBQUNILEdBTkQ7O0FBUUEsY0FBWSxDQUFDLEVBQWIsQ0FBZ0IsV0FBaEIsRUFBNkIsZUFBN0I7QUFDQSxjQUFZLENBQUMsRUFBYixDQUFnQixNQUFoQixFQUF3QixVQUF4QjtBQUNBLGNBQVksQ0FBQyxFQUFiLENBQWdCLElBQWhCLEVBQXNCLFFBQXRCOztBQUNBLFFBQU0sT0FBTyxHQUFHLE1BQUs7QUFDakIsZ0JBQVksQ0FBQyxjQUFiLENBQTRCLFdBQTVCLEVBQXlDLGVBQXpDO0FBQ0EsZ0JBQVksQ0FBQyxjQUFiLENBQTRCLE1BQTVCLEVBQW9DLFVBQXBDO0FBQ0EsZ0JBQVksQ0FBQyxjQUFiLENBQTRCLElBQTVCLEVBQWtDLFFBQWxDO0FBQ0gsR0FKRDs7QUFNQSxTQUFlO0FBQ1gsUUFBSSxFQUFFLFFBREs7QUFFWCxXQUZXO0FBR1g7QUFIVyxHQUFmO0FBS0g7O0FBRUQsaUVBQWUsZ0JBQWYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teGZsb3cvLi9zcmMvc3lzdGVtcy9zZWxlY3QudHM/OGY0YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBGbG93VHlwZXMgZnJvbSAndHlwZXMvZmxvdy50eXBlcy52Mic7XHJcbmltcG9ydCAqIGFzIEludGVyYWN0VHlwZXMgZnJvbSAndHlwZXMvaW50ZXJhY3QudHlwZXMnO1xyXG5cclxuLyoqXHJcbiAqIE1YRmxvdyB0b29sIHdoaWNoIGhhbmRsZXMgYmFzaWMgc2VsZWN0aW9ucyB3LyBkb3duIGFuZCBkb3duICsgc2hpZnQ7XHJcbiAqL1xyXG5mdW5jdGlvbiBNWEZsb3dTZWxlY3RUb29sKGFwaTogRmxvd1R5cGVzLkFwaSwgbWV0aG9kczogRmxvd1R5cGVzLk1ldGhvZHMsIGludGVyYWN0aW9uczogSW50ZXJhY3RUeXBlcy5JbnRlcmFjdGlvbkVtaXR0ZXIpIDogRmxvd1R5cGVzLkFjdGlvbkhhbmRsZXIge1xyXG4gICAgbGV0IHN0YXRlID0gYXBpLnN0YXRlO1xyXG4gICAgbGV0IGRyYWdnZWQgPSBmYWxzZTtcclxuXHJcbiAgICBjb25zdCB1cGRhdGUgPSAoYXBpOiBGbG93VHlwZXMuQXBpKSA9PiBzdGF0ZSA9IGFwaS5zdGF0ZTtcclxuICAgIGNvbnN0IGhhbmRsZURyYWdTdGFydCA9ICgpID0+IGRyYWdnZWQgPSB0cnVlO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZURvd24gPSAoZXZ0OiBJbnRlcmFjdFR5cGVzLk1YUG9pbnRlckV2ZW50KSA9PiB7XHJcbiAgICAgICAgbGV0IGUgPSBldnQuc291cmNlLCBpdGVtID0gbWV0aG9kcy5yZXNvbHZlSXRlbShldnQuc291cmNlKTtcclxuICAgICAgICBpZiAoIWl0ZW0gfHwgIW1ldGhvZHMuZXZlbnRJbkdyYXBoKGUpKSByZXR1cm47XHJcblxyXG4gICAgICAgIC8vQ2xlYXIgc2VsZWN0aW9uIHdoZW4gZG93biBldmVudCBpcyBvbiBncmFwaFxyXG4gICAgICAgIGxldCBtdWx0aSA9IGludGVyYWN0aW9ucy5pc01vZEFjdGl2ZSgnbXVsdGlTZWxlY3RNb2RpZmllcicpO1xyXG4gICAgICAgIGlmIChpdGVtLnR5cGUgPT09ICdncmFwaCcpe1xyXG4gICAgICAgICAgICBpZiAobXVsdGkpIHJldHVybjtcclxuICAgICAgICAgICAgaWYgKGludGVyYWN0aW9ucy5pc01vZEFjdGl2ZSgnbGFzc29Nb2RpZmllcicpICYmIGUuYnV0dG9uID09PSBhcGkub3B0cy5jb250cm9scy5sYXNzb0J1dHRvbikgcmV0dXJuOyBcclxuICAgICAgICAgICAgaWYgKGUuYnV0dG9uID09PSBhcGkub3B0cy5jb250cm9scy5zZWxlY3RCdXR0b24gLyogJiYgYXBpLmRvbS5jb250YWluZXJFbC5jb250YWlucyg8SFRNTEVsZW1lbnQ+IGUudGFyZ2V0KSAqLyl7XHJcbiAgICAgICAgICAgICAgICBtZXRob2RzLnNldFNlbGVjdGVkKFtdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGl0ZW0udHlwZSAhPT0gJ2xpbmsnICYmIGl0ZW0udHlwZSAhPT0gJ25vZGUnKSByZXR1cm47XHJcbiAgICAgICAgaWYgKGUuYnV0dG9uID09PSBhcGkub3B0cy5jb250cm9scy5zZWxlY3RCdXR0b24pe1xyXG4gICAgICAgICAgICBsZXQgbm9zZWxlY3QgPSBmYWxzZTsgLy9UT0RPIC0gQ2hlY2sgd2hldGhlciB0YXJnZXQgaGFzIG5vLXNlbGVjdCBhdHRyaWJ1dGVcclxuICAgICAgICAgICAgc3dpdGNoICh0cnVlKXtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRG93biBvbiBhIHNpbmdsZSBpdGVtLCB3aXRob3V0IHNoaWZ0LCB3aGVuIHRoZXJlIGFyZSBlaXRoZXIgbm8gaXRlbXMgY3VycmVudGx5IFxyXG4gICAgICAgICAgICAgICAgICogc2VsZWN0ZWQsIG9yIHRoZXJlIGlzIG9ubHkgb25lIGFuZCBpdCBpcyB0aGUgdGFyZ2V0IG9mIHRoZSBldmVudC4gQmVnaW5zIGRyYWcgb24gYVxyXG4gICAgICAgICAgICAgICAgICogc2luZ2xlIGl0ZW0uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGNhc2UgIW11bHRpICYmICFtZXRob2RzLmlzU2VsZWN0ZWQoaXRlbSk6XHJcbiAgICAgICAgICAgICAgICAvL2Nhc2UgIW11bHRpICYmIG1ldGhvZHMuaXNTZWxlY3RlZChpdGVtKSAmJiBzdGF0ZS5zZWxlY3RlZC5zaXplID09PSAxOiAvL1JlbW92ZWQgYmVjYXVzZSBsZWZ0b3ZlciBmcm9tIG9sZCBkcmFnIGNvZGU/XHJcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kcy5zZXRTZWxlY3RlZChbaXRlbV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBXaXRoIHNoaWZ0IGhlbGQgZG93biwgbW91c2UgZG93biBvbiBhbiBpdGVtIHRoYXQgaXMgbm90IHlldCBzZWxlY3RlZC5cclxuICAgICAgICAgICAgICAgICAqIEFkZHMgdGhlIHRhcmdldCBpdGVtIHRvIHRoZSBzZWxlY3Rpb25zLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBjYXNlIG11bHRpICYmICFtZXRob2RzLmlzU2VsZWN0ZWQoaXRlbSk6XHJcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kcy5hZGRUb1NlbGVjdGlvbihbaXRlbV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFdpdGggc2hpZnQgaGVsZCBkb3duLCBtb3VzZSBkb3duIG9uIGFuIGl0ZW0gdGhhdCBpcyBhbHJlYWR5IHNlbGVjdGVkLlxyXG4gICAgICAgICAgICAgICAgICogRGVzZWxlY3RzIHRoZSB0YXJnZXQgaXRlbS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgY2FzZSBtdWx0aSAmJiBtZXRob2RzLmlzU2VsZWN0ZWQoaXRlbSk6XHJcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kcy5yZW1vdmVGcm9tU2VsZWN0aW9uKFtpdGVtLmtleV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBhbGwgY29uZGl0aW9ucyBhcmUgbWV0IHVuZGVyIHdoaWNoIGFuIHVwIGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IHNob3VsZEhhbmRsZVVwRXZ0ID0gKGU6IEludGVyYWN0VHlwZXMuTVhQb2ludGVyRXZlbnQsIGl0ZW0/OiBGbG93VHlwZXMuRmxvd0l0ZW0pID0+IHtcclxuICAgICAgICByZXR1cm4gICFkcmFnZ2VkICYmXHJcbiAgICAgICAgICAgICAgICAhaW50ZXJhY3Rpb25zLmlzTW9kQWN0aXZlKCdtdWx0aVNlbGVjdE1vZGlmaWVyJykgJiZcclxuICAgICAgICAgICAgICAgIG1ldGhvZHMuZXZlbnRJbkdyYXBoKGUuc291cmNlKSAmJiBcclxuICAgICAgICAgICAgICAgIGl0ZW0gJiYgKGl0ZW0udHlwZSA9PT0gJ2xpbmsnIHx8IGl0ZW0udHlwZSA9PT0gJ25vZGUnKSAmJlxyXG4gICAgICAgICAgICAgICAgc3RhdGUuc2VsZWN0ZWQuc2l6ZSA+IDFcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXMgdGhlIHNwZWNpZmljIGNhc2Ugb2YgYW4gYHVwYCBldmVudCBvbiBhIG5vZGUgd2hlbiBtdWx0aXBsZSBub2RlcyBhcmUgc2VsZWN0ZWRcclxuICAgICAqIGFuZCBubyBkcmFnIGV2ZW50IG9jY3VycmVkLiBEZXNlbGVjdHMgYWxsIG90aGVyIG5vZGVzLlxyXG4gICAgICovXHJcbiAgICBjb25zdCBoYW5kbGVVcCA9IChldnQ6IEludGVyYWN0VHlwZXMuTVhQb2ludGVyRXZlbnQpID0+IHtcclxuICAgICAgICBsZXQgaXRlbSA9IG1ldGhvZHMucmVzb2x2ZUl0ZW0oZXZ0LnNvdXJjZSk7XHJcbiAgICAgICAgaWYgKHNob3VsZEhhbmRsZVVwRXZ0KGV2dCwgaXRlbSkpe1xyXG4gICAgICAgICAgICBtZXRob2RzLnNldFNlbGVjdGVkKFs8Rmxvd1R5cGVzLlNlbGVjdGFibGVJdGVtPiBpdGVtXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRyYWdnZWQgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpbnRlcmFjdGlvbnMub24oJ2RyYWdzdGFydCcsIGhhbmRsZURyYWdTdGFydCk7XHJcbiAgICBpbnRlcmFjdGlvbnMub24oJ2Rvd24nLCBoYW5kbGVEb3duKTtcclxuICAgIGludGVyYWN0aW9ucy5vbigndXAnLCBoYW5kbGVVcCk7XHJcbiAgICBjb25zdCBkaXNwb3NlID0gKCkgPT4ge1xyXG4gICAgICAgIGludGVyYWN0aW9ucy5yZW1vdmVMaXN0ZW5lcignZHJhZ3N0YXJ0JywgaGFuZGxlRHJhZ1N0YXJ0KTtcclxuICAgICAgICBpbnRlcmFjdGlvbnMucmVtb3ZlTGlzdGVuZXIoJ2Rvd24nLCBoYW5kbGVEb3duKTtcclxuICAgICAgICBpbnRlcmFjdGlvbnMucmVtb3ZlTGlzdGVuZXIoJ3VwJywgaGFuZGxlVXApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiA8Y29uc3Q+IHtcclxuICAgICAgICBuYW1lOiAnc2VsZWN0JyxcclxuICAgICAgICBkaXNwb3NlLFxyXG4gICAgICAgIHVwZGF0ZVxyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBNWEZsb3dTZWxlY3RUb29sOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/systems/select.ts\n");

/***/ }),

/***/ "./src/systems/shortcut.ts":
/*!*********************************!*\
  !*** ./src/systems/shortcut.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var hotkeys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hotkeys-js */ \"./node_modules/hotkeys-js/dist/hotkeys.esm.js\");\n\n/**\r\n * Handlers for various shortcuts\r\n */\n\nfunction MXFlowShortcutTool(api, methods) {\n  const handleUndo = (e, handler) => {\n    if (!methods.eventInGraph(e)) return;\n    e.preventDefault();\n    e.stopPropagation();\n    methods.undo();\n  };\n\n  const handleRedo = (e, handler) => {\n    if (!methods.eventInGraph(e)) return;\n    e.preventDefault();\n    e.stopPropagation();\n    methods.redo();\n  };\n\n  const handleDelete = (e, handler) => {\n    if (!methods.eventInGraph(e)) return;\n    e.preventDefault();\n    e.stopPropagation();\n    methods.removeSelectedItems();\n  };\n\n  (0,hotkeys_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('delete', {\n    element: api.dom.containerEl\n  }, handleDelete);\n  (0,hotkeys_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('ctrl+z, command+z', {\n    element: api.dom.containerEl\n  }, handleUndo);\n  (0,hotkeys_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('ctrl+shift+z, command+shift+z, ctrl+y, command+y', {\n    element: api.dom.containerEl\n  }, handleRedo);\n\n  const dispose = () => {\n    hotkeys_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].unbind('delete', handleDelete);\n    hotkeys_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].unbind('ctrl+z, command+z', handleUndo);\n    hotkeys_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].unbind('ctrl+shift+z, command+shift+z, ctrl+y, command+y', handleRedo);\n  };\n\n  return {\n    name: 'shortcut',\n    dispose\n  };\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (MXFlowShortcutTool);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3lzdGVtcy9zaG9ydGN1dC50cy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUVBO0FBRUE7O0FBRUc7O0FBQ0gsU0FBUyxrQkFBVCxDQUE0QixHQUE1QixFQUFnRCxPQUFoRCxFQUE4RjtBQUcxRixRQUFNLFVBQVUsR0FBRyxDQUFDLENBQUQsRUFBbUIsT0FBbkIsS0FBNEM7QUFDM0QsUUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFSLENBQXFCLENBQXJCLENBQUwsRUFBOEI7QUFFOUIsS0FBQyxDQUFDLGNBQUY7QUFDQSxLQUFDLENBQUMsZUFBRjtBQUVBLFdBQU8sQ0FBQyxJQUFSO0FBQ0gsR0FQRDs7QUFTQSxRQUFNLFVBQVUsR0FBRyxDQUFDLENBQUQsRUFBbUIsT0FBbkIsS0FBNEM7QUFDM0QsUUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFSLENBQXFCLENBQXJCLENBQUwsRUFBOEI7QUFFOUIsS0FBQyxDQUFDLGNBQUY7QUFDQSxLQUFDLENBQUMsZUFBRjtBQUVBLFdBQU8sQ0FBQyxJQUFSO0FBQ0gsR0FQRDs7QUFTQSxRQUFNLFlBQVksR0FBRyxDQUFDLENBQUQsRUFBbUIsT0FBbkIsS0FBNEM7QUFDN0QsUUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFSLENBQXFCLENBQXJCLENBQUwsRUFBOEI7QUFFOUIsS0FBQyxDQUFDLGNBQUY7QUFDQSxLQUFDLENBQUMsZUFBRjtBQUVBLFdBQU8sQ0FBQyxtQkFBUjtBQUNILEdBUEQ7O0FBU0Esd0RBQU8sQ0FBQyxRQUFELEVBQVc7QUFBRSxXQUFPLEVBQUUsR0FBRyxDQUFDLEdBQUosQ0FBUTtBQUFuQixHQUFYLEVBQTZDLFlBQTdDLENBQVA7QUFDQSx3REFBTyxDQUFDLG1CQUFELEVBQXNCO0FBQUUsV0FBTyxFQUFFLEdBQUcsQ0FBQyxHQUFKLENBQVE7QUFBbkIsR0FBdEIsRUFBd0QsVUFBeEQsQ0FBUDtBQUNBLHdEQUFPLENBQUMsa0RBQUQsRUFBcUQ7QUFBRSxXQUFPLEVBQUUsR0FBRyxDQUFDLEdBQUosQ0FBUTtBQUFuQixHQUFyRCxFQUF1RixVQUF2RixDQUFQOztBQUNBLFFBQU0sT0FBTyxHQUFHLE1BQUs7QUFDakIsOERBQWUsUUFBZixFQUF5QixZQUF6QjtBQUNBLDhEQUFlLG1CQUFmLEVBQW9DLFVBQXBDO0FBQ0EsOERBQWUsa0RBQWYsRUFBbUUsVUFBbkU7QUFDSCxHQUpEOztBQU1BLFNBQWU7QUFDWCxRQUFJLEVBQUUsVUFESztBQUVYO0FBRlcsR0FBZjtBQUlIOztBQUVELGlFQUFlLGtCQUFmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXhmbG93Ly4vc3JjL3N5c3RlbXMvc2hvcnRjdXQudHM/MmU0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBGbG93VHlwZXMgZnJvbSAndHlwZXMvZmxvdy50eXBlcy52Mic7XHJcbmltcG9ydCB7IGdldFB1YmxpY0ludGVyZmFjZSB9IGZyb20gJy4uL21ldGhvZHMnO1xyXG5pbXBvcnQgaG90a2V5cywgeyBIb3RrZXlzRXZlbnQgfSBmcm9tICdob3RrZXlzLWpzJztcclxuXHJcbi8qKlxyXG4gKiBIYW5kbGVycyBmb3IgdmFyaW91cyBzaG9ydGN1dHNcclxuICovXHJcbmZ1bmN0aW9uIE1YRmxvd1Nob3J0Y3V0VG9vbChhcGk6IEZsb3dUeXBlcy5BcGksIG1ldGhvZHM6IFJldHVyblR5cGU8dHlwZW9mIGdldFB1YmxpY0ludGVyZmFjZT4pIDogRmxvd1R5cGVzLkFjdGlvbkhhbmRsZXIge1xyXG5cclxuXHJcbiAgICBjb25zdCBoYW5kbGVVbmRvID0gKGU6IEtleWJvYXJkRXZlbnQsIGhhbmRsZXI6IEhvdGtleXNFdmVudCkgPT4ge1xyXG4gICAgICAgIGlmICghbWV0aG9kcy5ldmVudEluR3JhcGgoZSkpIHJldHVybjtcclxuXHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgICAgIG1ldGhvZHMudW5kbygpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGhhbmRsZVJlZG8gPSAoZTogS2V5Ym9hcmRFdmVudCwgaGFuZGxlcjogSG90a2V5c0V2ZW50KSA9PiB7XHJcbiAgICAgICAgaWYgKCFtZXRob2RzLmV2ZW50SW5HcmFwaChlKSkgcmV0dXJuO1xyXG5cclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHJcbiAgICAgICAgbWV0aG9kcy5yZWRvKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaGFuZGxlRGVsZXRlID0gKGU6IEtleWJvYXJkRXZlbnQsIGhhbmRsZXI6IEhvdGtleXNFdmVudCkgPT4ge1xyXG4gICAgICAgIGlmICghbWV0aG9kcy5ldmVudEluR3JhcGgoZSkpIHJldHVybjtcclxuXHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgICAgIG1ldGhvZHMucmVtb3ZlU2VsZWN0ZWRJdGVtcygpO1xyXG4gICAgfVxyXG5cclxuICAgIGhvdGtleXMoJ2RlbGV0ZScsIHsgZWxlbWVudDogYXBpLmRvbS5jb250YWluZXJFbCB9LCBoYW5kbGVEZWxldGUpO1xyXG4gICAgaG90a2V5cygnY3RybCt6LCBjb21tYW5kK3onLCB7IGVsZW1lbnQ6IGFwaS5kb20uY29udGFpbmVyRWwgfSwgaGFuZGxlVW5kbyk7XHJcbiAgICBob3RrZXlzKCdjdHJsK3NoaWZ0K3osIGNvbW1hbmQrc2hpZnQreiwgY3RybCt5LCBjb21tYW5kK3knLCB7IGVsZW1lbnQ6IGFwaS5kb20uY29udGFpbmVyRWwgfSwgaGFuZGxlUmVkbyk7XHJcbiAgICBjb25zdCBkaXNwb3NlID0gKCkgPT4ge1xyXG4gICAgICAgIGhvdGtleXMudW5iaW5kKCdkZWxldGUnLCBoYW5kbGVEZWxldGUpO1xyXG4gICAgICAgIGhvdGtleXMudW5iaW5kKCdjdHJsK3osIGNvbW1hbmQreicsIGhhbmRsZVVuZG8pO1xyXG4gICAgICAgIGhvdGtleXMudW5iaW5kKCdjdHJsK3NoaWZ0K3osIGNvbW1hbmQrc2hpZnQreiwgY3RybCt5LCBjb21tYW5kK3knLCBoYW5kbGVSZWRvKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gPGNvbnN0PiB7XHJcbiAgICAgICAgbmFtZTogJ3Nob3J0Y3V0JyxcclxuICAgICAgICBkaXNwb3NlXHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1YRmxvd1Nob3J0Y3V0VG9vbDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/systems/shortcut.ts\n");

/***/ }),

/***/ "./src/types/flow.types.v2.ts":
/*!************************************!*\
  !*** ./src/types/flow.types.v2.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ActionTypes\": () => (/* binding */ ActionTypes),\n/* harmony export */   \"FlowAttr\": () => (/* binding */ FlowAttr),\n/* harmony export */   \"FlowClass\": () => (/* binding */ FlowClass),\n/* harmony export */   \"FlowItemType\": () => (/* binding */ FlowItemType),\n/* harmony export */   \"LinkLatchPosition\": () => (/* binding */ LinkLatchPosition)\n/* harmony export */ });\n/**\r\n * Posssible positions for link to latch to edge\r\n */\nvar LinkLatchPosition;\n\n(function (LinkLatchPosition) {\n  LinkLatchPosition[\"TOP\"] = \"top\";\n  LinkLatchPosition[\"RIGHT\"] = \"right\";\n  LinkLatchPosition[\"LEFT\"] = \"left\";\n  LinkLatchPosition[\"BOTTOM\"] = \"bottom\";\n  LinkLatchPosition[\"CENTER\"] = \"center\";\n})(LinkLatchPosition || (LinkLatchPosition = {})); // enum RenderableType {\n//     Node = 'node',\n//     Edge = 'edge',\n//     //Context = 'context'\n// }\n\n\nvar FlowItemType;\n\n(function (FlowItemType) {\n  FlowItemType[\"None\"] = \"none\";\n  FlowItemType[\"Graph\"] = \"graph\";\n  FlowItemType[\"Link\"] = \"link\";\n  FlowItemType[\"Node\"] = \"node\";\n  FlowItemType[\"Edge\"] = \"edge\";\n})(FlowItemType || (FlowItemType = {}));\n/**\r\n * The data attribute keys applied to all graph entities\r\n */\n\n\nvar FlowAttr;\n\n(function (FlowAttr) {\n  FlowAttr[\"Type\"] = \"data-mxflow-type\";\n  FlowAttr[\"Key\"] = \"data-mxflow-key\";\n  FlowAttr[\"NodeTemplate\"] = \"data-mxflow-node-template\";\n  FlowAttr[\"NodeContent\"] = \"data-mxflow-node-content\";\n  FlowAttr[\"EdgeGroup\"] = \"data-mxflow-edge-group\";\n  FlowAttr[\"EdgeLatch\"] = \"data-mxflow-edge-latch\";\n})(FlowAttr || (FlowAttr = {}));\n\nvar FlowClass;\n\n(function (FlowClass) {\n  FlowClass[\"Container\"] = \"mxflow-container\";\n  FlowClass[\"Root\"] = \"mxflow-root\";\n  FlowClass[\"RootPanning\"] = \"mxflow-root--panning\";\n  FlowClass[\"Background\"] = \"mxflow-background\";\n  FlowClass[\"Dots\"] = \"mxflow-dots\";\n  FlowClass[\"Grid\"] = \"mxflow-grid\";\n  FlowClass[\"GridInner\"] = \"mxflow-grid-inner\";\n  FlowClass[\"GridOuter\"] = \"mxflow-grid-outer\";\n  FlowClass[\"Context\"] = \"mxflow-context\";\n  FlowClass[\"ItemSelected\"] = \"mxflow-item--selected\";\n  FlowClass[\"ItemPreselected\"] = \"mxflow-item--preselected\";\n  FlowClass[\"Nodes\"] = \"mxflow-nodes\";\n  FlowClass[\"Node\"] = \"mxflow-node\";\n  FlowClass[\"NodeContent\"] = \"mxflow-node-content\";\n  FlowClass[\"EdgeGroup\"] = \"mxflow-edge-group\";\n  FlowClass[\"Edge\"] = \"mxflow-edge\";\n  FlowClass[\"EdgeValid\"] = \"mxflow-edge--valid\";\n  FlowClass[\"EdgeInvalid\"] = \"mxflow-edge--invalid\";\n  FlowClass[\"Lasso\"] = \"mxflow-lasso\";\n  FlowClass[\"Links\"] = \"mxlflow-links\";\n  FlowClass[\"Link\"] = \"mxflow-link\"; // LinkInner = 'mxflow-link-inner',\n  // LinkOuter = 'mxflow-link-outer',\n\n  FlowClass[\"LinkBand1\"] = \"mxflow-link-band1\";\n  FlowClass[\"LinkBand2\"] = \"mxflow-link-band2\";\n  FlowClass[\"LinkBand3\"] = \"mxflow-link-band3\";\n  FlowClass[\"LinkValid\"] = \"mxflow-link--valid\";\n  FlowClass[\"LinkInvalid\"] = \"mxflow-link--invalid\";\n  FlowClass[\"GhostLinks\"] = \"mxflow-ghost-links\";\n  FlowClass[\"GhostLink\"] = \"mxflow-ghost-link\";\n})(FlowClass || (FlowClass = {}));\n\nconst ActionTypes = {\n  TRANSFORM: 'transform',\n  SELECT: 'select',\n  DRAG: 'drag',\n  ADD_EDGE: 'addEdge',\n  REMOVE_EDGE: 'removeEdge',\n  ADD_NODE: 'addNode',\n  REMOVE_NODE: 'removeNode',\n  ADD_LINK: 'addLink',\n  REMOVE_LINK: 'removeLink',\n  REMOVE_ITEMS: 'removeItems',\n  CLEAR: 'clear',\n  CUSTOM: 'custom'\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdHlwZXMvZmxvdy50eXBlcy52Mi50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQXFMQTs7QUFFRztBQUNILElBQUssaUJBQUw7O0FBQUEsV0FBSyxpQkFBTCxFQUFzQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0gsQ0FORCxFQUFLLGlCQUFpQixLQUFqQixpQkFBaUIsTUFBdEIsR0E0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUEsSUFBSyxZQUFMOztBQUFBLFdBQUssWUFBTCxFQUFpQjtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSCxDQU5ELEVBQUssWUFBWSxLQUFaLFlBQVksTUFBakI7QUFRQTs7QUFFRzs7O0FBQ0gsSUFBSyxRQUFMOztBQUFBLFdBQUssUUFBTCxFQUFhO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0gsQ0FQRCxFQUFLLFFBQVEsS0FBUixRQUFRLE1BQWI7O0FBU0EsSUFBSyxTQUFMOztBQUFBLFdBQUssU0FBTCxFQUFjO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQXJCVSxDQXNCVjtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0gsQ0EvQkQsRUFBSyxTQUFTLEtBQVQsU0FBUyxNQUFkOztBQStDQSxNQUFNLFdBQVcsR0FBVztBQUN4QixXQUFTLEVBQUUsV0FEYTtBQUV4QixRQUFNLEVBQUUsUUFGZ0I7QUFHeEIsTUFBSSxFQUFFLE1BSGtCO0FBSXhCLFVBQVEsRUFBRSxTQUpjO0FBS3hCLGFBQVcsRUFBRSxZQUxXO0FBTXhCLFVBQVEsRUFBRSxTQU5jO0FBT3hCLGFBQVcsRUFBRSxZQVBXO0FBUXhCLFVBQVEsRUFBRSxTQVJjO0FBU3hCLGFBQVcsRUFBRSxZQVRXO0FBVXhCLGNBQVksRUFBRSxhQVZVO0FBV3hCLE9BQUssRUFBRSxPQVhpQjtBQVl4QixRQUFNLEVBQUU7QUFaZ0IsQ0FBNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teGZsb3cvLi9zcmMvdHlwZXMvZmxvdy50eXBlcy52Mi50cz9jM2M1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1YRmxvd0NvbnRyb2xsZXJJbnN0YW5jZSB9IGZyb20gXCIuLi9mbG93XCI7XHJcbmltcG9ydCB7IGdldFB1YmxpY0ludGVyZmFjZSB9IGZyb20gJy4uL21ldGhvZHMnO1xyXG5cclxudHlwZSBOb09wdGlvbmFsczxUPiA9IHtcclxuICAgIFtQIGluIGtleW9mIFRdLT86IFRbUF07XHJcbn07XHJcblxyXG5pbnRlcmZhY2UgUmVjdCB7XHJcbiAgICBsZWZ0OiBudW1iZXIsXHJcbiAgICByaWdodDogbnVtYmVyLFxyXG4gICAgdG9wOiBudW1iZXIsXHJcbiAgICBib3R0b206IG51bWJlclxyXG59XHJcblxyXG5pbnRlcmZhY2UgRmxvd0RvbSB7XHJcbiAgICBpbnN0YW5jZUlkOiBzdHJpbmcsXHJcbiAgICBjb250YWluZXJFbDogSFRNTERpdkVsZW1lbnRcclxuICAgIGxhc3NvRWw6IFNWR0VsZW1lbnRcclxuICAgIGNvbnRleHRFbDogSFRNTERpdkVsZW1lbnRcclxuICAgIHJvb3RFbDogSFRNTERpdkVsZW1lbnRcclxuICAgIGJnRWw6IEhUTUxEaXZFbGVtZW50LFxyXG4gICAgbm9kZUNvbnRhaW5lckVsOiBIVE1MRGl2RWxlbWVudFxyXG4gICAgbGlua0NvbnRhaW5lckVsOiBTVkdFbGVtZW50XHJcbiAgICBnaG9zdExpbmtDb250YWluZXJFbDogU1ZHRWxlbWVudFxyXG4gICAgZ2hvc3RMaW5rRWw6IFNWR1BhdGhFbGVtZW50XHJcbn1cclxuXHJcbmludGVyZmFjZSBGbG93U3RhdGUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc2luZ3VsYXIgXCJncmFwaFwiIGl0ZW1cclxuICAgICAqL1xyXG4gICAgcm9vdDogR3JhcGgsXHJcbiAgICAvKipcclxuICAgICAqIEVudGl0eSBjb2xsZWN0aW9uc1xyXG4gICAgICovXHJcbiAgICBub2RlczogTWFwPHN0cmluZywgTm9kZT4sXHJcbiAgICBlZGdlczogTWFwPHN0cmluZywgRWRnZT4sXHJcbiAgICBsaW5rczogTWFwPHN0cmluZywgTGluaz4sXHJcbiAgICAvKipcclxuICAgICAqIFByZXNlbGVjdGlvbiAoZm9yIGxhc3NvIHRvb2wpIGFuZCBzZWxlY3Rpb24gY29sbGVjdGlvbnNcclxuICAgICAqL1xyXG4gICAgcHJlc2VsZWN0ZWQ6IE1hcDxzdHJpbmcsIFNlbGVjdGFibGVJdGVtPixcclxuICAgIHNlbGVjdGVkOiBNYXA8c3RyaW5nLCBTZWxlY3RhYmxlSXRlbT4sXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhlIGNvbnRleHQgbWVudSBpcyBjdXJyZW50bHkgb3BlblxyXG4gICAgICovXHJcbiAgICBjb250ZXh0T3BlbjogYm9vbGVhbixcclxuXHJcbiAgICAvLyBtdWx0aTogYm9vbGVhbixcclxuICAgIHVuZG86IEFjdGlvbltdLFxyXG4gICAgcmVkbzogQWN0aW9uW10sXHJcbiAgICB0cmFuc2Zvcm06IFRyYW5zZm9ybVxyXG59XHJcblxyXG5pbnRlcmZhY2UgRmxvd0ludGVybmFsQXBpIHtcclxuICAgIG9wdHM6IE9wdGlvbnMsXHJcbiAgICBkb206IEZsb3dEb20sXHJcbiAgICBzdGF0ZTogRmxvd1N0YXRlLFxyXG4gICAgc2V0U2VsZWN0ZWQ6IChzZWxlY3RlZDogU2VsZWN0YWJsZUl0ZW1bXSB8IE1hcDxzdHJpbmcsIFNlbGVjdGFibGVJdGVtPikgPT4gdm9pZCxcclxuICAgIGFkZFRvU2VsZWN0aW9uOiAoaXRlbXM6IFNlbGVjdGFibGVJdGVtW10pID0+IHZvaWQsXHJcbiAgICByZW1vdmVGcm9tU2VsZWN0aW9uOiAoa2V5czogc3RyaW5nW10pID0+IHZvaWQsXHJcbiAgICBlbWl0OiA8SyBleHRlbmRzIGtleW9mIEZsb3dFdmVudE1hcD4odHlwZTogSywgZXZlbnQ/OiBGbG93RXZlbnRNYXBbS10pID0+IHZvaWRcclxufVxyXG5cclxuaW50ZXJmYWNlIFRyYW5zZm9ybU1vZGVsIHtcclxuICAgIHNjYWxlOiBudW1iZXIsXHJcbiAgICB4OiBudW1iZXIsXHJcbiAgICB5OiBudW1iZXJcclxufVxyXG5cclxuaW50ZXJmYWNlIE5vZGVNb2RlbCB7XHJcbiAgICBzZWxlY3RlZDogYm9vbGVhbixcclxuICAgIHg6IG51bWJlcixcclxuICAgIHk6IG51bWJlcixcclxuICAgIHdpZHRoOiBudW1iZXIgfCBzdHJpbmcsXHJcbiAgICBoZWlnaHQ6IG51bWJlciB8IHN0cmluZyxcclxuICAgIGNsYXNzOiBzdHJpbmdbXSxcclxuICAgIGRhdGE6IFNlcmlhbGl6YWJsZVxyXG59XHJcblxyXG5pbnRlcmZhY2UgRWRnZU1vZGVsIHtcclxuICAgIG5vZGVLZXk6IHN0cmluZyxcclxuICAgIGVkZ2VLZXk6IHN0cmluZyxcclxuICAgIGdyb3VwS2V5OiBzdHJpbmcsXHJcbiAgICBkYXRhOiBTZXJpYWxpemFibGUsXHJcbiAgICBjbGFzczogc3RyaW5nXHJcbn1cclxuXHJcbmludGVyZmFjZSBMaW5rTW9kZWwge1xyXG4gICAgc2VsZWN0ZWQ6IGJvb2xlYW4sXHJcbiAgICBmcm9tTm9kZTogc3RyaW5nLFxyXG4gICAgZnJvbUVkZ2U6IHN0cmluZyxcclxuICAgIHRvTm9kZTogc3RyaW5nLFxyXG4gICAgdG9FZGdlOiBzdHJpbmcsXHJcbiAgICBkYXRhOiBTZXJpYWxpemFibGVcclxufVxyXG5cclxuaW50ZXJmYWNlIE1vZGVsIHtcclxuICAgIHRyYW5zZm9ybTogVHJhbnNmb3JtTW9kZWwsXHJcbiAgICBub2RlczogeyBba2V5OnN0cmluZ106IE5vZGVNb2RlbCB9LFxyXG4gICAgZWRnZXM6IHsgW2tleTogc3RyaW5nXTogRWRnZU1vZGVsIH0sXHJcbiAgICBsaW5rczogeyBba2V5OnN0cmluZ106IExpbmtNb2RlbCB9XHJcbn1cclxuXHJcbnR5cGUgQ29udGVudE1vZGVsSXRlbSA9IE5vZGVNb2RlbCB8IEVkZ2VNb2RlbDsgLy9Nb2RlbCBpdGVtcyB3aG9zZSBhY3R1YWwgaXRlbXMgaGF2ZSBjb250ZW50IHNlY3Rpb25zXHJcblxyXG5cclxuaW50ZXJmYWNlIFNlcmlhbGl6YWJsZSB7XHJcbiAgICBba2V5OnN0cmluZ106IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkIHwgU2VyaWFsaXphYmxlO1xyXG59XHJcblxyXG4vKipcclxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqIERyYWcgQ29udHJvbGxlciBUeXBlc1xyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICovXHJcbmludGVyZmFjZSBHcmFwaCB7XHJcbiAgICBrZXk6ICdncmFwaCcsXHJcbiAgICB0eXBlOiBGbG93SXRlbVR5cGUuR3JhcGgsXHJcbiAgICBlbDogSFRNTEVsZW1lbnRcclxufVxyXG5cclxuaW50ZXJmYWNlIE5vZGUge1xyXG4gICAgdHlwZTogRmxvd0l0ZW1UeXBlLk5vZGUsXHJcbiAgICBrZXk6IHN0cmluZyxcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRlbXBsYXRlIHVzZWQgdG8gZ2VuZXJhdGUgdGhpcyBub2RlLiBUaGlzIHZhbHVlIGlzIGF1dG9wb3B1bGF0ZWQgYmFzZWQgb24gdGhlIGdsb2JhbFxyXG4gICAgICogYG5vZGVIVE1MVGVtcGxhdGVgIG9wdGlvbiwgYnV0IGNhbiBiZSBzcGVjaWZpZWQgaW5kaXZpZHVhbGx5IHdoZW4gY3JlYXRpbmcgYSBub2RlLlxyXG4gICAgICovXHJcbiAgICB0ZW1wbGF0ZTogc3RyaW5nLFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgb3V0ZXIgbm9kZSBlbGVtZW50XHJcbiAgICAgKi9cclxuICAgIGVsOiBIVE1MRWxlbWVudCxcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNvbnRhaW5lciBmb3IgcmVuZGVyZWQgY29udGVudFxyXG4gICAgICovXHJcbiAgICBjb250ZW50RWw6IEhUTUxFbGVtZW50LFxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXAgb2YgZWRnZSBncm91cHMgZ2VuZXJhdGVkIGFmdGVyIHRlbXBhbHRlIHBhcnNpbmdcclxuICAgICAqL1xyXG4gICAgZWRnZUdyb3VwczogTWFwPHN0cmluZywgRWRnZUdyb3VwPixcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG5vZGUncyBjdXJyZW50IHBvc2l0aW9uIGFuZCBzaXplXHJcbiAgICAgKi9cclxuICAgIHg6IG51bWJlcixcclxuICAgIHk6IG51bWJlcixcclxuICAgIHo6IG51bWJlcixcclxuICAgIHdpZHRoOiBudW1iZXIgfCBzdHJpbmcsXHJcbiAgICBoZWlnaHQ6IG51bWJlciAgfCBzdHJpbmcsXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBub2RlJ3Mgb2Zmc2V0IHBvc2l0aW9uIGR1cmluZyBhIGRyYWcgb3BlcmF0aW9uLiBBbHdheXMgemVybyB1bmxlc3NcclxuICAgICAqIGFjdGl2ZWx5IGRyYWdnaW5nLlxyXG4gICAgICovXHJcbiAgICBkZWx0YVg6IG51bWJlcixcclxuICAgIGRlbHRhWTogbnVtYmVyLFxyXG4gICAgLyoqXHJcbiAgICAgKiBDb250YWluZXIgZm9yIGFueSB1c2VyLWF0dGFjaGVkIGRhdGEgZm9yIHRoaXMgbm9kZVxyXG4gICAgICovXHJcbiAgICBkYXRhOiBTZXJpYWxpemFibGVcclxuICAgIC8qKlxyXG4gICAgICogVXNlciBjbGFzc2VzXHJcbiAgICAgKi9cclxuICAgIGNsYXNzOiBzdHJpbmdbXVxyXG59XHJcblxyXG50eXBlIEFkZE5vZGVPcHRpb25zID0ge1xyXG4gICAgY2xhc3M/OiBzdHJpbmcgfCBzdHJpbmdbXSxcclxuICAgIGRhdGE/OiBTZXJpYWxpemFibGUsXHJcbiAgICB3aWR0aD86IHN0cmluZyB8IG51bWJlcixcclxuICAgIGhlaWdodD86IHN0cmluZyB8IG51bWJlcixcclxuICAgIGVkZ2VzPzogeyBcclxuICAgICAgICBncm91cDogc3RyaW5nLCBcclxuICAgICAgICBrZXk6IHN0cmluZywgXHJcbiAgICAgICAgZGF0YT86IFNlcmlhbGl6YWJsZSxcclxuICAgICAgICBjbGFzcz86IHN0cmluZ1xyXG4gICAgfVtdLFxyXG4gICAgeD86IG51bWJlcixcclxuICAgIHk/OiBudW1iZXIsXHJcbn0gJiBBY3Rpb25FeHRlbmRlZE9wdHM7XHJcblxyXG4vKipcclxuICogUG9zc3NpYmxlIHBvc2l0aW9ucyBmb3IgbGluayB0byBsYXRjaCB0byBlZGdlXHJcbiAqL1xyXG5lbnVtIExpbmtMYXRjaFBvc2l0aW9uIHtcclxuICAgIFRPUCA9ICd0b3AnLFxyXG4gICAgUklHSFQgPSAncmlnaHQnLFxyXG4gICAgTEVGVCA9ICdsZWZ0JyxcclxuICAgIEJPVFRPTSA9ICdib3R0b20nLFxyXG4gICAgQ0VOVEVSID0gJ2NlbnRlcidcclxufVxyXG5cclxuaW50ZXJmYWNlIEVkZ2VHcm91cCB7XHJcbiAgICBncm91cEtleTogc3RyaW5nLFxyXG4gICAgZ3JvdXBFbDogSFRNTFVMaXN0RWxlbWVudCxcclxuICAgIGxhdGNoUG9zOiBMaW5rTGF0Y2hQb3NpdGlvblxyXG59XHJcblxyXG5pbnRlcmZhY2UgRWRnZSB7XHJcbiAgICB0eXBlOiBGbG93SXRlbVR5cGUuRWRnZSxcclxuICAgIGdyb3VwOiBFZGdlR3JvdXAsXHJcbiAgICBrZXk6IHN0cmluZywgLy9UaGUgY29tcG9zaXRlIGtleVxyXG4gICAgbm9kZUtleTogc3RyaW5nLFxyXG4gICAgZWRnZUtleTogc3RyaW5nLFxyXG4gICAgZWw6IEhUTUxFbGVtZW50LFxyXG4gICAgZGF0YTogU2VyaWFsaXphYmxlLFxyXG4gICAgY2xhc3M6IHN0cmluZ1xyXG59XHJcblxyXG50eXBlIEFkZEVkZ2VPcHRpb25zID0ge1xyXG4gICAgZGF0YT86IFNlcmlhbGl6YWJsZVxyXG4gICAgY2xhc3M/OiBzdHJpbmdcclxufSAmIEFjdGlvbkV4dGVuZGVkT3B0cztcclxuXHJcbmludGVyZmFjZSBMaW5rIHtcclxuICAgIHR5cGU6IEZsb3dJdGVtVHlwZS5MaW5rLFxyXG4gICAga2V5OiBzdHJpbmcsIC8vVGhlIGNvbXBvc2l0ZSBrZXlcclxuICAgIGZyb21Ob2RlOiBzdHJpbmcsXHJcbiAgICBmcm9tRWRnZTogc3RyaW5nLFxyXG4gICAgdG9Ob2RlOiBzdHJpbmcsXHJcbiAgICB0b0VkZ2U6IHN0cmluZ1xyXG4gICAgZWw6IFNWR0dFbGVtZW50LFxyXG4gICAgLy8gaW5uZXJFbDogU1ZHUGF0aEVsZW1lbnQsXHJcbiAgICAvLyBvdXRlckVsOiBTVkdQYXRoRWxlbWVudCxcclxuICAgIGJhbmQxOiBTVkdQYXRoRWxlbWVudCxcclxuICAgIGJhbmQyOiBTVkdQYXRoRWxlbWVudCxcclxuICAgIGJhbmQzOiBTVkdQYXRoRWxlbWVudCxcclxuICAgIGxhYmVsRWw6IFNWR1RleHRQYXRoRWxlbWVudCxcclxuICAgIGRhdGE6IFNlcmlhbGl6YWJsZVxyXG4gICAgLy8gZk9iamVjdDogU1ZHRm9yZWlnbk9iamVjdEVsZW1lbnQsXHJcbiAgICAvLyBjb250ZW50OiBIVE1MRWxlbWVudFxyXG59XHJcblxyXG50eXBlIEFkZExpbmtPcHRpb25zID0ge1xyXG4gICAgY2xhc3M/OiBzdHJpbmcsXHJcbiAgICBkYXRhPzogU2VyaWFsaXphYmxlXHJcbn0gJiBBY3Rpb25FeHRlbmRlZE9wdHM7XHJcblxyXG5pbnRlcmZhY2UgR2hvc3RMaW5rIHtcclxuICAgIGVsOiBTVkdFbGVtZW50LFxyXG4gICAgcGF0aEVsOiBTVkdFbGVtZW50XHJcbn1cclxuXHJcbmludGVyZmFjZSBMaW5rU3RhdGUge1xyXG4gICAgYWN0aXZlOiBib29sZWFuLFxyXG4gICAgZWRnZVJlY3Q6IFJlY3QgfCBudWxsLFxyXG4gICAgZnJvbUVkZ2U6IEVkZ2UgfCBudWxsXHJcbn1cclxuXHJcbmludGVyZmFjZSBDcmVhdGVMaW5rUGFyYW1zIHsgXHJcbiAgICBmcm9tTm9kZTogc3RyaW5nLCBcclxuICAgIHRvTm9kZTogc3RyaW5nLCBcclxuICAgIGZyb21FZGdlOiBzdHJpbmcsIFxyXG4gICAgdG9FZGdlOiBzdHJpbmdcclxufVxyXG5cclxuLyoqXHJcbiAqIEdyYXBoIGVudGl0aWVzXHJcbiAqL1xyXG50eXBlIEZsb3dJdGVtID0gR3JhcGggfCBOb2RlIHwgRWRnZSB8IExpbms7IC8vQWxsIGl0ZW1zXHJcblxyXG4vKipcclxuICogVmFsaWQgaXRlbXMgZm9yIHNlbGVjdGlvblxyXG4gKi9cclxudHlwZSBTZWxlY3RhYmxlSXRlbSA9IE5vZGUgfCBMaW5rOyAvL0l0ZW1zIHdoaWNoIGNhbiBiZSBzZWxlY3RlZFxyXG5cclxuLyoqXHJcbiAqIFZhbGlkIHRhcmdldCBpdGVtcyBmb3IgY29udGV4dCBtZW51XHJcbiAqL1xyXG50eXBlIENvbnRleHRUYXJnZXRJdGVtID0gR3JhcGggfCBOb2RlIHwgRWRnZSB8IExpbms7XHJcblxyXG4vKipcclxuICogSXRlbSB0eXBlcyB3aGljaCBoYXZlIGEgcmVuZGVyYWJsZSBjb250ZW50IHNlY3Rpb25cclxuICovXHJcbnR5cGUgUmVuZGVyYWJsZVR5cGUgPSAnbm9kZScgfCAnZWRnZSc7XHJcbnR5cGUgUmVuZGVyYWJsZUl0ZW0gPSBOb2RlIHwgRWRnZTtcclxuLy8gZW51bSBSZW5kZXJhYmxlVHlwZSB7XHJcbi8vICAgICBOb2RlID0gJ25vZGUnLFxyXG4vLyAgICAgRWRnZSA9ICdlZGdlJyxcclxuLy8gICAgIC8vQ29udGV4dCA9ICdjb250ZXh0J1xyXG4vLyB9XHJcblxyXG5lbnVtIEZsb3dJdGVtVHlwZSB7XHJcbiAgICBOb25lID0gJ25vbmUnLFxyXG4gICAgR3JhcGggPSAnZ3JhcGgnLFxyXG4gICAgTGluayA9ICdsaW5rJyxcclxuICAgIE5vZGUgPSAnbm9kZScsXHJcbiAgICBFZGdlID0gJ2VkZ2UnXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgZGF0YSBhdHRyaWJ1dGUga2V5cyBhcHBsaWVkIHRvIGFsbCBncmFwaCBlbnRpdGllc1xyXG4gKi9cclxuZW51bSBGbG93QXR0ciB7XHJcbiAgICBUeXBlID0gJ2RhdGEtbXhmbG93LXR5cGUnLFxyXG4gICAgS2V5ID0gJ2RhdGEtbXhmbG93LWtleScsXHJcbiAgICBOb2RlVGVtcGxhdGUgPSAnZGF0YS1teGZsb3ctbm9kZS10ZW1wbGF0ZScsXHJcbiAgICBOb2RlQ29udGVudCA9ICdkYXRhLW14Zmxvdy1ub2RlLWNvbnRlbnQnLFxyXG4gICAgRWRnZUdyb3VwID0gJ2RhdGEtbXhmbG93LWVkZ2UtZ3JvdXAnLFxyXG4gICAgRWRnZUxhdGNoID0gJ2RhdGEtbXhmbG93LWVkZ2UtbGF0Y2gnLFxyXG59XHJcblxyXG5lbnVtIEZsb3dDbGFzcyB7XHJcbiAgICBDb250YWluZXIgPSAnbXhmbG93LWNvbnRhaW5lcicsXHJcbiAgICBSb290ID0gJ214Zmxvdy1yb290JyxcclxuICAgIFJvb3RQYW5uaW5nID0gJ214Zmxvdy1yb290LS1wYW5uaW5nJyxcclxuICAgIEJhY2tncm91bmQgPSAnbXhmbG93LWJhY2tncm91bmQnLFxyXG4gICAgRG90cyA9ICdteGZsb3ctZG90cycsXHJcbiAgICBHcmlkID0gJ214Zmxvdy1ncmlkJyxcclxuICAgIEdyaWRJbm5lciA9ICdteGZsb3ctZ3JpZC1pbm5lcicsXHJcbiAgICBHcmlkT3V0ZXIgPSAnbXhmbG93LWdyaWQtb3V0ZXInLFxyXG4gICAgQ29udGV4dCA9ICdteGZsb3ctY29udGV4dCcsXHJcbiAgICBJdGVtU2VsZWN0ZWQgPSAnbXhmbG93LWl0ZW0tLXNlbGVjdGVkJyxcclxuICAgIEl0ZW1QcmVzZWxlY3RlZCA9ICdteGZsb3ctaXRlbS0tcHJlc2VsZWN0ZWQnLFxyXG4gICAgTm9kZXMgPSAnbXhmbG93LW5vZGVzJyxcclxuICAgIE5vZGUgPSAnbXhmbG93LW5vZGUnLFxyXG4gICAgTm9kZUNvbnRlbnQgPSAnbXhmbG93LW5vZGUtY29udGVudCcsXHJcbiAgICBFZGdlR3JvdXAgPSAnbXhmbG93LWVkZ2UtZ3JvdXAnLFxyXG4gICAgRWRnZSA9ICdteGZsb3ctZWRnZScsXHJcbiAgICBFZGdlVmFsaWQgPSAnbXhmbG93LWVkZ2UtLXZhbGlkJyxcclxuICAgIEVkZ2VJbnZhbGlkID0gJ214Zmxvdy1lZGdlLS1pbnZhbGlkJyxcclxuICAgIExhc3NvID0gJ214Zmxvdy1sYXNzbycsXHJcbiAgICBMaW5rcyA9ICdteGxmbG93LWxpbmtzJyxcclxuICAgIExpbmsgPSAnbXhmbG93LWxpbmsnLFxyXG4gICAgLy8gTGlua0lubmVyID0gJ214Zmxvdy1saW5rLWlubmVyJyxcclxuICAgIC8vIExpbmtPdXRlciA9ICdteGZsb3ctbGluay1vdXRlcicsXHJcbiAgICBMaW5rQmFuZDEgPSAnbXhmbG93LWxpbmstYmFuZDEnLFxyXG4gICAgTGlua0JhbmQyID0gJ214Zmxvdy1saW5rLWJhbmQyJyxcclxuICAgIExpbmtCYW5kMyA9ICdteGZsb3ctbGluay1iYW5kMycsXHJcbiAgICBMaW5rVmFsaWQgPSAnbXhmbG93LWxpbmstLXZhbGlkJyxcclxuICAgIExpbmtJbnZhbGlkID0gJ214Zmxvdy1saW5rLS1pbnZhbGlkJyxcclxuICAgIEdob3N0TGlua3MgPSAnbXhmbG93LWdob3N0LWxpbmtzJyxcclxuICAgIEdob3N0TGluayA9ICdteGZsb3ctZ2hvc3QtbGluaycsXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHcmFwaCB0cmFuc2Zvcm0gc3RhdGUsIHBhcnQgb2YgdGhlIGxhcmdlciBzdGF0ZSBvYmplY3RcclxuICovXHJcbmludGVyZmFjZSBUcmFuc2Zvcm0ge1xyXG4gICAgc2NhbGU6IG51bWJlcixcclxuICAgIHg6IG51bWJlcixcclxuICAgIHk6IG51bWJlclxyXG59XHJcblxyXG4vKipcclxuICogUGVyc2lzdGFibGUgYWN0aW9uIHR5cGVzIHVzZWQgZm9yIGRvL3VuZG8uIFRoZXNlIHR5cGVzIGFyZSB1c2VkIHRvIFxyXG4gKiBkZWZpbmUgd2hpY2ggYWN0aW9ucyBzaG91bGQgYmUgcmVjb3JkZWQgaW4gdGhlIG1haW4gb3B0aW9ucy5cclxuICovXHJcbnR5cGUgQWN0aW9uVHlwZSA9IHR5cGVvZiBBY3Rpb25UeXBlc1trZXlvZiB0eXBlb2YgQWN0aW9uVHlwZXNdO1xyXG5jb25zdCBBY3Rpb25UeXBlcyA9IDxjb25zdD4ge1xyXG4gICAgVFJBTlNGT1JNOiAndHJhbnNmb3JtJyxcclxuICAgIFNFTEVDVDogJ3NlbGVjdCcsXHJcbiAgICBEUkFHOiAnZHJhZycsXHJcbiAgICBBRERfRURHRTogJ2FkZEVkZ2UnLFxyXG4gICAgUkVNT1ZFX0VER0U6ICdyZW1vdmVFZGdlJyxcclxuICAgIEFERF9OT0RFOiAnYWRkTm9kZScsXHJcbiAgICBSRU1PVkVfTk9ERTogJ3JlbW92ZU5vZGUnLFxyXG4gICAgQUREX0xJTks6ICdhZGRMaW5rJyxcclxuICAgIFJFTU9WRV9MSU5LOiAncmVtb3ZlTGluaycsXHJcbiAgICBSRU1PVkVfSVRFTVM6ICdyZW1vdmVJdGVtcycsXHJcbiAgICBDTEVBUjogJ2NsZWFyJyxcclxuICAgIENVU1RPTTogJ2N1c3RvbSdcclxufVxyXG5cclxuLyoqXHJcbiAqIEFuIGdyYXBoIGFjdGlvbiBpbnN0YW5jZVxyXG4gKi9cclxuaW50ZXJmYWNlIEFjdGlvbiB7XHJcbiAgICB0eXBlOiBBY3Rpb25UeXBlLFxyXG4gICAgZGVzY3JpcHRpb24/OiBzdHJpbmcsXHJcbiAgICBtb2RlbDogTW9kZWxcclxufVxyXG5cclxuLyoqXHJcbiAqIE9wdGlvbnMgZm9yIHRoZSBgZHJhZ2Agc3lzdGVtXHJcbiAqL1xyXG5pbnRlcmZhY2UgRHJhZ09wdGlvbnMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZWxlY3RvciB0byBjYW5jZWwgZHJhZy4gRGVmaW5lIGEgc2VsZWN0b3IgKGNsYXNzLCBkYXRhIGF0dHJpYnV0ZSwgZXRjLikgYW5kIGFwcGx5XHJcbiAgICAgKiBpdCB0byBhbnkgZWxlbWVudHMgd2l0aGluIGEgbm9kZSB3aGljaCBzaG91bGQgbm90IHRyaWdnZXIgYSBkcmFnIG9wZXJhdGlvbi4gVGhpcyBzZXR0aW5nXHJcbiAgICAgKiBvdmVycmlkZXMgdGhlIGBoYW5kbGVTZWxlY3RvcmAgc2V0dGluZy4gTm8gdmFsdWUgYnkgZGVmYXVsdC5cclxuICAgICAqL1xyXG4gICAgY2FuY2VsU2VsZWN0b3I/OiBzdHJpbmcsXHJcbiAgICAvKipcclxuICAgICAqIFNlbGVjdG9yIGZvciB0aGUgZHJhZyBcImhhbmRsZVwiIGkuZS4gc3BvdCB3aGVyZSBkcmFnZ2luZyBtYXkgb2NjdXIuIE5vIHZhbHVlIGJ5IGRlZmF1bHQuXHJcbiAgICAgKi9cclxuICAgIGhhbmRsZVNlbGVjdG9yPzogc3RyaW5nLFxyXG4gICAgLyoqXHJcbiAgICAgKiBHcmlkIFgsIGFueSB2YWx1ZSB6ZXJvIG9yIGJlbG93IHdpbGwgZGlzYWJsZSB0aGUgZ3JpZCBvbiB0aGUgeCBheGlzLiBEZWZhdWx0IGlzIGAwYC5cclxuICAgICAqL1xyXG4gICAgZ3JpZFg/OiBudW1iZXIsXHJcbiAgICAvKipcclxuICAgICAqIEdyaWQgWSwgYW55IHZhbHVlIHplcm8gb3IgYmVsb3cgd2lsbCBkaXNhYmxlIHRoZSBncmlkIG9uIHRoZSB4IGF4aXMuIERlZmF1bHQgaXMgYDBgLlxyXG4gICAgICovXHJcbiAgICBncmlkWT86IG51bWJlcixcclxuICAgIC8qKlxyXG4gICAgICogTnVtYmVyIG9mIHBpeGVscyBhIGRyYWcgb3BlcmF0aW9uIG11c3QgbW92ZSBiZWZvcmUgY29uc2lkZXJlZCBgbGF0Y2hlZGAuIFRoZSBgZHJhZ2AgYWN0aW9uXHJcbiAgICAgKiBpcyBub3QgcmVjb3JkZWQgYW5kIGBkcmFnYCBldmVudCBub3QgZW1pdHRlZCB1bnRpbCBsYXRjaC4gRGVmYXVsdCBpcyBgNWAuXHJcbiAgICAgKi9cclxuICAgIGxhdGNoVGhyZXNob2xkPzogbnVtYmVyXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBPcHRpb25zIGZvciB0aGUgYHNlbGVjdGBcclxuICovXHJcbmludGVyZmFjZSBTZWxlY3RPcHRpb25zIHtcclxuICAgIC8qKlxyXG4gICAgICogV2hlbiBzZXQgdG8gdHJ1ZSAoZGVmYXVsdCkgbXVsdGlwbGUgaXRlbXMgY2FuIGJlIHNlbGVjdGVkLiBOb3RlIHRoYXRcclxuICAgICAqIHRoaXMgb25seSBhZmZlY3RzIFwic2hpZnQrY2xpY2tcIiB0eXBlIG9wZXJhdGlvbnMuIFRoZXJlIGFyZSBvdGhlciB3YXlzIHRvIHNlbGVjdCBtdWx0aXBsZVxyXG4gICAgICogaXRlbXMgd2hpY2ggYXJlIHVuYWZmZWN0ZWQgKGxhc3NvIHRvb2wsIG1hbnVhbGx5IHNlbGVjdGluZyBpdGVtcyB2aWEgYHNldFNlbGVjdGVkYCkuXHJcbiAgICAgKi9cclxuICAgIG11bHRpU2VsZWN0RW5hYmxlZD86IGJvb2xlYW4sXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEby91bmRvIG9wdGlvbnNcclxuICovXHJcbmludGVyZmFjZSBVbmRvT3B0aW9ucyB7XHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdW5kbyBpcyBlbmFibGVkIGF0IGFsbC5cclxuICAgICAqL1xyXG4gICAgZW5hYmxlZD86IGJvb2xlYW4sXHJcbiAgICAvKipcclxuICAgICAqIE1heCBudW1iZXIgb2YgYWN0aW9ucyB0byByZWNvcmQuIEEgbGFyZ2UgbnVtYmVyIG9mIGFjdGlvbnMgY2FuIGhhdmUgYSBzaWduaWZpY2FudCBtZW1vcnkgZm9vdHByaW50XHJcbiAgICAgKiBmb3IgY29tcGxleCBncmFwaHMuIERlZmF1bHQgaXMgYDUwYC5cclxuICAgICAqL1xyXG4gICAgbWF4PzogbnVtYmVyLFxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBhcnJheSBvZiBhY3Rpb24gdHlwZXMgd2hpY2ggY2FuIGJlIHVuZG9uZS4gQnkgZGVmYXVsdCwgbW9zdCBhY3Rpb25zIGFyZSByZWNvcmRlZC4gSWYgb3ZlcnJpZGluZywgYmVcclxuICAgICAqIHN1cmUgdG8gaW5jbHVkZSBBTEwgYWN0aW9uIHR5cGVzIHlvdSB3aGljaCB0byBiZSB1bmRvYWJsZS5cclxuICAgICAqIFxyXG4gICAgICovXHJcbiAgICBhY3Rpb25zPzogQWN0aW9uVHlwZVtdXHJcbn1cclxuXHJcbmludGVyZmFjZSBMYXNzb09wdGlvbnMge1xyXG4gICAgZW5hYmxlZDogYm9vbGVhbixcclxufVxyXG5cclxuLyoqXHJcbiAqIE9wdGlvbnMgZm9yIHRoZSBgcGFuem9vbWAgc3lzdGVtXHJcbiAqL1xyXG5pbnRlcmZhY2UgUGFuWm9vbU9wdGlvbnMge1xyXG4gICAgZW5hYmxlZD86IGJvb2xlYW4sXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpbml0aWFsIHggcG9zaXRpb24gb2YgdGhlIHZpZXdwb3J0XHJcbiAgICAgKi9cclxuICAgIHg/OiBudW1iZXIsXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpbml0aWFsIHkgcG9zaXRpb24gb2YgdGhlIHZpZXdwb3J0XHJcbiAgICAgKi9cclxuICAgIHk/OiBudW1iZXIsXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpbml0aWFsIHNjYWxlXHJcbiAgICAgKi9cclxuICAgIHNjYWxlPzogbnVtYmVyLFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc21hbGxlc3Qgc2NhbGUgYWxsb3dlZCAoem9vbSBvdXQpXHJcbiAgICAgKi9cclxuICAgIG1pblNjYWxlPzogbnVtYmVyLFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbGFyZ2VzdCBzY2FsZSBhbGxvd2VkICh6b29tIGluKVxyXG4gICAgICovXHJcbiAgICBtYXhTY2FsZT86IG51bWJlcixcclxuICAgIC8qKlxyXG4gICAgICogU3RlcCBhbW91bnQgd2hlbiB6b29taW5nIGluIG9yIG91dFxyXG4gICAgICovXHJcbiAgICBzY2FsZVN0ZXA/OiBudW1iZXJcclxufVxyXG5cclxuaW50ZXJmYWNlIEJhY2tncm91bmRPcHRpb25zIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhY2tncm91bmQgdHlwZVxyXG4gICAgICovXHJcbiAgICB0eXBlPzogJ2dyaWQnIHwgJ2RvdHMnIHwgJ2N1c3RvbScgfCAnbm9uZScsXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBncmlkIHNpemUuIFJlY29tbWVuZGVkIHRvIGFsaWduIHRoaXMgc2l6ZSB3LyBkcmFnIGdyaWQgc2V0dGluZ3MgaWYgYXBwbGljYWJsZS5cclxuICAgICAqIElnbm9yZWQgaWYgdHlwZSBpcyBzZXQgdG8gYGN1c3RvbWAgb3IgYG5vbmVgLlxyXG4gICAgICovXHJcbiAgICBzaXplPzogbnVtYmVyLFxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB0eXBlIGlzIHNldCB0byBgY3VzdG9tYCwgcHJvdmlkZSB5b3VyIGN1c3RvbSBIVE1MLiBJZ25vcmVkIGlmIGJhY2tncm91bmRcclxuICAgICAqIHR5cGUgaXMgbm90IHNldCB0byBgY3VzdG9tYC5cclxuICAgICAqL1xyXG4gICAgaHRtbD86IHN0cmluZyBcclxuICAgIC8qKlxyXG4gICAgICogSWYgdHlwZSBpcyBzZXQgdG8gYGRvdHNgLCB0aGlzIHZhbHVlIGRlZmluZXMgdGhlIHNpemUgb2YgdGhlIGRvdHMuXHJcbiAgICAgKi9cclxuICAgIHJhZGl1cz86IG51bWJlclxyXG59XHJcblxyXG5pbnRlcmZhY2UgQ29udHJvbE9wdGlvbnMge1xyXG4gICAgcGFuQnV0dG9uPzogMCB8IDEgfCAyLFxyXG4gICAgcGFuTW9kaWZpZXI/OiBzdHJpbmcgfCBmYWxzZSxcclxuICAgIHBhbk9uV2hlZWw/OiBib29sZWFuLFxyXG4gICAgcGFuT25BcnJvd0tleXM/OiBib29sZWFuLFxyXG4gICAgem9vbU9uV2hlZWxNb2RpZmllcj86IHN0cmluZyB8IGZhbHNlLFxyXG4gICAgem9vbU9uV2hlZWw/OiBib29sZWFuLFxyXG4gICAgem9vbU9uUGluY2g/OiBib29sZWFuLFxyXG4gICAgem9vbU9uRG91YmxlQ2xpY2s/OiBib29sZWFuLFxyXG4gICAgc2VsZWN0QnV0dG9uPzogMCB8IDEgfCAyLFxyXG4gICAgbXVsdGlTZWxlY3RNb2RpZmllcj86IHN0cmluZyB8IGZhbHNlLFxyXG4gICAgbGFzc29Nb2RpZmllcj86IHN0cmluZyB8IGZhbHNlXHJcbiAgICBsYXNzb0J1dHRvbj86IDAgfCAxIHwgMlxyXG59XHJcblxyXG4vKipcclxuICogTWFpbiBvcHRpb25zXHJcbiAqL1xyXG50eXBlIENvbmZpZyA9IE5vT3B0aW9uYWxzPE9wdGlvbnM+ICYge1xyXG4gICAgZHJhZz86IE5vT3B0aW9uYWxzPERyYWdPcHRpb25zPixcclxuICAgIHNlbGVjdD86IE5vT3B0aW9uYWxzPFNlbGVjdE9wdGlvbnM+LFxyXG4gICAgdW5kbz86IE5vT3B0aW9uYWxzPFVuZG9PcHRpb25zPixcclxuICAgIHBhbnpvb20/OiBOb09wdGlvbmFsczxQYW5ab29tT3B0aW9ucz4sXHJcbiAgICBsYXNzbz86IE5vT3B0aW9uYWxzPExhc3NvT3B0aW9ucz4sXHJcbiAgICBjb250cm9scz86IE5vT3B0aW9uYWxzPENvbnRyb2xPcHRpb25zPlxyXG59XHJcblxyXG5cclxuaW50ZXJmYWNlIE9wdGlvbnMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBJZiBncmFwaCBpcyBuZXN0ZWQsIHRoZSBkaXJlY3QgcGFyZW50IG9mIHRoaXMgZ3JhcGguIFRoaXMgaXMgbmVjZXNzYXJ5IGZvciBuZXN0ZWQgZ3JhcGhzXHJcbiAgICAgKiB0byByZWNvbmNpbGUgc2NhbGUuXHJcbiAgICAgKi9cclxuICAgIHBhcmVudD86IE1YRmxvd0NvbnRyb2xsZXJJbnN0YW5jZSxcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGdyYXBoLlxyXG4gICAgICovXHJcbiAgICB3aWR0aD86IG51bWJlcixcclxuICAgIGhlaWdodD86IG51bWJlcixcclxuXHJcbiAgICBtb2RlbD86IE1vZGVsLFxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRvIHNob3cgdGhlIGJhY2tncm91bmQgZ3JpZCBvciBub3QuIERlZmF1bHQgaXMgYHRydWVgLlxyXG4gICAgICovXHJcbiAgICBzaG93R3JpZD86IGJvb2xlYW4sXHJcbiAgICAvKipcclxuICAgICAqIElmIGJhY2tncm91bmQgZ3JpZCBpcyB2aXNpYmxlLCB0aGUgc2l6ZSBvZiBlYWNoICh0aW5pZXN0KSBzcXVhcmUuIERlZmF1bHQgaXMgYDMyYC5cclxuICAgICAqL1xyXG4gICAgZ3JpZFNpemU/OiBudW1iZXIsXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzdGFydCB6LWluZGV4IGZvciBhbGwgZmxvdyBpdGVtcyBhbmQgZWxlbWVudHMuXHJcbiAgICAgKi9cclxuICAgIHpJbmRleFN0YXJ0PzogbnVtYmVyLCAvL0Jhc2Ugei1pbmRleFxyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBIVE1MIHN0cmluZyB0ZW1wbGF0ZSBkZWZpbmluZyB0aGUgYmFzaWMgbGF5b3V0IGZvciBlYWNoIG5vZGUuIFxyXG4gICAgICogVGhpcyBpcyBmb3IgdGhlIGxheW91dCBvciBcInNoZWxsXCIgb25seS4gTm8gZGVjb3JhdGlvbiBzaG91bGQgYmUgaW5jbHVkZWQgaGVyZS5cclxuICAgICAqL1xyXG4gICAgbm9kZUhUTUxUZW1wbGF0ZT86IHN0cmluZyxcclxuICAgIC8qKlxyXG4gICAgICogQ3VydmUgd2VpZ2h0aW5nIGZvciBlZGdlIGxpbmtlcnMuIERlZmF1bHQgaXQgYDAuNjc1YC5cclxuICAgICAqL1xyXG4gICAgYmV6aWVyV2VpZ2h0PzogbnVtYmVyLFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZ3JhcGggYmFja2dyb3VuZCBvcHRpb25zXHJcbiAgICAgKi9cclxuICAgIGJhY2tncm91bmQ/OiBCYWNrZ3JvdW5kT3B0aW9uc1xyXG4gICAgLyoqXHJcbiAgICAgKiBPcHRpb25zIGZvciB0aGUgJ2RyYWcnIHRvb2wuXHJcbiAgICAgKi9cclxuICAgIGRyYWc/OiBEcmFnT3B0aW9ucyxcclxuICAgIC8qKlxyXG4gICAgICogT3B0aW9ucyBmb3IgXCJzZWxlY3RcIiB0b29sLlxyXG4gICAgICovXHJcbiAgICBzZWxlY3Q/OiBTZWxlY3RPcHRpb25zLFxyXG4gICAgLyoqXHJcbiAgICAgKiBPcHRpb25zIGZvciBkby91bmRvIGNhcGFiaWxpdGVzIFxyXG4gICAgICovXHJcbiAgICB1bmRvPzogVW5kb09wdGlvbnMsXHJcbiAgICAvKipcclxuICAgICAqIE9wdGlvbnMgZm9yIHRoZSBcInBhbnpvb21cIiB0b29sLlxyXG4gICAgICovXHJcbiAgICBwYW56b29tPzogUGFuWm9vbU9wdGlvbnMsXHJcbiAgICAvKipcclxuICAgICAqIE9wdGlvbnMgZm9yIHRoZSBcImxhc3NvXCIgdG9vbC5cclxuICAgICAqL1xyXG4gICAgbGFzc28/OiBMYXNzb09wdGlvbnMsXHJcbiAgICAvKipcclxuICAgICAqIFxyXG4gICAgICovXHJcbiAgICBjb250cm9scz86IENvbnRyb2xPcHRpb25zLFxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcmVuZGVyIG1ldGhvZC4gV2hlbiB1c2luZyBWYW5pbGxhSlMsIHRoaXMgaXMgdGhlIG1ldGhvZCBmcm9tIHdoaWNoIHRoZVxyXG4gICAgICogdXNlciBjYW4gaW5zZXJ0IHRoZWlyIEhUTUwgY29udGVudCBpbnRvIGVhY2ggbm9kZSBhbmQgZWRnZS4gVGhlIHVzZXIgbXVzdCBrZWVwXHJcbiAgICAgKiB0cmFjayBvZiBIVE1MIGNvbnRlbnQgZXh0ZXJuYWxseSBhcyBtYW55IG9wZXJhdGlvbnMgd2lsbCBkZXN0cm95IGFuIGl0ZW1zJ3MgXHJcbiAgICAgKiBjb250ZW50IHNlY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIHJlbmRlcj86IChpdGVtOiBSZW5kZXJhYmxlSXRlbSwgY29udGVudDogRWxlbWVudCB8IG51bGwgfCB1bmRlZmluZWQsIGRhdGE6IHsgW2tleTpzdHJpbmddOiBhbnkgfSkgPT4gRWxlbWVudCB8IHN0cmluZyB8IHZvaWQsXHJcbiAgICAvKipcclxuICAgICAqIFRoZSByZW5kZXIgbWV0aG9kIGZvciB0aGUgY29udGV4dCBtZW51LiBcclxuICAgICAqL1xyXG4gICAgcmVuZGVyQ29udGV4dD86IChpdGVtOiBGbG93SXRlbSwgZ3JhcGhYOiBudW1iZXIsIGdyYXBoWTogbnVtYmVyKSA9PiBFbGVtZW50IHwgc3RyaW5nIHwgdm9pZCxcclxuICAgIC8qKlxyXG4gICAgICogQ3VzdG9tIGxpbmsgdmFsaWRhdG9yLiBUaGlzIHZhbGlkYXRvciB3aWxsIGJlIGNhbGxlZCByZXBlYXRlZGx5IHdoZW4gYSBcImxpbmtpbmdcIlxyXG4gICAgICogb3BlcmF0aW9uIGlzIG9jY3VycmluZyBhbmQgdGhlbiBvbmNlIGJlZm9yZSBhIGZpbmFsIGxpbmsgaXMgZm9ybWVkLiBEb24ndCBwZXJmb3JtIGFueVxyXG4gICAgICogaGVhdnkgcHJvY2Vzc2luZyBpbiB0aGlzIG1ldGhvZC5cclxuICAgICAqL1xyXG4gICAgbGlua1ZhbGlkYXRvcj86IChzdGFydEVkZ2U6IEVkZ2UsIGVuZEVkZ2U6IEVkZ2UpID0+IGJvb2xlYW4sXHJcbiAgICAvKipcclxuICAgICAqIENhbGxiYWNrIHdoZW4gYSBcImRvd25cIiBldmVudCBvY2N1cnMgb24gYW4gZWRnZSBhbmQgYSBcImxpbmtpbmdcIiBvcGVyYXRpb24gYmVnaW5zLiBcclxuICAgICAqIFJldHVybiB0cnVlIHRvIGNvbnRpbnVlIG9yIGZhbHNlIHRvIGNhbmNlbC5cclxuICAgICAqL1xyXG4gICAgYmVmb3JlTGlua1N0YXJ0PzogKHN0YXJ0RWRnZTogRWRnZSkgPT4gYm9vbGVhbixcclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGJhY2sgd2hlbiBhbiBcInVwXCIgZXZlbnQgb2NjdXJzIG9uIGEgdmFsaWQgZWRnZSBhbmQgdGhlIFwibGlua2luZ1wiIG9wZXJhdGlvbiBlbmQuIFxyXG4gICAgICogUmV0dXJuIHRydWUgdG8gY29udGludWUgb3IgZmFsc2UgdG8gY2FuY2VsLlxyXG4gICAgICovXHJcbiAgICBiZWZvcmVMaW5rRW5kPzogKHN0YXJ0RWRnZTogRWRnZSwgZW5kRWRnZTogRWRnZSkgPT4gYm9vbGVhbixcclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIGJlZm9yZSBhIGxpbmsgaXMgcmVtb3ZlZC4gUmV0dXJuIHRydWUgdG8gY29udGludWUgb3IgZmFsc2UgdG8gY2FuY2VsLlxyXG4gICAgICovXHJcbiAgICBiZWZvcmVMaW5rUmVtb3ZlZD86IChsaW5rOiBMaW5rKSA9PiBib29sZWFuLFxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgYmVmb3JlIGEgbm9kZSBpcyByZW1vdmVkLiBSZXR1cm4gdHJ1ZSB0byBjb250aW51ZSBvciBmYWxzZSB0byBjYW5jZWwuXHJcbiAgICAgKi9cclxuICAgIGJlZm9yZU5vZGVSZW1vdmVkPzogKG5vZGU6IE5vZGUpID0+IGJvb2xlYW4sXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCBiZWZvcmUgYW4gZWRnZSBpcyByZW1vdmVkLiBSZXR1cm4gdHJ1ZSB0byBjb250aW51ZSBvciBmYWxzZSB0byBjYW5jZWwuXHJcbiAgICAgKi9cclxuICAgIGJlZm9yZUVkZ2VSZW1vdmVkPzogKGVkZ2U6IEVkZ2UpID0+IGJvb2xlYW4sXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZWZpbmVzIHJldHVybiB2YWx1ZSBmb3IgaW50ZXJuYWwgc3lzdGVtIFwicGx1Z2luXCJcclxuICovXHJcbmludGVyZmFjZSBBY3Rpb25IYW5kbGVyIHtcclxuICAgIG5hbWU6IHN0cmluZyxcclxuICAgIC8vIG9uRG93bj86IChlOiBQb2ludGVyRXZlbnQsIGl0ZW0/OiBGbG93SXRlbSkgPT4gdm9pZCxcclxuICAgIC8vIG9uVXA/OiAoZTogUG9pbnRlckV2ZW50LCBpdGVtPzogRmxvd0l0ZW0pID0+IHZvaWQsXHJcbiAgICAvLyBvbk1vdmU/OiAoZTogUG9pbnRlckV2ZW50KSA9PiB2b2lkLFxyXG4gICAgLy8gb25LZXlVcD86IChlOiBLZXlib2FyZEV2ZW50KSA9PiB2b2lkLFxyXG4gICAgLy8gb25LZXlEb3duPzogKGU6IEtleWJvYXJkRXZlbnQpID0+IHZvaWQsXHJcbiAgICAvLyBvbkNvbnRleHRNZW51PzogKGU6IE1vdXNlRXZlbnQsIGl0ZW0/OiBGbG93SXRlbSkgPT4gdm9pZCxcclxuICAgIHVwZGF0ZT86IChhcGk6IEFwaSkgPT4gdm9pZCxcclxuICAgIGNhbmNlbD86ICgpID0+IHZvaWQsXHJcbiAgICBkaXNwb3NlPzogKCkgPT4gdm9pZFxyXG59XHJcblxyXG4vKipcclxuICogSW50ZXJuYWwgZ3JhcGggQVBJIHBhc3NlZCB0byBzdWJzeXN0ZW1zLCBldGMuXHJcbiAqL1xyXG50eXBlIE1ldGhvZHMgPSBSZXR1cm5UeXBlPHR5cGVvZiBnZXRQdWJsaWNJbnRlcmZhY2U+O1xyXG5pbnRlcmZhY2UgQXBpIHtcclxuICAgIG9wdHM6IENvbmZpZyxcclxuICAgIGRvbTogRmxvd0RvbSxcclxuICAgIHN0YXRlOiBGbG93U3RhdGUsXHJcbiAgICB0b29sczogTWFwPHN0cmluZywgQWN0aW9uSGFuZGxlcj4sXHJcbiAgICByZW5kZXJDYWNoZTogTWFwPHN0cmluZywgRWxlbWVudCB8IG51bGw+LFxyXG4gICAgZW1pdDogPEsgZXh0ZW5kcyBrZXlvZiBGbG93RXZlbnRNYXA+KHR5cGU6IEssIGV2ZW50PzogRmxvd0V2ZW50TWFwW0tdKSA9PiB2b2lkLFxyXG4gICAgbG9jazogKHRvb2xOYW1lOiBzdHJpbmcpID0+IHZvaWQsXHJcbiAgICB1bmxvY2s6ICgpID0+IHZvaWQsXHJcbiAgICBpc0xvY2tlZDogKGV4Y2VwdFRvb2w/OiBzdHJpbmcpID0+IGJvb2xlYW5cclxufVxyXG5cclxuLyoqXHJcbiAqIEV2ZW50cyBlbW1pdHRlZCBhbmQgdGhlaXIgcGFyYW1ldGVyc1xyXG4gKi9cclxuaW50ZXJmYWNlIEZsb3dFdmVudE1hcCB7XHJcbiAgICAndHJhbnNmb3JtJzogVHJhbnNmb3JtLFxyXG4gICAgJ3ByZXNlbGVjdGVkJzogTWFwPHN0cmluZywgU2VsZWN0YWJsZUl0ZW0+LFxyXG4gICAgJ3NlbGVjdGVkJzogTWFwPHN0cmluZywgU2VsZWN0YWJsZUl0ZW0+LFxyXG4gICAgJ25vZGVBZGRlZCc6IE5vZGUsXHJcbiAgICAnbm9kZVJlbW92ZWQnOiBOb2RlLFxyXG4gICAgJ2xpbmtBZGRlZCc6IExpbmssXHJcbiAgICAnbGlua1JlbW92ZWQnOiBMaW5rLFxyXG4gICAgJ2RyYWdTdGFydCc6IE5vZGVbXSxcclxuICAgICdkcmFnRW5kJzogTm9kZVtdLFxyXG4gICAgJ2NvbnRleHRPcGVuZWQnOiBDb250ZXh0VGFyZ2V0SXRlbSxcclxuICAgICdjb250ZXh0Q2xvc2VkJzogQ29udGV4dFRhcmdldEl0ZW0sXHJcbiAgICAnZWRnZUFkZGVkJzogRWRnZSxcclxuICAgICdlZGdlUmVtb3ZlZCc6IEVkZ2UsXHJcbiAgICAnY2xlYXJlZCc6IHZvaWQsXHJcbiAgICAvLyAnbW9kZWxDaGFuZ2UnOiBNb2RlbCxcclxuICAgIC8vJ2JhdGNoOm5vZGVBZGRlZCc6IE1vZGVsLFxyXG59XHJcblxyXG4vKipcclxuICogRXh0ZW5kZWQgcGFyYW1ldGVycyBhdmFpbGFibGUgZm9yIG1vc3QgYWN0aW9ucyAoYGFkZE5vZGVgLCBgZGVsZXRlTm9kZWApIGV0Yy5cclxuICovXHJcbmludGVyZmFjZSBBY3Rpb25FeHRlbmRlZE9wdHMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdXBwcmVzcyBhbnkgZXZlbnRzIG5vcm1hbGx5IHRyaWdnZXJlZCBieSB0aGlzIGFjdGlvblxyXG4gICAgICovXHJcbiAgICBzdXBwcmVzc0V2ZW50PzogYm9vbGVhbixcclxuICAgIC8qKlxyXG4gICAgICogU3VwcHJlc3MgYW55IGFjdGlvbiBwZXJzaXN0ZW5jZSBub3JtYWxseSB0cmlnZ2VyZWQgYnkgdGhpcyBhY3Rpb24uXHJcbiAgICAgKiBVc2VmdWwgd2hlbiBiYXRjaGluZyBhY3Rpb25zIGludG8gYSBzaW5nbGUgb3BlcmF0aW9uLlxyXG4gICAgICovXHJcbiAgICBpZ25vcmVBY3Rpb24/OiBib29sZWFuXHJcbn1cclxuXHJcblxyXG50eXBlIFNldFZpZXdPcHRpb25zID0ge1xyXG4gICAgeD86IG51bWJlcixcclxuICAgIHk/OiBudW1iZXIsXHJcbiAgICBzY2FsZT86IG51bWJlcixcclxuICAgIHNjYWxlU3RlcHM/OiBudW1iZXIsXHJcbiAgICB0cmFuc2l0aW9uPzogYm9vbGVhbiB8IG51bWJlclxyXG59ICYgQWN0aW9uRXh0ZW5kZWRPcHRzO1xyXG5cclxudHlwZSBJbnRlcmFjdGlvbkV2ZW50ID0ge1xyXG4gICAgdHlwZToga2V5b2YgSW50ZXJhY3Rpb25FdmVudE1hcCxcclxuICAgIGl0ZW06IEZsb3dJdGVtIHwgdW5kZWZpbmVkLFxyXG4gICAgZ3JhcGhYOiBudW1iZXIsXHJcbiAgICBncmFwaFk6IG51bWJlcixcclxuICAgIGNvbnRhaW5lclg6IG51bWJlcixcclxuICAgIGNvbnRhaW5lclk6IG51bWJlcixcclxuICAgIHBhZ2VYOiBudW1iZXIsXHJcbiAgICBwYWdlWTogbnVtYmVyLFxyXG4gICAgZXZlbnQ6IEV2ZW50XHJcbn1cclxuXHJcbmludGVyZmFjZSBJbnRlcmFjdGlvbkV2ZW50TWFwIHtcclxuICAgICdjb250ZXh0bWVudSc6IEludGVyYWN0aW9uRXZlbnQsXHJcbiAgICAnZG93bic6IEludGVyYWN0aW9uRXZlbnQsXHJcbiAgICAndXAnOiBJbnRlcmFjdGlvbkV2ZW50LFxyXG4gICAgJ21vdmUnOiBJbnRlcmFjdGlvbkV2ZW50LFxyXG4gICAgJ2tleWRvd24nOiBJbnRlcmFjdGlvbkV2ZW50LFxyXG4gICAgJ2tleXVwJzogSW50ZXJhY3Rpb25FdmVudCxcclxuICAgICd3aGVlbCc6IEludGVyYWN0aW9uRXZlbnRcclxufVxyXG5cclxuZXhwb3J0IHtcclxuICAgIEFjdGlvbixcclxuICAgIEFjdGlvbkV4dGVuZGVkT3B0cyxcclxuICAgIEFjdGlvbkhhbmRsZXIsXHJcbiAgICBBY3Rpb25UeXBlLFxyXG4gICAgQWN0aW9uVHlwZXMsXHJcbiAgICBBZGROb2RlT3B0aW9ucyxcclxuICAgIEFkZEVkZ2VPcHRpb25zLFxyXG4gICAgQWRkTGlua09wdGlvbnMsXHJcbiAgICBNZXRob2RzLFxyXG4gICAgQXBpLFxyXG4gICAgQ29udGVudE1vZGVsSXRlbSxcclxuICAgIENyZWF0ZUxpbmtQYXJhbXMsXHJcbiAgICBFZGdlLFxyXG4gICAgRWRnZUdyb3VwLFxyXG4gICAgRWRnZU1vZGVsLFxyXG4gICAgRmxvd0RvbSxcclxuICAgIEZsb3dFdmVudE1hcCxcclxuICAgIEZsb3dJbnRlcm5hbEFwaSxcclxuICAgIEZsb3dJdGVtLFxyXG4gICAgRmxvd0F0dHIsXHJcbiAgICBGbG93Q2xhc3MsXHJcbiAgICBGbG93SXRlbVR5cGUsXHJcbiAgICBGbG93U3RhdGUsXHJcbiAgICBHaG9zdExpbmssXHJcbiAgICBHcmFwaCxcclxuICAgIExpbmssXHJcbiAgICBMaW5rTW9kZWwsXHJcbiAgICBMaW5rTGF0Y2hQb3NpdGlvbixcclxuICAgIExpbmtTdGF0ZSxcclxuICAgIE1vZGVsLFxyXG4gICAgTm9kZSxcclxuICAgIE5vZGVNb2RlbCxcclxuICAgIE9wdGlvbnMsXHJcbiAgICBDb25maWcsXHJcbiAgICBQYW5ab29tT3B0aW9ucyxcclxuICAgIFJlY3QsXHJcbiAgICBSZW5kZXJhYmxlVHlwZSxcclxuICAgIFNlbGVjdGFibGVJdGVtLFxyXG4gICAgU2VsZWN0T3B0aW9ucyxcclxuICAgIFRyYW5zZm9ybSxcclxuICAgIFRyYW5zZm9ybU1vZGVsLFxyXG4gICAgUmVuZGVyYWJsZUl0ZW0sXHJcbiAgICBJbnRlcmFjdGlvbkV2ZW50LFxyXG4gICAgSW50ZXJhY3Rpb25FdmVudE1hcCxcclxuICAgIFNlcmlhbGl6YWJsZSxcclxuICAgIFNldFZpZXdPcHRpb25zLFxyXG4gICAgTm9PcHRpb25hbHMsXHJcbiAgICBDb250cm9sT3B0aW9ucyxcclxuICAgIERyYWdPcHRpb25zXHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/types/flow.types.v2.ts\n");

/***/ }),

/***/ "./src/util/event-emitter.ts":
/*!***********************************!*\
  !*** ./src/util/event-emitter.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EventEmitter\": () => (/* binding */ EventEmitter)\n/* harmony export */ });\nclass EventEmitter {\n  constructor() {\n    this.events = {};\n  }\n\n  on(event, listener) {\n    if (typeof this.events[event] !== \"object\") {\n      this.events[event] = [];\n    }\n\n    this.events[event].push(listener);\n    return () => this.removeListener(event, listener);\n  }\n\n  removeListener(event, listener) {\n    if (typeof this.events[event] !== \"object\") {\n      return;\n    }\n\n    const idx = this.events[event].indexOf(listener);\n\n    if (idx > -1) {\n      this.events[event].splice(idx, 1);\n    }\n  }\n\n  removeAllListeners() {\n    Object.keys(this.events).forEach(event => this.events[event].splice(0, this.events[event].length));\n  }\n\n  emit(event) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    if (typeof this.events[event] !== \"object\") {\n      return;\n    }\n\n    [...this.events[event]].forEach(listener => listener.apply(this, args));\n  }\n\n  once(event, listener) {\n    var _this = this;\n\n    const remove = this.on(event, function () {\n      remove();\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      listener.apply(_this, args);\n    });\n    return remove;\n  }\n\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbC9ldmVudC1lbWl0dGVyLnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFHQSxNQUFNLFlBQU4sQ0FBa0I7QUFBbEI7QUFDcUIsa0JBQWtCLEVBQWxCO0FBNENwQjs7QUExQ1UsSUFBRSxDQUFDLEtBQUQsRUFBZ0IsUUFBaEIsRUFBa0M7QUFDdkMsUUFBSSxPQUFPLEtBQUssTUFBTCxDQUFZLEtBQVosQ0FBUCxLQUE4QixRQUFsQyxFQUE0QztBQUN4QyxXQUFLLE1BQUwsQ0FBWSxLQUFaLElBQXFCLEVBQXJCO0FBQ0g7O0FBRUQsU0FBSyxNQUFMLENBQVksS0FBWixFQUFtQixJQUFuQixDQUF3QixRQUF4QjtBQUNBLFdBQU8sTUFBTSxLQUFLLGNBQUwsQ0FBb0IsS0FBcEIsRUFBMkIsUUFBM0IsQ0FBYjtBQUNIOztBQUVNLGdCQUFjLENBQUMsS0FBRCxFQUFnQixRQUFoQixFQUFrQztBQUNuRCxRQUFJLE9BQU8sS0FBSyxNQUFMLENBQVksS0FBWixDQUFQLEtBQThCLFFBQWxDLEVBQTRDO0FBQ3hDO0FBQ0g7O0FBRUQsVUFBTSxHQUFHLEdBQVcsS0FBSyxNQUFMLENBQVksS0FBWixFQUFtQixPQUFuQixDQUEyQixRQUEzQixDQUFwQjs7QUFDQSxRQUFJLEdBQUcsR0FBRyxDQUFDLENBQVgsRUFBYztBQUNWLFdBQUssTUFBTCxDQUFZLEtBQVosRUFBbUIsTUFBbkIsQ0FBMEIsR0FBMUIsRUFBK0IsQ0FBL0I7QUFDSDtBQUNKOztBQUVNLG9CQUFrQjtBQUNyQixVQUFNLENBQUMsSUFBUCxDQUFZLEtBQUssTUFBakIsRUFBeUIsT0FBekIsQ0FBa0MsS0FBRCxJQUM3QixLQUFLLE1BQUwsQ0FBWSxLQUFaLEVBQW1CLE1BQW5CLENBQTBCLENBQTFCLEVBQTZCLEtBQUssTUFBTCxDQUFZLEtBQVosRUFBbUIsTUFBaEQsQ0FESjtBQUdIOztBQUVNLE1BQUksQ0FBQyxLQUFELEVBQThCO0FBQUEsc0NBQVgsSUFBVztBQUFYLFVBQVc7QUFBQTs7QUFDckMsUUFBSSxPQUFPLEtBQUssTUFBTCxDQUFZLEtBQVosQ0FBUCxLQUE4QixRQUFsQyxFQUE0QztBQUN4QztBQUNIOztBQUVELEtBQUMsR0FBRyxLQUFLLE1BQUwsQ0FBWSxLQUFaLENBQUosRUFBd0IsT0FBeEIsQ0FBaUMsUUFBRCxJQUFjLFFBQVEsQ0FBQyxLQUFULENBQWUsSUFBZixFQUFxQixJQUFyQixDQUE5QztBQUNIOztBQUVNLE1BQUksQ0FBQyxLQUFELEVBQWdCLFFBQWhCLEVBQWtDO0FBQUE7O0FBQ3pDLFVBQU0sTUFBTSxHQUFpQixLQUFLLEVBQUwsQ0FBUSxLQUFSLEVBQWUsWUFBbUI7QUFDM0QsWUFBTTs7QUFEcUQseUNBQWYsSUFBZTtBQUFmLFlBQWU7QUFBQTs7QUFFM0QsY0FBUSxDQUFDLEtBQVQsQ0FBZSxLQUFmLEVBQXFCLElBQXJCO0FBQ0gsS0FINEIsQ0FBN0I7QUFLQSxXQUFPLE1BQVA7QUFDSDs7QUE1Q2EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teGZsb3cvLi9zcmMvdXRpbC9ldmVudC1lbWl0dGVyLnRzP2EzM2IiXSwic291cmNlc0NvbnRlbnQiOlsidHlwZSBMaXN0ZW5lciA9ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZDtcclxuaW50ZXJmYWNlIElFdmVudHMgeyBbZXZlbnQ6IHN0cmluZ106IExpc3RlbmVyW107IH1cclxuXHJcbmNsYXNzIEV2ZW50RW1pdHRlciB7XHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IGV2ZW50czogSUV2ZW50cyA9IHt9O1xyXG5cclxuICAgIHB1YmxpYyBvbihldmVudDogc3RyaW5nLCBsaXN0ZW5lcjogTGlzdGVuZXIpOiAoKSA9PiB2b2lkIHtcclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZXZlbnRzW2V2ZW50XSAhPT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50c1tldmVudF0gPSBbXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuZXZlbnRzW2V2ZW50XS5wdXNoKGxpc3RlbmVyKTtcclxuICAgICAgICByZXR1cm4gKCkgPT4gdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZW1vdmVMaXN0ZW5lcihldmVudDogc3RyaW5nLCBsaXN0ZW5lcjogTGlzdGVuZXIpOiB2b2lkIHtcclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZXZlbnRzW2V2ZW50XSAhPT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBpZHg6IG51bWJlciA9IHRoaXMuZXZlbnRzW2V2ZW50XS5pbmRleE9mKGxpc3RlbmVyKTtcclxuICAgICAgICBpZiAoaWR4ID4gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudHNbZXZlbnRdLnNwbGljZShpZHgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVtb3ZlQWxsTGlzdGVuZXJzKCk6IHZvaWQge1xyXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuZXZlbnRzKS5mb3JFYWNoKChldmVudDogc3RyaW5nKSA9PlxyXG4gICAgICAgICAgICB0aGlzLmV2ZW50c1tldmVudF0uc3BsaWNlKDAsIHRoaXMuZXZlbnRzW2V2ZW50XS5sZW5ndGgpLFxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGVtaXQoZXZlbnQ6IHN0cmluZywgLi4uYXJnczogYW55W10pOiB2b2lkIHtcclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZXZlbnRzW2V2ZW50XSAhPT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBbLi4udGhpcy5ldmVudHNbZXZlbnRdXS5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIuYXBwbHkodGhpcywgYXJncykpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbmNlKGV2ZW50OiBzdHJpbmcsIGxpc3RlbmVyOiBMaXN0ZW5lcik6ICgpID0+IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IHJlbW92ZTogKCgpID0+IHZvaWQpID0gdGhpcy5vbihldmVudCwgKC4uLmFyZ3M6IGFueVtdKSA9PiB7XHJcbiAgICAgICAgICAgIHJlbW92ZSgpO1xyXG4gICAgICAgICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJlbW92ZTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IHsgRXZlbnRFbWl0dGVyLCBMaXN0ZW5lciB9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/util/event-emitter.ts\n");

/***/ }),

/***/ "./src/styles/default.css":
/*!********************************!*\
  !*** ./src/styles/default.css ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"themes/default.css\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3R5bGVzL2RlZmF1bHQuY3NzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxxQkFBdUIsdUJBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXhmbG93Ly4vc3JjL3N0eWxlcy9kZWZhdWx0LmNzcz9lMzQ4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJ0aGVtZXMvZGVmYXVsdC5jc3NcIjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/styles/default.css\n");

/***/ }),

/***/ "./node_modules/hotkeys-js/dist/hotkeys.esm.js":
/*!*****************************************************!*\
  !*** ./node_modules/hotkeys-js/dist/hotkeys.esm.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*!\n * hotkeys-js v3.8.7\n * A simple micro-library for defining and dispatching keyboard shortcuts. It has no dependencies.\n * \n * Copyright (c) 2021 kenny wong <wowohoo@qq.com>\n * http://jaywcjlove.github.io/hotkeys\n * \n * Licensed under the MIT license.\n */\n\nvar isff = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase().indexOf('firefox') > 0 : false; // 绑定事件\n\nfunction addEvent(object, event, method) {\n  if (object.addEventListener) {\n    object.addEventListener(event, method, false);\n  } else if (object.attachEvent) {\n    object.attachEvent(\"on\".concat(event), function () {\n      method(window.event);\n    });\n  }\n} // 修饰键转换成对应的键码\n\n\nfunction getMods(modifier, key) {\n  var mods = key.slice(0, key.length - 1);\n\n  for (var i = 0; i < mods.length; i++) {\n    mods[i] = modifier[mods[i].toLowerCase()];\n  }\n\n  return mods;\n} // 处理传的key字符串转换成数组\n\n\nfunction getKeys(key) {\n  if (typeof key !== 'string') key = '';\n  key = key.replace(/\\s/g, ''); // 匹配任何空白字符,包括空格、制表符、换页符等等\n\n  var keys = key.split(','); // 同时设置多个快捷键，以','分割\n\n  var index = keys.lastIndexOf(''); // 快捷键可能包含','，需特殊处理\n\n  for (; index >= 0;) {\n    keys[index - 1] += ',';\n    keys.splice(index, 1);\n    index = keys.lastIndexOf('');\n  }\n\n  return keys;\n} // 比较修饰键的数组\n\n\nfunction compareArray(a1, a2) {\n  var arr1 = a1.length >= a2.length ? a1 : a2;\n  var arr2 = a1.length >= a2.length ? a2 : a1;\n  var isIndex = true;\n\n  for (var i = 0; i < arr1.length; i++) {\n    if (arr2.indexOf(arr1[i]) === -1) isIndex = false;\n  }\n\n  return isIndex;\n}\n\nvar _keyMap = {\n  backspace: 8,\n  tab: 9,\n  clear: 12,\n  enter: 13,\n  return: 13,\n  esc: 27,\n  escape: 27,\n  space: 32,\n  left: 37,\n  up: 38,\n  right: 39,\n  down: 40,\n  del: 46,\n  delete: 46,\n  ins: 45,\n  insert: 45,\n  home: 36,\n  end: 35,\n  pageup: 33,\n  pagedown: 34,\n  capslock: 20,\n  num_0: 96,\n  num_1: 97,\n  num_2: 98,\n  num_3: 99,\n  num_4: 100,\n  num_5: 101,\n  num_6: 102,\n  num_7: 103,\n  num_8: 104,\n  num_9: 105,\n  num_multiply: 106,\n  num_add: 107,\n  num_enter: 108,\n  num_subtract: 109,\n  num_decimal: 110,\n  num_divide: 111,\n  '⇪': 20,\n  ',': 188,\n  '.': 190,\n  '/': 191,\n  '`': 192,\n  '-': isff ? 173 : 189,\n  '=': isff ? 61 : 187,\n  ';': isff ? 59 : 186,\n  '\\'': 222,\n  '[': 219,\n  ']': 221,\n  '\\\\': 220\n}; // Modifier Keys\n\nvar _modifier = {\n  // shiftKey\n  '⇧': 16,\n  shift: 16,\n  // altKey\n  '⌥': 18,\n  alt: 18,\n  option: 18,\n  // ctrlKey\n  '⌃': 17,\n  ctrl: 17,\n  control: 17,\n  // metaKey\n  '⌘': 91,\n  cmd: 91,\n  command: 91\n};\nvar modifierMap = {\n  16: 'shiftKey',\n  18: 'altKey',\n  17: 'ctrlKey',\n  91: 'metaKey',\n  shiftKey: 16,\n  ctrlKey: 17,\n  altKey: 18,\n  metaKey: 91\n};\nvar _mods = {\n  16: false,\n  18: false,\n  17: false,\n  91: false\n};\nvar _handlers = {}; // F1~F12 special key\n\nfor (var k = 1; k < 20; k++) {\n  _keyMap[\"f\".concat(k)] = 111 + k;\n}\n\nvar _downKeys = []; // 记录摁下的绑定键\n\nvar _scope = 'all'; // 默认热键范围\n\nvar elementHasBindEvent = []; // 已绑定事件的节点记录\n// 返回键码\n\nvar code = function code(x) {\n  return _keyMap[x.toLowerCase()] || _modifier[x.toLowerCase()] || x.toUpperCase().charCodeAt(0);\n}; // 设置获取当前范围（默认为'所有'）\n\n\nfunction setScope(scope) {\n  _scope = scope || 'all';\n} // 获取当前范围\n\n\nfunction getScope() {\n  return _scope || 'all';\n} // 获取摁下绑定键的键值\n\n\nfunction getPressedKeyCodes() {\n  return _downKeys.slice(0);\n} // 表单控件控件判断 返回 Boolean\n// hotkey is effective only when filter return true\n\n\nfunction filter(event) {\n  var target = event.target || event.srcElement;\n  var tagName = target.tagName;\n  var flag = true; // ignore: isContentEditable === 'true', <input> and <textarea> when readOnly state is false, <select>\n\n  if (target.isContentEditable || (tagName === 'INPUT' || tagName === 'TEXTAREA' || tagName === 'SELECT') && !target.readOnly) {\n    flag = false;\n  }\n\n  return flag;\n} // 判断摁下的键是否为某个键，返回true或者false\n\n\nfunction isPressed(keyCode) {\n  if (typeof keyCode === 'string') {\n    keyCode = code(keyCode); // 转换成键码\n  }\n\n  return _downKeys.indexOf(keyCode) !== -1;\n} // 循环删除handlers中的所有 scope(范围)\n\n\nfunction deleteScope(scope, newScope) {\n  var handlers;\n  var i; // 没有指定scope，获取scope\n\n  if (!scope) scope = getScope();\n\n  for (var key in _handlers) {\n    if (Object.prototype.hasOwnProperty.call(_handlers, key)) {\n      handlers = _handlers[key];\n\n      for (i = 0; i < handlers.length;) {\n        if (handlers[i].scope === scope) handlers.splice(i, 1);else i++;\n      }\n    }\n  } // 如果scope被删除，将scope重置为all\n\n\n  if (getScope() === scope) setScope(newScope || 'all');\n} // 清除修饰键\n\n\nfunction clearModifier(event) {\n  var key = event.keyCode || event.which || event.charCode;\n\n  var i = _downKeys.indexOf(key); // 从列表中清除按压过的键\n\n\n  if (i >= 0) {\n    _downKeys.splice(i, 1);\n  } // 特殊处理 cmmand 键，在 cmmand 组合快捷键 keyup 只执行一次的问题\n\n\n  if (event.key && event.key.toLowerCase() === 'meta') {\n    _downKeys.splice(0, _downKeys.length);\n  } // 修饰键 shiftKey altKey ctrlKey (command||metaKey) 清除\n\n\n  if (key === 93 || key === 224) key = 91;\n\n  if (key in _mods) {\n    _mods[key] = false; // 将修饰键重置为false\n\n    for (var k in _modifier) {\n      if (_modifier[k] === key) hotkeys[k] = false;\n    }\n  }\n}\n\nfunction unbind(keysInfo) {\n  // unbind(), unbind all keys\n  if (!keysInfo) {\n    Object.keys(_handlers).forEach(function (key) {\n      return delete _handlers[key];\n    });\n  } else if (Array.isArray(keysInfo)) {\n    // support like : unbind([{key: 'ctrl+a', scope: 's1'}, {key: 'ctrl-a', scope: 's2', splitKey: '-'}])\n    keysInfo.forEach(function (info) {\n      if (info.key) eachUnbind(info);\n    });\n  } else if (typeof keysInfo === 'object') {\n    // support like unbind({key: 'ctrl+a, ctrl+b', scope:'abc'})\n    if (keysInfo.key) eachUnbind(keysInfo);\n  } else if (typeof keysInfo === 'string') {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    // support old method\n    // eslint-disable-line\n    var scope = args[0],\n        method = args[1];\n\n    if (typeof scope === 'function') {\n      method = scope;\n      scope = '';\n    }\n\n    eachUnbind({\n      key: keysInfo,\n      scope: scope,\n      method: method,\n      splitKey: '+'\n    });\n  }\n} // 解除绑定某个范围的快捷键\n\n\nvar eachUnbind = function eachUnbind(_ref) {\n  var key = _ref.key,\n      scope = _ref.scope,\n      method = _ref.method,\n      _ref$splitKey = _ref.splitKey,\n      splitKey = _ref$splitKey === void 0 ? '+' : _ref$splitKey;\n  var multipleKeys = getKeys(key);\n  multipleKeys.forEach(function (originKey) {\n    var unbindKeys = originKey.split(splitKey);\n    var len = unbindKeys.length;\n    var lastKey = unbindKeys[len - 1];\n    var keyCode = lastKey === '*' ? '*' : code(lastKey);\n    if (!_handlers[keyCode]) return; // 判断是否传入范围，没有就获取范围\n\n    if (!scope) scope = getScope();\n    var mods = len > 1 ? getMods(_modifier, unbindKeys) : [];\n    _handlers[keyCode] = _handlers[keyCode].map(function (record) {\n      // 通过函数判断，是否解除绑定，函数相等直接返回\n      var isMatchingMethod = method ? record.method === method : true;\n\n      if (isMatchingMethod && record.scope === scope && compareArray(record.mods, mods)) {\n        return {};\n      }\n\n      return record;\n    });\n  });\n}; // 对监听对应快捷键的回调函数进行处理\n\n\nfunction eventHandler(event, handler, scope) {\n  var modifiersMatch; // 看它是否在当前范围\n\n  if (handler.scope === scope || handler.scope === 'all') {\n    // 检查是否匹配修饰符（如果有返回true）\n    modifiersMatch = handler.mods.length > 0;\n\n    for (var y in _mods) {\n      if (Object.prototype.hasOwnProperty.call(_mods, y)) {\n        if (!_mods[y] && handler.mods.indexOf(+y) > -1 || _mods[y] && handler.mods.indexOf(+y) === -1) {\n          modifiersMatch = false;\n        }\n      }\n    } // 调用处理程序，如果是修饰键不做处理\n\n\n    if (handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91] || modifiersMatch || handler.shortcut === '*') {\n      if (handler.method(event, handler) === false) {\n        if (event.preventDefault) event.preventDefault();else event.returnValue = false;\n        if (event.stopPropagation) event.stopPropagation();\n        if (event.cancelBubble) event.cancelBubble = true;\n      }\n    }\n  }\n} // 处理keydown事件\n\n\nfunction dispatch(event) {\n  var asterisk = _handlers['*'];\n  var key = event.keyCode || event.which || event.charCode; // 表单控件过滤 默认表单控件不触发快捷键\n\n  if (!hotkeys.filter.call(this, event)) return; // Gecko(Firefox)的command键值224，在Webkit(Chrome)中保持一致\n  // Webkit左右 command 键值不一样\n\n  if (key === 93 || key === 224) key = 91;\n  /**\n   * Collect bound keys\n   * If an Input Method Editor is processing key input and the event is keydown, return 229.\n   * https://stackoverflow.com/questions/25043934/is-it-ok-to-ignore-keydown-events-with-keycode-229\n   * http://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html\n   */\n\n  if (_downKeys.indexOf(key) === -1 && key !== 229) _downKeys.push(key);\n  /**\n   * Jest test cases are required.\n   * ===============================\n   */\n\n  ['ctrlKey', 'altKey', 'shiftKey', 'metaKey'].forEach(function (keyName) {\n    var keyNum = modifierMap[keyName];\n\n    if (event[keyName] && _downKeys.indexOf(keyNum) === -1) {\n      _downKeys.push(keyNum);\n    } else if (!event[keyName] && _downKeys.indexOf(keyNum) > -1) {\n      _downKeys.splice(_downKeys.indexOf(keyNum), 1);\n    } else if (keyName === 'metaKey' && event[keyName] && _downKeys.length === 3) {\n      /**\n       * Fix if Command is pressed:\n       * ===============================\n       */\n      if (!(event.ctrlKey || event.shiftKey || event.altKey)) {\n        _downKeys = _downKeys.slice(_downKeys.indexOf(keyNum));\n      }\n    }\n  });\n  /**\n   * -------------------------------\n   */\n\n  if (key in _mods) {\n    _mods[key] = true; // 将特殊字符的key注册到 hotkeys 上\n\n    for (var k in _modifier) {\n      if (_modifier[k] === key) hotkeys[k] = true;\n    }\n\n    if (!asterisk) return;\n  } // 将 modifierMap 里面的修饰键绑定到 event 中\n\n\n  for (var e in _mods) {\n    if (Object.prototype.hasOwnProperty.call(_mods, e)) {\n      _mods[e] = event[modifierMap[e]];\n    }\n  }\n  /**\n   * https://github.com/jaywcjlove/hotkeys/pull/129\n   * This solves the issue in Firefox on Windows where hotkeys corresponding to special characters would not trigger.\n   * An example of this is ctrl+alt+m on a Swedish keyboard which is used to type μ.\n   * Browser support: https://caniuse.com/#feat=keyboardevent-getmodifierstate\n   */\n\n\n  if (event.getModifierState && !(event.altKey && !event.ctrlKey) && event.getModifierState('AltGraph')) {\n    if (_downKeys.indexOf(17) === -1) {\n      _downKeys.push(17);\n    }\n\n    if (_downKeys.indexOf(18) === -1) {\n      _downKeys.push(18);\n    }\n\n    _mods[17] = true;\n    _mods[18] = true;\n  } // 获取范围 默认为 `all`\n\n\n  var scope = getScope(); // 对任何快捷键都需要做的处理\n\n  if (asterisk) {\n    for (var i = 0; i < asterisk.length; i++) {\n      if (asterisk[i].scope === scope && (event.type === 'keydown' && asterisk[i].keydown || event.type === 'keyup' && asterisk[i].keyup)) {\n        eventHandler(event, asterisk[i], scope);\n      }\n    }\n  } // key 不在 _handlers 中返回\n\n\n  if (!(key in _handlers)) return;\n\n  for (var _i = 0; _i < _handlers[key].length; _i++) {\n    if (event.type === 'keydown' && _handlers[key][_i].keydown || event.type === 'keyup' && _handlers[key][_i].keyup) {\n      if (_handlers[key][_i].key) {\n        var record = _handlers[key][_i];\n        var splitKey = record.splitKey;\n        var keyShortcut = record.key.split(splitKey);\n        var _downKeysCurrent = []; // 记录当前按键键值\n\n        for (var a = 0; a < keyShortcut.length; a++) {\n          _downKeysCurrent.push(code(keyShortcut[a]));\n        }\n\n        if (_downKeysCurrent.sort().join('') === _downKeys.sort().join('')) {\n          // 找到处理内容\n          eventHandler(event, record, scope);\n        }\n      }\n    }\n  }\n} // 判断 element 是否已经绑定事件\n\n\nfunction isElementBind(element) {\n  return elementHasBindEvent.indexOf(element) > -1;\n}\n\nfunction hotkeys(key, option, method) {\n  _downKeys = [];\n  var keys = getKeys(key); // 需要处理的快捷键列表\n\n  var mods = [];\n  var scope = 'all'; // scope默认为all，所有范围都有效\n\n  var element = document; // 快捷键事件绑定节点\n\n  var i = 0;\n  var keyup = false;\n  var keydown = true;\n  var splitKey = '+'; // 对为设定范围的判断\n\n  if (method === undefined && typeof option === 'function') {\n    method = option;\n  }\n\n  if (Object.prototype.toString.call(option) === '[object Object]') {\n    if (option.scope) scope = option.scope; // eslint-disable-line\n\n    if (option.element) element = option.element; // eslint-disable-line\n\n    if (option.keyup) keyup = option.keyup; // eslint-disable-line\n\n    if (option.keydown !== undefined) keydown = option.keydown; // eslint-disable-line\n\n    if (typeof option.splitKey === 'string') splitKey = option.splitKey; // eslint-disable-line\n  }\n\n  if (typeof option === 'string') scope = option; // 对于每个快捷键进行处理\n\n  for (; i < keys.length; i++) {\n    key = keys[i].split(splitKey); // 按键列表\n\n    mods = []; // 如果是组合快捷键取得组合快捷键\n\n    if (key.length > 1) mods = getMods(_modifier, key); // 将非修饰键转化为键码\n\n    key = key[key.length - 1];\n    key = key === '*' ? '*' : code(key); // *表示匹配所有快捷键\n    // 判断key是否在_handlers中，不在就赋一个空数组\n\n    if (!(key in _handlers)) _handlers[key] = [];\n\n    _handlers[key].push({\n      keyup: keyup,\n      keydown: keydown,\n      scope: scope,\n      mods: mods,\n      shortcut: keys[i],\n      method: method,\n      key: keys[i],\n      splitKey: splitKey\n    });\n  } // 在全局document上设置快捷键\n\n\n  if (typeof element !== 'undefined' && !isElementBind(element) && window) {\n    elementHasBindEvent.push(element);\n    addEvent(element, 'keydown', function (e) {\n      dispatch(e);\n    });\n    addEvent(window, 'focus', function () {\n      _downKeys = [];\n    });\n    addEvent(element, 'keyup', function (e) {\n      dispatch(e);\n      clearModifier(e);\n    });\n  }\n}\n\nvar _api = {\n  setScope: setScope,\n  getScope: getScope,\n  deleteScope: deleteScope,\n  getPressedKeyCodes: getPressedKeyCodes,\n  isPressed: isPressed,\n  filter: filter,\n  unbind: unbind\n};\n\nfor (var a in _api) {\n  if (Object.prototype.hasOwnProperty.call(_api, a)) {\n    hotkeys[a] = _api[a];\n  }\n}\n\nif (typeof window !== 'undefined') {\n  var _hotkeys = window.hotkeys;\n\n  hotkeys.noConflict = function (deep) {\n    if (deep && window.hotkeys === hotkeys) {\n      window.hotkeys = _hotkeys;\n    }\n\n    return hotkeys;\n  };\n\n  window.hotkeys = hotkeys;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hotkeys);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaG90a2V5cy1qcy9kaXN0L2hvdGtleXMuZXNtLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0hBQWdIOztBQUVoSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEMsNkJBQTZCOztBQUU3QixvQ0FBb0M7O0FBRXBDLFNBQVMsV0FBVztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQixnQkFBZ0IsUUFBUTtB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QUVsRCw0Q0FBNEM7O0FBRTVDLGdFQUFnRTs7QUFFaEUseUVBQXlFO0FBQ3pFOztBQUVBLGtEQUFrRDs7QUFFbEQsU0FBUyxpQkFBaUI7QUFDMUIsbUNBQW1DOztBQUVuQyxlQUFlOztBQUVmLHdEQUF3RDs7QUFFeEQ7QUFDQSx5Q0FBeUM7QUFDekM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUVBQWUsT0FBTyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXhmbG93Ly4vbm9kZV9tb2R1bGVzL2hvdGtleXMtanMvZGlzdC9ob3RrZXlzLmVzbS5qcz85YjZhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogaG90a2V5cy1qcyB2My44LjdcbiAqIEEgc2ltcGxlIG1pY3JvLWxpYnJhcnkgZm9yIGRlZmluaW5nIGFuZCBkaXNwYXRjaGluZyBrZXlib2FyZCBzaG9ydGN1dHMuIEl0IGhhcyBubyBkZXBlbmRlbmNpZXMuXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAyMSBrZW5ueSB3b25nIDx3b3dvaG9vQHFxLmNvbT5cbiAqIGh0dHA6Ly9qYXl3Y2psb3ZlLmdpdGh1Yi5pby9ob3RrZXlzXG4gKiBcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuXG52YXIgaXNmZiA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnID8gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2ZpcmVmb3gnKSA+IDAgOiBmYWxzZTsgLy8g57uR5a6a5LqL5Lu2XG5cbmZ1bmN0aW9uIGFkZEV2ZW50KG9iamVjdCwgZXZlbnQsIG1ldGhvZCkge1xuICBpZiAob2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICBvYmplY3QuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbWV0aG9kLCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAob2JqZWN0LmF0dGFjaEV2ZW50KSB7XG4gICAgb2JqZWN0LmF0dGFjaEV2ZW50KFwib25cIi5jb25jYXQoZXZlbnQpLCBmdW5jdGlvbiAoKSB7XG4gICAgICBtZXRob2Qod2luZG93LmV2ZW50KTtcbiAgICB9KTtcbiAgfVxufSAvLyDkv67ppbDplK7ovazmjaLmiJDlr7nlupTnmoTplK7noIFcblxuXG5mdW5jdGlvbiBnZXRNb2RzKG1vZGlmaWVyLCBrZXkpIHtcbiAgdmFyIG1vZHMgPSBrZXkuc2xpY2UoMCwga2V5Lmxlbmd0aCAtIDEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbW9kcy5sZW5ndGg7IGkrKykge1xuICAgIG1vZHNbaV0gPSBtb2RpZmllclttb2RzW2ldLnRvTG93ZXJDYXNlKCldO1xuICB9XG5cbiAgcmV0dXJuIG1vZHM7XG59IC8vIOWkhOeQhuS8oOeahGtleeWtl+espuS4sui9rOaNouaIkOaVsOe7hFxuXG5cbmZ1bmN0aW9uIGdldEtleXMoa2V5KSB7XG4gIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykga2V5ID0gJyc7XG4gIGtleSA9IGtleS5yZXBsYWNlKC9cXHMvZywgJycpOyAvLyDljLnphY3ku7vkvZXnqbrnmb3lrZfnrKYs5YyF5ous56m65qC844CB5Yi26KGo56ym44CB5o2i6aG156ym562J562JXG5cbiAgdmFyIGtleXMgPSBrZXkuc3BsaXQoJywnKTsgLy8g5ZCM5pe26K6+572u5aSa5Liq5b+r5o236ZSu77yM5LulJywn5YiG5YmyXG5cbiAgdmFyIGluZGV4ID0ga2V5cy5sYXN0SW5kZXhPZignJyk7IC8vIOW/q+aNt+mUruWPr+iDveWMheWQqycsJ++8jOmcgOeJueauiuWkhOeQhlxuXG4gIGZvciAoOyBpbmRleCA+PSAwOykge1xuICAgIGtleXNbaW5kZXggLSAxXSArPSAnLCc7XG4gICAga2V5cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIGluZGV4ID0ga2V5cy5sYXN0SW5kZXhPZignJyk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn0gLy8g5q+U6L6D5L+u6aWw6ZSu55qE5pWw57uEXG5cblxuZnVuY3Rpb24gY29tcGFyZUFycmF5KGExLCBhMikge1xuICB2YXIgYXJyMSA9IGExLmxlbmd0aCA+PSBhMi5sZW5ndGggPyBhMSA6IGEyO1xuICB2YXIgYXJyMiA9IGExLmxlbmd0aCA+PSBhMi5sZW5ndGggPyBhMiA6IGExO1xuICB2YXIgaXNJbmRleCA9IHRydWU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIxLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycjIuaW5kZXhPZihhcnIxW2ldKSA9PT0gLTEpIGlzSW5kZXggPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc0luZGV4O1xufVxuXG52YXIgX2tleU1hcCA9IHtcbiAgYmFja3NwYWNlOiA4LFxuICB0YWI6IDksXG4gIGNsZWFyOiAxMixcbiAgZW50ZXI6IDEzLFxuICByZXR1cm46IDEzLFxuICBlc2M6IDI3LFxuICBlc2NhcGU6IDI3LFxuICBzcGFjZTogMzIsXG4gIGxlZnQ6IDM3LFxuICB1cDogMzgsXG4gIHJpZ2h0OiAzOSxcbiAgZG93bjogNDAsXG4gIGRlbDogNDYsXG4gIGRlbGV0ZTogNDYsXG4gIGluczogNDUsXG4gIGluc2VydDogNDUsXG4gIGhvbWU6IDM2LFxuICBlbmQ6IDM1LFxuICBwYWdldXA6IDMzLFxuICBwYWdlZG93bjogMzQsXG4gIGNhcHNsb2NrOiAyMCxcbiAgbnVtXzA6IDk2LFxuICBudW1fMTogOTcsXG4gIG51bV8yOiA5OCxcbiAgbnVtXzM6IDk5LFxuICBudW1fNDogMTAwLFxuICBudW1fNTogMTAxLFxuICBudW1fNjogMTAyLFxuICBudW1fNzogMTAzLFxuICBudW1fODogMTA0LFxuICBudW1fOTogMTA1LFxuICBudW1fbXVsdGlwbHk6IDEwNixcbiAgbnVtX2FkZDogMTA3LFxuICBudW1fZW50ZXI6IDEwOCxcbiAgbnVtX3N1YnRyYWN0OiAxMDksXG4gIG51bV9kZWNpbWFsOiAxMTAsXG4gIG51bV9kaXZpZGU6IDExMSxcbiAgJ+KHqic6IDIwLFxuICAnLCc6IDE4OCxcbiAgJy4nOiAxOTAsXG4gICcvJzogMTkxLFxuICAnYCc6IDE5MixcbiAgJy0nOiBpc2ZmID8gMTczIDogMTg5LFxuICAnPSc6IGlzZmYgPyA2MSA6IDE4NyxcbiAgJzsnOiBpc2ZmID8gNTkgOiAxODYsXG4gICdcXCcnOiAyMjIsXG4gICdbJzogMjE5LFxuICAnXSc6IDIyMSxcbiAgJ1xcXFwnOiAyMjBcbn07IC8vIE1vZGlmaWVyIEtleXNcblxudmFyIF9tb2RpZmllciA9IHtcbiAgLy8gc2hpZnRLZXlcbiAgJ+KHpyc6IDE2LFxuICBzaGlmdDogMTYsXG4gIC8vIGFsdEtleVxuICAn4oylJzogMTgsXG4gIGFsdDogMTgsXG4gIG9wdGlvbjogMTgsXG4gIC8vIGN0cmxLZXlcbiAgJ+KMgyc6IDE3LFxuICBjdHJsOiAxNyxcbiAgY29udHJvbDogMTcsXG4gIC8vIG1ldGFLZXlcbiAgJ+KMmCc6IDkxLFxuICBjbWQ6IDkxLFxuICBjb21tYW5kOiA5MVxufTtcbnZhciBtb2RpZmllck1hcCA9IHtcbiAgMTY6ICdzaGlmdEtleScsXG4gIDE4OiAnYWx0S2V5JyxcbiAgMTc6ICdjdHJsS2V5JyxcbiAgOTE6ICdtZXRhS2V5JyxcbiAgc2hpZnRLZXk6IDE2LFxuICBjdHJsS2V5OiAxNyxcbiAgYWx0S2V5OiAxOCxcbiAgbWV0YUtleTogOTFcbn07XG52YXIgX21vZHMgPSB7XG4gIDE2OiBmYWxzZSxcbiAgMTg6IGZhbHNlLFxuICAxNzogZmFsc2UsXG4gIDkxOiBmYWxzZVxufTtcbnZhciBfaGFuZGxlcnMgPSB7fTsgLy8gRjF+RjEyIHNwZWNpYWwga2V5XG5cbmZvciAodmFyIGsgPSAxOyBrIDwgMjA7IGsrKykge1xuICBfa2V5TWFwW1wiZlwiLmNvbmNhdChrKV0gPSAxMTEgKyBrO1xufVxuXG52YXIgX2Rvd25LZXlzID0gW107IC8vIOiusOW9leaRgeS4i+eahOe7keWumumUrlxuXG52YXIgX3Njb3BlID0gJ2FsbCc7IC8vIOm7mOiupOeDremUruiMg+WbtFxuXG52YXIgZWxlbWVudEhhc0JpbmRFdmVudCA9IFtdOyAvLyDlt7Lnu5Hlrprkuovku7bnmoToioLngrnorrDlvZVcbi8vIOi/lOWbnumUrueggVxuXG52YXIgY29kZSA9IGZ1bmN0aW9uIGNvZGUoeCkge1xuICByZXR1cm4gX2tleU1hcFt4LnRvTG93ZXJDYXNlKCldIHx8IF9tb2RpZmllclt4LnRvTG93ZXJDYXNlKCldIHx8IHgudG9VcHBlckNhc2UoKS5jaGFyQ29kZUF0KDApO1xufTsgLy8g6K6+572u6I635Y+W5b2T5YmN6IyD5Zu077yI6buY6K6k5Li6J+aJgOaciSfvvIlcblxuXG5mdW5jdGlvbiBzZXRTY29wZShzY29wZSkge1xuICBfc2NvcGUgPSBzY29wZSB8fCAnYWxsJztcbn0gLy8g6I635Y+W5b2T5YmN6IyD5Zu0XG5cblxuZnVuY3Rpb24gZ2V0U2NvcGUoKSB7XG4gIHJldHVybiBfc2NvcGUgfHwgJ2FsbCc7XG59IC8vIOiOt+WPluaRgeS4i+e7keWumumUrueahOmUruWAvFxuXG5cbmZ1bmN0aW9uIGdldFByZXNzZWRLZXlDb2RlcygpIHtcbiAgcmV0dXJuIF9kb3duS2V5cy5zbGljZSgwKTtcbn0gLy8g6KGo5Y2V5o6n5Lu25o6n5Lu25Yik5patIOi/lOWbniBCb29sZWFuXG4vLyBob3RrZXkgaXMgZWZmZWN0aXZlIG9ubHkgd2hlbiBmaWx0ZXIgcmV0dXJuIHRydWVcblxuXG5mdW5jdGlvbiBmaWx0ZXIoZXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldCB8fCBldmVudC5zcmNFbGVtZW50O1xuICB2YXIgdGFnTmFtZSA9IHRhcmdldC50YWdOYW1lO1xuICB2YXIgZmxhZyA9IHRydWU7IC8vIGlnbm9yZTogaXNDb250ZW50RWRpdGFibGUgPT09ICd0cnVlJywgPGlucHV0PiBhbmQgPHRleHRhcmVhPiB3aGVuIHJlYWRPbmx5IHN0YXRlIGlzIGZhbHNlLCA8c2VsZWN0PlxuXG4gIGlmICh0YXJnZXQuaXNDb250ZW50RWRpdGFibGUgfHwgKHRhZ05hbWUgPT09ICdJTlBVVCcgfHwgdGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyB8fCB0YWdOYW1lID09PSAnU0VMRUNUJykgJiYgIXRhcmdldC5yZWFkT25seSkge1xuICAgIGZsYWcgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBmbGFnO1xufSAvLyDliKTmlq3mkYHkuIvnmoTplK7mmK/lkKbkuLrmn5DkuKrplK7vvIzov5Tlm550cnVl5oiW6ICFZmFsc2VcblxuXG5mdW5jdGlvbiBpc1ByZXNzZWQoa2V5Q29kZSkge1xuICBpZiAodHlwZW9mIGtleUNvZGUgPT09ICdzdHJpbmcnKSB7XG4gICAga2V5Q29kZSA9IGNvZGUoa2V5Q29kZSk7IC8vIOi9rOaNouaIkOmUrueggVxuICB9XG5cbiAgcmV0dXJuIF9kb3duS2V5cy5pbmRleE9mKGtleUNvZGUpICE9PSAtMTtcbn0gLy8g5b6q546v5Yig6ZmkaGFuZGxlcnPkuK3nmoTmiYDmnIkgc2NvcGUo6IyD5Zu0KVxuXG5cbmZ1bmN0aW9uIGRlbGV0ZVNjb3BlKHNjb3BlLCBuZXdTY29wZSkge1xuICB2YXIgaGFuZGxlcnM7XG4gIHZhciBpOyAvLyDmsqHmnInmjIflrppzY29wZe+8jOiOt+WPlnNjb3BlXG5cbiAgaWYgKCFzY29wZSkgc2NvcGUgPSBnZXRTY29wZSgpO1xuXG4gIGZvciAodmFyIGtleSBpbiBfaGFuZGxlcnMpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9oYW5kbGVycywga2V5KSkge1xuICAgICAgaGFuZGxlcnMgPSBfaGFuZGxlcnNba2V5XTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDspIHtcbiAgICAgICAgaWYgKGhhbmRsZXJzW2ldLnNjb3BlID09PSBzY29wZSkgaGFuZGxlcnMuc3BsaWNlKGksIDEpO2Vsc2UgaSsrO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyDlpoLmnpxzY29wZeiiq+WIoOmZpO+8jOWwhnNjb3Bl6YeN572u5Li6YWxsXG5cblxuICBpZiAoZ2V0U2NvcGUoKSA9PT0gc2NvcGUpIHNldFNjb3BlKG5ld1Njb3BlIHx8ICdhbGwnKTtcbn0gLy8g5riF6Zmk5L+u6aWw6ZSuXG5cblxuZnVuY3Rpb24gY2xlYXJNb2RpZmllcihldmVudCkge1xuICB2YXIga2V5ID0gZXZlbnQua2V5Q29kZSB8fCBldmVudC53aGljaCB8fCBldmVudC5jaGFyQ29kZTtcblxuICB2YXIgaSA9IF9kb3duS2V5cy5pbmRleE9mKGtleSk7IC8vIOS7juWIl+ihqOS4rea4hemZpOaMieWOi+i/h+eahOmUrlxuXG5cbiAgaWYgKGkgPj0gMCkge1xuICAgIF9kb3duS2V5cy5zcGxpY2UoaSwgMSk7XG4gIH0gLy8g54m55q6K5aSE55CGIGNtbWFuZCDplK7vvIzlnKggY21tYW5kIOe7hOWQiOW/q+aNt+mUriBrZXl1cCDlj6rmiafooYzkuIDmrKHnmoTpl67pophcblxuXG4gIGlmIChldmVudC5rZXkgJiYgZXZlbnQua2V5LnRvTG93ZXJDYXNlKCkgPT09ICdtZXRhJykge1xuICAgIF9kb3duS2V5cy5zcGxpY2UoMCwgX2Rvd25LZXlzLmxlbmd0aCk7XG4gIH0gLy8g5L+u6aWw6ZSuIHNoaWZ0S2V5IGFsdEtleSBjdHJsS2V5IChjb21tYW5kfHxtZXRhS2V5KSDmuIXpmaRcblxuXG4gIGlmIChrZXkgPT09IDkzIHx8IGtleSA9PT0gMjI0KSBrZXkgPSA5MTtcblxuICBpZiAoa2V5IGluIF9tb2RzKSB7XG4gICAgX21vZHNba2V5XSA9IGZhbHNlOyAvLyDlsIbkv67ppbDplK7ph43nva7kuLpmYWxzZVxuXG4gICAgZm9yICh2YXIgayBpbiBfbW9kaWZpZXIpIHtcbiAgICAgIGlmIChfbW9kaWZpZXJba10gPT09IGtleSkgaG90a2V5c1trXSA9IGZhbHNlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1bmJpbmQoa2V5c0luZm8pIHtcbiAgLy8gdW5iaW5kKCksIHVuYmluZCBhbGwga2V5c1xuICBpZiAoIWtleXNJbmZvKSB7XG4gICAgT2JqZWN0LmtleXMoX2hhbmRsZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBkZWxldGUgX2hhbmRsZXJzW2tleV07XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShrZXlzSW5mbykpIHtcbiAgICAvLyBzdXBwb3J0IGxpa2UgOiB1bmJpbmQoW3trZXk6ICdjdHJsK2EnLCBzY29wZTogJ3MxJ30sIHtrZXk6ICdjdHJsLWEnLCBzY29wZTogJ3MyJywgc3BsaXRLZXk6ICctJ31dKVxuICAgIGtleXNJbmZvLmZvckVhY2goZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgIGlmIChpbmZvLmtleSkgZWFjaFVuYmluZChpbmZvKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2Yga2V5c0luZm8gPT09ICdvYmplY3QnKSB7XG4gICAgLy8gc3VwcG9ydCBsaWtlIHVuYmluZCh7a2V5OiAnY3RybCthLCBjdHJsK2InLCBzY29wZTonYWJjJ30pXG4gICAgaWYgKGtleXNJbmZvLmtleSkgZWFjaFVuYmluZChrZXlzSW5mbyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGtleXNJbmZvID09PSAnc3RyaW5nJykge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIC8vIHN1cHBvcnQgb2xkIG1ldGhvZFxuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB2YXIgc2NvcGUgPSBhcmdzWzBdLFxuICAgICAgICBtZXRob2QgPSBhcmdzWzFdO1xuXG4gICAgaWYgKHR5cGVvZiBzY29wZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbWV0aG9kID0gc2NvcGU7XG4gICAgICBzY29wZSA9ICcnO1xuICAgIH1cblxuICAgIGVhY2hVbmJpbmQoe1xuICAgICAga2V5OiBrZXlzSW5mbyxcbiAgICAgIHNjb3BlOiBzY29wZSxcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgc3BsaXRLZXk6ICcrJ1xuICAgIH0pO1xuICB9XG59IC8vIOino+mZpOe7keWumuafkOS4quiMg+WbtOeahOW/q+aNt+mUrlxuXG5cbnZhciBlYWNoVW5iaW5kID0gZnVuY3Rpb24gZWFjaFVuYmluZChfcmVmKSB7XG4gIHZhciBrZXkgPSBfcmVmLmtleSxcbiAgICAgIHNjb3BlID0gX3JlZi5zY29wZSxcbiAgICAgIG1ldGhvZCA9IF9yZWYubWV0aG9kLFxuICAgICAgX3JlZiRzcGxpdEtleSA9IF9yZWYuc3BsaXRLZXksXG4gICAgICBzcGxpdEtleSA9IF9yZWYkc3BsaXRLZXkgPT09IHZvaWQgMCA/ICcrJyA6IF9yZWYkc3BsaXRLZXk7XG4gIHZhciBtdWx0aXBsZUtleXMgPSBnZXRLZXlzKGtleSk7XG4gIG11bHRpcGxlS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChvcmlnaW5LZXkpIHtcbiAgICB2YXIgdW5iaW5kS2V5cyA9IG9yaWdpbktleS5zcGxpdChzcGxpdEtleSk7XG4gICAgdmFyIGxlbiA9IHVuYmluZEtleXMubGVuZ3RoO1xuICAgIHZhciBsYXN0S2V5ID0gdW5iaW5kS2V5c1tsZW4gLSAxXTtcbiAgICB2YXIga2V5Q29kZSA9IGxhc3RLZXkgPT09ICcqJyA/ICcqJyA6IGNvZGUobGFzdEtleSk7XG4gICAgaWYgKCFfaGFuZGxlcnNba2V5Q29kZV0pIHJldHVybjsgLy8g5Yik5pat5piv5ZCm5Lyg5YWl6IyD5Zu077yM5rKh5pyJ5bCx6I635Y+W6IyD5Zu0XG5cbiAgICBpZiAoIXNjb3BlKSBzY29wZSA9IGdldFNjb3BlKCk7XG4gICAgdmFyIG1vZHMgPSBsZW4gPiAxID8gZ2V0TW9kcyhfbW9kaWZpZXIsIHVuYmluZEtleXMpIDogW107XG4gICAgX2hhbmRsZXJzW2tleUNvZGVdID0gX2hhbmRsZXJzW2tleUNvZGVdLm1hcChmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAvLyDpgJrov4flh73mlbDliKTmlq3vvIzmmK/lkKbop6PpmaTnu5HlrprvvIzlh73mlbDnm7jnrYnnm7TmjqXov5Tlm55cbiAgICAgIHZhciBpc01hdGNoaW5nTWV0aG9kID0gbWV0aG9kID8gcmVjb3JkLm1ldGhvZCA9PT0gbWV0aG9kIDogdHJ1ZTtcblxuICAgICAgaWYgKGlzTWF0Y2hpbmdNZXRob2QgJiYgcmVjb3JkLnNjb3BlID09PSBzY29wZSAmJiBjb21wYXJlQXJyYXkocmVjb3JkLm1vZHMsIG1vZHMpKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICB9KTtcbiAgfSk7XG59OyAvLyDlr7nnm5HlkKzlr7nlupTlv6vmjbfplK7nmoTlm57osIPlh73mlbDov5vooYzlpITnkIZcblxuXG5mdW5jdGlvbiBldmVudEhhbmRsZXIoZXZlbnQsIGhhbmRsZXIsIHNjb3BlKSB7XG4gIHZhciBtb2RpZmllcnNNYXRjaDsgLy8g55yL5a6D5piv5ZCm5Zyo5b2T5YmN6IyD5Zu0XG5cbiAgaWYgKGhhbmRsZXIuc2NvcGUgPT09IHNjb3BlIHx8IGhhbmRsZXIuc2NvcGUgPT09ICdhbGwnKSB7XG4gICAgLy8g5qOA5p+l5piv5ZCm5Yy56YWN5L+u6aWw56ym77yI5aaC5p6c5pyJ6L+U5ZuedHJ1Ze+8iVxuICAgIG1vZGlmaWVyc01hdGNoID0gaGFuZGxlci5tb2RzLmxlbmd0aCA+IDA7XG5cbiAgICBmb3IgKHZhciB5IGluIF9tb2RzKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9tb2RzLCB5KSkge1xuICAgICAgICBpZiAoIV9tb2RzW3ldICYmIGhhbmRsZXIubW9kcy5pbmRleE9mKCt5KSA+IC0xIHx8IF9tb2RzW3ldICYmIGhhbmRsZXIubW9kcy5pbmRleE9mKCt5KSA9PT0gLTEpIHtcbiAgICAgICAgICBtb2RpZmllcnNNYXRjaCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyDosIPnlKjlpITnkIbnqIvluo/vvIzlpoLmnpzmmK/kv67ppbDplK7kuI3lgZrlpITnkIZcblxuXG4gICAgaWYgKGhhbmRsZXIubW9kcy5sZW5ndGggPT09IDAgJiYgIV9tb2RzWzE2XSAmJiAhX21vZHNbMThdICYmICFfbW9kc1sxN10gJiYgIV9tb2RzWzkxXSB8fCBtb2RpZmllcnNNYXRjaCB8fCBoYW5kbGVyLnNob3J0Y3V0ID09PSAnKicpIHtcbiAgICAgIGlmIChoYW5kbGVyLm1ldGhvZChldmVudCwgaGFuZGxlcikgPT09IGZhbHNlKSB7XG4gICAgICAgIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdCkgZXZlbnQucHJldmVudERlZmF1bHQoKTtlbHNlIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24pIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBpZiAoZXZlbnQuY2FuY2VsQnViYmxlKSBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSAvLyDlpITnkIZrZXlkb3du5LqL5Lu2XG5cblxuZnVuY3Rpb24gZGlzcGF0Y2goZXZlbnQpIHtcbiAgdmFyIGFzdGVyaXNrID0gX2hhbmRsZXJzWycqJ107XG4gIHZhciBrZXkgPSBldmVudC5rZXlDb2RlIHx8IGV2ZW50LndoaWNoIHx8IGV2ZW50LmNoYXJDb2RlOyAvLyDooajljZXmjqfku7bov4fmu6Qg6buY6K6k6KGo5Y2V5o6n5Lu25LiN6Kem5Y+R5b+r5o236ZSuXG5cbiAgaWYgKCFob3RrZXlzLmZpbHRlci5jYWxsKHRoaXMsIGV2ZW50KSkgcmV0dXJuOyAvLyBHZWNrbyhGaXJlZm94KeeahGNvbW1hbmTplK7lgLwyMjTvvIzlnKhXZWJraXQoQ2hyb21lKeS4reS/neaMgeS4gOiHtFxuICAvLyBXZWJraXTlt6blj7MgY29tbWFuZCDplK7lgLzkuI3kuIDmoLdcblxuICBpZiAoa2V5ID09PSA5MyB8fCBrZXkgPT09IDIyNCkga2V5ID0gOTE7XG4gIC8qKlxuICAgKiBDb2xsZWN0IGJvdW5kIGtleXNcbiAgICogSWYgYW4gSW5wdXQgTWV0aG9kIEVkaXRvciBpcyBwcm9jZXNzaW5nIGtleSBpbnB1dCBhbmQgdGhlIGV2ZW50IGlzIGtleWRvd24sIHJldHVybiAyMjkuXG4gICAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI1MDQzOTM0L2lzLWl0LW9rLXRvLWlnbm9yZS1rZXlkb3duLWV2ZW50cy13aXRoLWtleWNvZGUtMjI5XG4gICAqIGh0dHA6Ly9saXN0cy53My5vcmcvQXJjaGl2ZXMvUHVibGljL3d3dy1kb20vMjAxMEp1bFNlcC9hdHQtMDE4Mi9rZXlDb2RlLXNwZWMuaHRtbFxuICAgKi9cblxuICBpZiAoX2Rvd25LZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTEgJiYga2V5ICE9PSAyMjkpIF9kb3duS2V5cy5wdXNoKGtleSk7XG4gIC8qKlxuICAgKiBKZXN0IHRlc3QgY2FzZXMgYXJlIHJlcXVpcmVkLlxuICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAqL1xuXG4gIFsnY3RybEtleScsICdhbHRLZXknLCAnc2hpZnRLZXknLCAnbWV0YUtleSddLmZvckVhY2goZnVuY3Rpb24gKGtleU5hbWUpIHtcbiAgICB2YXIga2V5TnVtID0gbW9kaWZpZXJNYXBba2V5TmFtZV07XG5cbiAgICBpZiAoZXZlbnRba2V5TmFtZV0gJiYgX2Rvd25LZXlzLmluZGV4T2Yoa2V5TnVtKSA9PT0gLTEpIHtcbiAgICAgIF9kb3duS2V5cy5wdXNoKGtleU51bSk7XG4gICAgfSBlbHNlIGlmICghZXZlbnRba2V5TmFtZV0gJiYgX2Rvd25LZXlzLmluZGV4T2Yoa2V5TnVtKSA+IC0xKSB7XG4gICAgICBfZG93bktleXMuc3BsaWNlKF9kb3duS2V5cy5pbmRleE9mKGtleU51bSksIDEpO1xuICAgIH0gZWxzZSBpZiAoa2V5TmFtZSA9PT0gJ21ldGFLZXknICYmIGV2ZW50W2tleU5hbWVdICYmIF9kb3duS2V5cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIC8qKlxuICAgICAgICogRml4IGlmIENvbW1hbmQgaXMgcHJlc3NlZDpcbiAgICAgICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAqL1xuICAgICAgaWYgKCEoZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSB8fCBldmVudC5hbHRLZXkpKSB7XG4gICAgICAgIF9kb3duS2V5cyA9IF9kb3duS2V5cy5zbGljZShfZG93bktleXMuaW5kZXhPZihrZXlOdW0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICBpZiAoa2V5IGluIF9tb2RzKSB7XG4gICAgX21vZHNba2V5XSA9IHRydWU7IC8vIOWwhueJueauiuWtl+espueahGtleeazqOWGjOWIsCBob3RrZXlzIOS4ilxuXG4gICAgZm9yICh2YXIgayBpbiBfbW9kaWZpZXIpIHtcbiAgICAgIGlmIChfbW9kaWZpZXJba10gPT09IGtleSkgaG90a2V5c1trXSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCFhc3RlcmlzaykgcmV0dXJuO1xuICB9IC8vIOWwhiBtb2RpZmllck1hcCDph4zpnaLnmoTkv67ppbDplK7nu5HlrprliLAgZXZlbnQg5LitXG5cblxuICBmb3IgKHZhciBlIGluIF9tb2RzKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfbW9kcywgZSkpIHtcbiAgICAgIF9tb2RzW2VdID0gZXZlbnRbbW9kaWZpZXJNYXBbZV1dO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL2pheXdjamxvdmUvaG90a2V5cy9wdWxsLzEyOVxuICAgKiBUaGlzIHNvbHZlcyB0aGUgaXNzdWUgaW4gRmlyZWZveCBvbiBXaW5kb3dzIHdoZXJlIGhvdGtleXMgY29ycmVzcG9uZGluZyB0byBzcGVjaWFsIGNoYXJhY3RlcnMgd291bGQgbm90IHRyaWdnZXIuXG4gICAqIEFuIGV4YW1wbGUgb2YgdGhpcyBpcyBjdHJsK2FsdCttIG9uIGEgU3dlZGlzaCBrZXlib2FyZCB3aGljaCBpcyB1c2VkIHRvIHR5cGUgzrwuXG4gICAqIEJyb3dzZXIgc3VwcG9ydDogaHR0cHM6Ly9jYW5pdXNlLmNvbS8jZmVhdD1rZXlib2FyZGV2ZW50LWdldG1vZGlmaWVyc3RhdGVcbiAgICovXG5cblxuICBpZiAoZXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZSAmJiAhKGV2ZW50LmFsdEtleSAmJiAhZXZlbnQuY3RybEtleSkgJiYgZXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZSgnQWx0R3JhcGgnKSkge1xuICAgIGlmIChfZG93bktleXMuaW5kZXhPZigxNykgPT09IC0xKSB7XG4gICAgICBfZG93bktleXMucHVzaCgxNyk7XG4gICAgfVxuXG4gICAgaWYgKF9kb3duS2V5cy5pbmRleE9mKDE4KSA9PT0gLTEpIHtcbiAgICAgIF9kb3duS2V5cy5wdXNoKDE4KTtcbiAgICB9XG5cbiAgICBfbW9kc1sxN10gPSB0cnVlO1xuICAgIF9tb2RzWzE4XSA9IHRydWU7XG4gIH0gLy8g6I635Y+W6IyD5Zu0IOm7mOiupOS4uiBgYWxsYFxuXG5cbiAgdmFyIHNjb3BlID0gZ2V0U2NvcGUoKTsgLy8g5a+55Lu75L2V5b+r5o236ZSu6YO96ZyA6KaB5YGa55qE5aSE55CGXG5cbiAgaWYgKGFzdGVyaXNrKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhc3Rlcmlzay5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFzdGVyaXNrW2ldLnNjb3BlID09PSBzY29wZSAmJiAoZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nICYmIGFzdGVyaXNrW2ldLmtleWRvd24gfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJyAmJiBhc3Rlcmlza1tpXS5rZXl1cCkpIHtcbiAgICAgICAgZXZlbnRIYW5kbGVyKGV2ZW50LCBhc3Rlcmlza1tpXSwgc2NvcGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBrZXkg5LiN5ZyoIF9oYW5kbGVycyDkuK3ov5Tlm55cblxuXG4gIGlmICghKGtleSBpbiBfaGFuZGxlcnMpKSByZXR1cm47XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IF9oYW5kbGVyc1trZXldLmxlbmd0aDsgX2krKykge1xuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgJiYgX2hhbmRsZXJzW2tleV1bX2ldLmtleWRvd24gfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJyAmJiBfaGFuZGxlcnNba2V5XVtfaV0ua2V5dXApIHtcbiAgICAgIGlmIChfaGFuZGxlcnNba2V5XVtfaV0ua2V5KSB7XG4gICAgICAgIHZhciByZWNvcmQgPSBfaGFuZGxlcnNba2V5XVtfaV07XG4gICAgICAgIHZhciBzcGxpdEtleSA9IHJlY29yZC5zcGxpdEtleTtcbiAgICAgICAgdmFyIGtleVNob3J0Y3V0ID0gcmVjb3JkLmtleS5zcGxpdChzcGxpdEtleSk7XG4gICAgICAgIHZhciBfZG93bktleXNDdXJyZW50ID0gW107IC8vIOiusOW9leW9k+WJjeaMiemUrumUruWAvFxuXG4gICAgICAgIGZvciAodmFyIGEgPSAwOyBhIDwga2V5U2hvcnRjdXQubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgICBfZG93bktleXNDdXJyZW50LnB1c2goY29kZShrZXlTaG9ydGN1dFthXSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9kb3duS2V5c0N1cnJlbnQuc29ydCgpLmpvaW4oJycpID09PSBfZG93bktleXMuc29ydCgpLmpvaW4oJycpKSB7XG4gICAgICAgICAgLy8g5om+5Yiw5aSE55CG5YaF5a65XG4gICAgICAgICAgZXZlbnRIYW5kbGVyKGV2ZW50LCByZWNvcmQsIHNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSAvLyDliKTmlq0gZWxlbWVudCDmmK/lkKblt7Lnu4/nu5Hlrprkuovku7ZcblxuXG5mdW5jdGlvbiBpc0VsZW1lbnRCaW5kKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnRIYXNCaW5kRXZlbnQuaW5kZXhPZihlbGVtZW50KSA+IC0xO1xufVxuXG5mdW5jdGlvbiBob3RrZXlzKGtleSwgb3B0aW9uLCBtZXRob2QpIHtcbiAgX2Rvd25LZXlzID0gW107XG4gIHZhciBrZXlzID0gZ2V0S2V5cyhrZXkpOyAvLyDpnIDopoHlpITnkIbnmoTlv6vmjbfplK7liJfooahcblxuICB2YXIgbW9kcyA9IFtdO1xuICB2YXIgc2NvcGUgPSAnYWxsJzsgLy8gc2NvcGXpu5jorqTkuLphbGzvvIzmiYDmnInojIPlm7Tpg73mnInmlYhcblxuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50OyAvLyDlv6vmjbfplK7kuovku7bnu5HlrproioLngrlcblxuICB2YXIgaSA9IDA7XG4gIHZhciBrZXl1cCA9IGZhbHNlO1xuICB2YXIga2V5ZG93biA9IHRydWU7XG4gIHZhciBzcGxpdEtleSA9ICcrJzsgLy8g5a+55Li66K6+5a6a6IyD5Zu055qE5Yik5patXG5cbiAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvcHRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBtZXRob2QgPSBvcHRpb247XG4gIH1cblxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9wdGlvbikgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgaWYgKG9wdGlvbi5zY29wZSkgc2NvcGUgPSBvcHRpb24uc2NvcGU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgIGlmIChvcHRpb24uZWxlbWVudCkgZWxlbWVudCA9IG9wdGlvbi5lbGVtZW50OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICBpZiAob3B0aW9uLmtleXVwKSBrZXl1cCA9IG9wdGlvbi5rZXl1cDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgaWYgKG9wdGlvbi5rZXlkb3duICE9PSB1bmRlZmluZWQpIGtleWRvd24gPSBvcHRpb24ua2V5ZG93bjsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb24uc3BsaXRLZXkgPT09ICdzdHJpbmcnKSBzcGxpdEtleSA9IG9wdGlvbi5zcGxpdEtleTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICB9XG5cbiAgaWYgKHR5cGVvZiBvcHRpb24gPT09ICdzdHJpbmcnKSBzY29wZSA9IG9wdGlvbjsgLy8g5a+55LqO5q+P5Liq5b+r5o236ZSu6L+b6KGM5aSE55CGXG5cbiAgZm9yICg7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0ga2V5c1tpXS5zcGxpdChzcGxpdEtleSk7IC8vIOaMiemUruWIl+ihqFxuXG4gICAgbW9kcyA9IFtdOyAvLyDlpoLmnpzmmK/nu4TlkIjlv6vmjbfplK7lj5blvpfnu4TlkIjlv6vmjbfplK5cblxuICAgIGlmIChrZXkubGVuZ3RoID4gMSkgbW9kcyA9IGdldE1vZHMoX21vZGlmaWVyLCBrZXkpOyAvLyDlsIbpnZ7kv67ppbDplK7ovazljJbkuLrplK7noIFcblxuICAgIGtleSA9IGtleVtrZXkubGVuZ3RoIC0gMV07XG4gICAga2V5ID0ga2V5ID09PSAnKicgPyAnKicgOiBjb2RlKGtleSk7IC8vICrooajnpLrljLnphY3miYDmnInlv6vmjbfplK5cbiAgICAvLyDliKTmlq1rZXnmmK/lkKblnKhfaGFuZGxlcnPkuK3vvIzkuI3lnKjlsLHotYvkuIDkuKrnqbrmlbDnu4RcblxuICAgIGlmICghKGtleSBpbiBfaGFuZGxlcnMpKSBfaGFuZGxlcnNba2V5XSA9IFtdO1xuXG4gICAgX2hhbmRsZXJzW2tleV0ucHVzaCh7XG4gICAgICBrZXl1cDoga2V5dXAsXG4gICAgICBrZXlkb3duOiBrZXlkb3duLFxuICAgICAgc2NvcGU6IHNjb3BlLFxuICAgICAgbW9kczogbW9kcyxcbiAgICAgIHNob3J0Y3V0OiBrZXlzW2ldLFxuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICBrZXk6IGtleXNbaV0sXG4gICAgICBzcGxpdEtleTogc3BsaXRLZXlcbiAgICB9KTtcbiAgfSAvLyDlnKjlhajlsYBkb2N1bWVudOS4iuiuvue9ruW/q+aNt+mUrlxuXG5cbiAgaWYgKHR5cGVvZiBlbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhaXNFbGVtZW50QmluZChlbGVtZW50KSAmJiB3aW5kb3cpIHtcbiAgICBlbGVtZW50SGFzQmluZEV2ZW50LnB1c2goZWxlbWVudCk7XG4gICAgYWRkRXZlbnQoZWxlbWVudCwgJ2tleWRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgZGlzcGF0Y2goZSk7XG4gICAgfSk7XG4gICAgYWRkRXZlbnQod2luZG93LCAnZm9jdXMnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfZG93bktleXMgPSBbXTtcbiAgICB9KTtcbiAgICBhZGRFdmVudChlbGVtZW50LCAna2V5dXAnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgZGlzcGF0Y2goZSk7XG4gICAgICBjbGVhck1vZGlmaWVyKGUpO1xuICAgIH0pO1xuICB9XG59XG5cbnZhciBfYXBpID0ge1xuICBzZXRTY29wZTogc2V0U2NvcGUsXG4gIGdldFNjb3BlOiBnZXRTY29wZSxcbiAgZGVsZXRlU2NvcGU6IGRlbGV0ZVNjb3BlLFxuICBnZXRQcmVzc2VkS2V5Q29kZXM6IGdldFByZXNzZWRLZXlDb2RlcyxcbiAgaXNQcmVzc2VkOiBpc1ByZXNzZWQsXG4gIGZpbHRlcjogZmlsdGVyLFxuICB1bmJpbmQ6IHVuYmluZFxufTtcblxuZm9yICh2YXIgYSBpbiBfYXBpKSB7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX2FwaSwgYSkpIHtcbiAgICBob3RrZXlzW2FdID0gX2FwaVthXTtcbiAgfVxufVxuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgdmFyIF9ob3RrZXlzID0gd2luZG93LmhvdGtleXM7XG5cbiAgaG90a2V5cy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKGRlZXApIHtcbiAgICBpZiAoZGVlcCAmJiB3aW5kb3cuaG90a2V5cyA9PT0gaG90a2V5cykge1xuICAgICAgd2luZG93LmhvdGtleXMgPSBfaG90a2V5cztcbiAgICB9XG5cbiAgICByZXR1cm4gaG90a2V5cztcbiAgfTtcblxuICB3aW5kb3cuaG90a2V5cyA9IGhvdGtleXM7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhvdGtleXM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/hotkeys-js/dist/hotkeys.esm.js\n");

/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/*!*****************************************!*\
  !*** ./node_modules/tslib/tslib.es6.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"__extends\": () => (/* binding */ __extends),\n/* harmony export */   \"__assign\": () => (/* binding */ __assign),\n/* harmony export */   \"__rest\": () => (/* binding */ __rest),\n/* harmony export */   \"__decorate\": () => (/* binding */ __decorate),\n/* harmony export */   \"__param\": () => (/* binding */ __param),\n/* harmony export */   \"__metadata\": () => (/* binding */ __metadata),\n/* harmony export */   \"__awaiter\": () => (/* binding */ __awaiter),\n/* harmony export */   \"__generator\": () => (/* binding */ __generator),\n/* harmony export */   \"__createBinding\": () => (/* binding */ __createBinding),\n/* harmony export */   \"__exportStar\": () => (/* binding */ __exportStar),\n/* harmony export */   \"__values\": () => (/* binding */ __values),\n/* harmony export */   \"__read\": () => (/* binding */ __read),\n/* harmony export */   \"__spread\": () => (/* binding */ __spread),\n/* harmony export */   \"__spreadArrays\": () => (/* binding */ __spreadArrays),\n/* harmony export */   \"__spreadArray\": () => (/* binding */ __spreadArray),\n/* harmony export */   \"__await\": () => (/* binding */ __await),\n/* harmony export */   \"__asyncGenerator\": () => (/* binding */ __asyncGenerator),\n/* harmony export */   \"__asyncDelegator\": () => (/* binding */ __asyncDelegator),\n/* harmony export */   \"__asyncValues\": () => (/* binding */ __asyncValues),\n/* harmony export */   \"__makeTemplateObject\": () => (/* binding */ __makeTemplateObject),\n/* harmony export */   \"__importStar\": () => (/* binding */ __importStar),\n/* harmony export */   \"__importDefault\": () => (/* binding */ __importDefault),\n/* harmony export */   \"__classPrivateFieldGet\": () => (/* binding */ __classPrivateFieldGet),\n/* harmony export */   \"__classPrivateFieldSet\": () => (/* binding */ __classPrivateFieldSet)\n/* harmony export */ });\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nfunction __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q087QUFDUDtBQUNBO0FBQ0EsMkdBQTJHLHVGQUF1RixjQUFjO0FBQ2hOLHVCQUF1Qiw4QkFBOEIsZ0RBQWdELHdEQUF3RDtBQUM3Siw2Q0FBNkMsc0NBQXNDLFVBQVUsbUJBQW1CLElBQUk7QUFDcEg7QUFDQTtBQUNPO0FBQ1AsaUNBQWlDLHVDQUF1QyxZQUFZLEtBQUssT0FBTztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZDQUE2QztBQUM3QztBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXhmbG93Ly4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcz85YWI0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fY3JlYXRlQmluZGluZyA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgbykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tslib/tslib.es6.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});